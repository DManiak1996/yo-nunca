{
  "url": "https://nextjs.org/docs/pages/api-reference/functions/get-static-paths",
  "title": "getStaticPaths",
  "content": "When exporting a function called getStaticPaths from a page that uses Dynamic Routes, Next.js will statically pre-render all the paths specified by getStaticPaths.\n\nThe getStaticPaths function should return an object with the following required properties:\n\nThe paths key determines which paths will be pre-rendered. For example, suppose that you have a page that uses Dynamic Routes named pages/posts/[id].js. If you export getStaticPaths from this page and return the following for paths:\n\nThen, Next.js will statically generate /posts/1 and /posts/2 during next build using the page component in pages/posts/[id].js.\n\nThe value for each params object must match the parameters used in the page name:\n\nThe params strings are case-sensitive and ideally should be normalized to ensure the paths are generated correctly. For example, if WoRLD is returned for a param it will only match if WoRLD is the actual path visited, not world or World.\n\nSeparate of the params object a locale field can be returned when i18n is configured, which configures the locale for the path being generated.\n\nIf fallback is false, then any paths not returned by getStaticPaths will result in a 404 page.\n\nWhen next build is run, Next.js will check if getStaticPaths returned fallback: false, it will then build only the paths returned by getStaticPaths. This option is useful if you have a small number of paths to create, or new page data is not added often. If you find that you need to add more paths, and you have fallback: false, you will need to run next build again so that the new paths can be generated.\n\nThe following example pre-renders one blog post per page called pages/posts/[id].js. The list of blog posts will be fetched from a CMS and returned by getStaticPaths. Then, for each page, it fetches the post data from a CMS using getStaticProps.\n\nIf fallback is true, then the behavior of getStaticProps changes in the following ways:\n\nGood to know: fallback: true is not supported when using output: 'export'.\n\nfallback: true is useful if your app has a very large number of static pages that depend on data (such as a very large e-commerce site). If you want to pre-render all product pages, the builds would take a very long time.\n\nInstead, you may statically generate a small subset of pages and use fallback: true for the rest. When someone requests a page that is not generated yet, the user will see the page with a loading indicator or skeleton component.\n\nShortly after, getStaticProps finishes and the page will be rendered with the requested data. From now on, everyone who requests the same page will get the statically pre-rendered page.\n\nThis ensures that users always have a fast experience while preserving fast builds and the benefits of Static Generation.\n\nfallback: true will not update generated pages, for that take a look at Incremental Static Regeneration.\n\nIf fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR (hence why blocking), and then be cached for future requests so it only happens once per path.\n\ngetStaticProps will behave as follows:\n\nfallback: 'blocking' will not update generated pages by default. To update generated pages, use Incremental Static Regeneration in conjunction with fallback: 'blocking'.\n\nGood to know: fallback: 'blocking' is not supported when using output: 'export'.\n\nIn the “fallback” version of a page:\n\nThe following example showcases using isFallback:",
  "headings": [
    {
      "level": "h1",
      "text": "getStaticPaths",
      "id": ""
    },
    {
      "level": "h2",
      "text": "getStaticPaths return values",
      "id": "getstaticpaths-return-values"
    },
    {
      "level": "h3",
      "text": "paths",
      "id": "paths"
    },
    {
      "level": "h3",
      "text": "fallback: false",
      "id": "fallback-false"
    },
    {
      "level": "h3",
      "text": "fallback: true",
      "id": "fallback-true"
    },
    {
      "level": "h4",
      "text": "When is fallback: true useful?",
      "id": "when-is-fallback-true-useful"
    },
    {
      "level": "h3",
      "text": "fallback: 'blocking'",
      "id": "fallback-blocking"
    },
    {
      "level": "h3",
      "text": "Fallback pages",
      "id": "fallback-pages"
    },
    {
      "level": "h2",
      "text": "Version History",
      "id": "version-history"
    }
  ],
  "code_samples": [
    {
      "code": "import type {\n  InferGetStaticPropsType,\n  GetStaticProps,\n  GetStaticPaths,\n} from 'next'\n \ntype Repo = {\n  name: string\n  stargazers_count: number\n}\n \nexport const getStaticPaths = (async () => {\n  return {\n    paths: [\n      {\n        params: {\n          name: 'next.js',\n        },\n      }, // See the \"paths\" section below\n    ],\n    fallback: true, // false or \"blocking\"\n  }\n}) satisfies GetStaticPaths\n \nexport const getStaticProps = (async (context) => {\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\n  const repo = await res.json()\n  return { props: { repo } }\n}) satisfies GetStaticProps<{\n  repo: Repo\n}>\n \nexport default function Page({\n  repo,\n}: InferGetStaticPropsType<typeof getStaticProps>) {\n  return repo.stargazers_count\n}",
      "language": "python"
    },
    {
      "code": "return {\n  paths: [\n    { params: { id: '1' }},\n    {\n      params: { id: '2' },\n      // with i18n configured the locale for the path can be returned as well\n      locale: \"en\",\n    },\n  ],\n  fallback: ...\n}",
      "language": "unknown"
    },
    {
      "code": "function Post({ post }) {\n  // Render post...\n}\n \n// This function gets called at build time\nexport async function getStaticPaths() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n \n  // Get the paths we want to pre-render based on posts\n  const paths = posts.map((post) => ({\n    params: { id: post.id },\n  }))\n \n  // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n  return { paths, fallback: false }\n}\n \n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n \n  // Pass post data to the page via props\n  return { props: { post } }\n}\n \nexport default Post",
      "language": "javascript"
    },
    {
      "code": "import { useRouter } from 'next/router'\n \nfunction Post({ post }) {\n  const router = useRouter()\n \n  // If the page is not yet generated, this will be displayed\n  // initially until getStaticProps() finishes running\n  if (router.isFallback) {\n    return <div>Loading...</div>\n  }\n \n  // Render post...\n}\n \n// This function gets called at build time\nexport async function getStaticPaths() {\n  return {\n    // Only `/posts/1` and `/posts/2` are generated at build time\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\n    // Enable statically generating additional pages\n    // For example: `/posts/3`\n    fallback: true,\n  }\n}\n \n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n \n  // Pass post data to the page via props\n  return {\n    props: { post },\n    // Re-generate the post at most once per second\n    // if a request comes in\n    revalidate: 1,\n  }\n}\n \nexport default Post",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "API ReferenceFunctionsgetStaticPathsCopy pagegetStaticPathsWhen exporting a function called getStaticPaths from a page that uses Dynamic Routes, Next.js will statically pre-render all the paths specified by getStaticPaths. pages/repo/[name].tsxTypeScriptJavaScriptTypeScriptimport type { InferGetStaticPropsType, GetStaticProps, GetStaticPaths, } from 'next' type Repo = { name: string stargazers_count: number } export const getStaticPaths = (async () => { return { paths: [ { params: { name: 'next.js', }, }, // See the \"paths\" section below ], fallback: true, // false or \"blocking\" } }) satisfies GetStaticPaths export const getStaticProps = (async (context) => { const res = await fetch('https://api.github.com/repos/vercel/next.js') const repo = await res.json() return { props: { repo } } }) satisfies GetStaticProps<{ repo: Repo }> export default function Page({ repo, }: InferGetStaticPropsType<typeof getStaticProps>) { return repo.stargazers_count } getStaticPaths return values The getStaticPaths function should return an object with the following required properties: paths The paths key determines which paths will be pre-rendered. For example, suppose that you have a page that uses Dynamic Routes named pages/posts/[id].js. If you export getStaticPaths from this page and return the following for paths: return { paths: [ { params: { id: '1' }}, { params: { id: '2' }, // with i18n configured the locale for the path can be returned as well locale: \"en\", }, ], fallback: ... } Then, Next.js will statically generate /posts/1 and /posts/2 during next build using the page component in pages/posts/[id].js. The value for each params object must match the parameters used in the page name: If the page name is pages/posts/[postId]/[commentId], then params should contain postId and commentId. If the page name uses catch-all routes like pages/[...slug], then params should contain slug (which is an array). If this array is ['hello', 'world'], then Next.js will statically generate the page at /hello/world. If the page uses an optional catch-all route, use null, [], undefined or false to render the root-most route. For example, if you supply slug: false for pages/[[...slug]], Next.js will statically generate the page /. The params strings are case-sensitive and ideally should be normalized to ensure the paths are generated correctly. For example, if WoRLD is returned for a param it will only match if WoRLD is the actual path visited, not world or World. Separate of the params object a locale field can be returned when i18n is configured, which configures the locale for the path being generated. fallback: false If fallback is false, then any paths not returned by getStaticPaths will result in a 404 page. When next build is run, Next.js will check if getStaticPaths returned fallback: false, it will then build only the paths returned by getStaticPaths. This option is useful if you have a small number of paths to create, or new page data is not added often. If you find that you need to add more paths, and you have fallback: false, you will need to run next build again so that the new paths can be generated. The following example pre-renders one blog post per page called pages/posts/[id].js. The list of blog posts will be fetched from a CMS and returned by getStaticPaths. Then, for each page, it fetches the post data from a CMS using getStaticProps. pages/posts/[id].jsfunction Post({ post }) { // Render post... } // This function gets called at build time export async function getStaticPaths() { // Call an external API endpoint to get posts const res = await fetch('https://.../posts') const posts = await res.json() // Get the paths we want to pre-render based on posts const paths = posts.map((post) => ({ params: { id: post.id }, })) // We'll pre-render only these paths at build time. // { fallback: false } means other routes should 404. return { paths, fallback: false } } // This also gets called at build time export async function getStaticProps({ params }) { // params contains the post `id`. // If the route is like /posts/1, then params.id is 1 const res = await fetch(`https://.../posts/${params.id}`) const post = await res.json() // Pass post data to the page via props return { props: { post } } } export default Post fallback: true Examples Static generation of a large number of pages If fallback is true, then the behavior of getStaticProps changes in the following ways: The paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps. The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will serve a “fallback” version of the page on the first request to such a path. Web crawlers, such as Google, won't be served a fallback and instead the path will behave as in fallback: 'blocking'. When a page with fallback: true is navigated to through next/link or next/router (client-side) Next.js will not serve a fallback and instead the page will behave as fallback: 'blocking'. In the background, Next.js will statically generate the requested path HTML and JSON. This includes running getStaticProps. When complete, the browser receives the JSON for the generated path. This will be used to automatically render the page with the required props. From the user’s perspective, the page will be swapped from the fallback page to the full page. At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time. Good to know: fallback: true is not supported when using output: 'export'. When is fallback: true useful? fallback: true is useful if your app has a very large number of static pages that depend on data (such as a very large e-commerce site). If you want to pre-render all product pages, the builds would take a very long time. Instead, you may statically generate a small subset of pages and use fallback: true for the rest. When someone requests a page that is not generated yet, the user will see the page with a loading indicator or skeleton component. Shortly after, getStaticProps finishes and the page will be rendered with the requested data. From now on, everyone who requests the same page will get the statically pre-rendered page. This ensures that users always have a fast experience while preserving fast builds and the benefits of Static Generation. fallback: true will not update generated pages, for that take a look at Incremental Static Regeneration. fallback: 'blocking' If fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR (hence why blocking), and then be cached for future requests so it only happens once per path. getStaticProps will behave as follows: The paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps. The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will SSR on the first request and return the generated HTML. When complete, the browser receives the HTML for the generated path. From the user’s perspective, it will transition from \"the browser is requesting the page\" to \"the full page is loaded\". There is no flash of loading/fallback state. At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time. fallback: 'blocking' will not update generated pages by default. To update generated pages, use Incremental Static Regeneration in conjunction with fallback: 'blocking'. Good to know: fallback: 'blocking' is not supported when using output: 'export'. Fallback pages In the “fallback” version of a page: The page’s props will be empty. Using the router, you can detect if the fallback is being rendered, router.isFallback will be true. The following example showcases using isFallback: pages/posts/[id].jsimport { useRouter } from 'next/router' function Post({ post }) { const router = useRouter() // If the page is not yet generated, this will be displayed // initially until getStaticProps() finishes running if (router.isFallback) { return <div>Loading...</div> } // Render post... } // This function gets called at build time export async function getStaticPaths() { return { // Only `/posts/1` and `/posts/2` are generated at build time paths: [{ params: { id: '1' } }, { params: { id: '2' } }], // Enable statically generating additional pages // For example: `/posts/3` fallback: true, } } // This also gets called at build time export async function getStaticProps({ params }) { // params contains the post `id`. // If the route is like /posts/1, then params.id is 1 const res = await fetch(`https://.../posts/${params.id}`) const post = await res.json() // Pass post data to the page via props return { props: { post }, // Re-generate the post at most once per second // if a request comes in revalidate: 1, } } export default Post Version History VersionChangesv13.4.0App Router is now stable with simplified data fetching, including generateStaticParams()v12.2.0On-Demand Incremental Static Regeneration is stable.v12.1.0On-Demand Incremental Static Regeneration added (beta).v9.5.0Stable Incremental Static Regenerationv9.3.0getStaticPaths introduced.",
      "code": "getStaticPaths"
    },
    {
      "description": "getStaticPathsWhen exporting a function called getStaticPaths from a page that uses Dynamic Routes, Next.js will statically pre-render all the paths specified by getStaticPaths. pages/repo/[name].tsxTypeScriptJavaScriptTypeScriptimport type { InferGetStaticPropsType, GetStaticProps, GetStaticPaths, } from 'next' type Repo = { name: string stargazers_count: number } export const getStaticPaths = (async () => { return { paths: [ { params: { name: 'next.js', }, }, // See the \"paths\" section below ], fallback: true, // false or \"blocking\" } }) satisfies GetStaticPaths export const getStaticProps = (async (context) => { const res = await fetch('https://api.github.com/repos/vercel/next.js') const repo = await res.json() return { props: { repo } } }) satisfies GetStaticProps<{ repo: Repo }> export default function Page({ repo, }: InferGetStaticPropsType<typeof getStaticProps>) { return repo.stargazers_count } getStaticPaths return values The getStaticPaths function should return an object with the following required properties: paths The paths key determines which paths will be pre-rendered. For example, suppose that you have a page that uses Dynamic Routes named pages/posts/[id].js. If you export getStaticPaths from this page and return the following for paths: return { paths: [ { params: { id: '1' }}, { params: { id: '2' }, // with i18n configured the locale for the path can be returned as well locale: \"en\", }, ], fallback: ... } Then, Next.js will statically generate /posts/1 and /posts/2 during next build using the page component in pages/posts/[id].js. The value for each params object must match the parameters used in the page name: If the page name is pages/posts/[postId]/[commentId], then params should contain postId and commentId. If the page name uses catch-all routes like pages/[...slug], then params should contain slug (which is an array). If this array is ['hello', 'world'], then Next.js will statically generate the page at /hello/world. If the page uses an optional catch-all route, use null, [], undefined or false to render the root-most route. For example, if you supply slug: false for pages/[[...slug]], Next.js will statically generate the page /. The params strings are case-sensitive and ideally should be normalized to ensure the paths are generated correctly. For example, if WoRLD is returned for a param it will only match if WoRLD is the actual path visited, not world or World. Separate of the params object a locale field can be returned when i18n is configured, which configures the locale for the path being generated. fallback: false If fallback is false, then any paths not returned by getStaticPaths will result in a 404 page. When next build is run, Next.js will check if getStaticPaths returned fallback: false, it will then build only the paths returned by getStaticPaths. This option is useful if you have a small number of paths to create, or new page data is not added often. If you find that you need to add more paths, and you have fallback: false, you will need to run next build again so that the new paths can be generated. The following example pre-renders one blog post per page called pages/posts/[id].js. The list of blog posts will be fetched from a CMS and returned by getStaticPaths. Then, for each page, it fetches the post data from a CMS using getStaticProps. pages/posts/[id].jsfunction Post({ post }) { // Render post... } // This function gets called at build time export async function getStaticPaths() { // Call an external API endpoint to get posts const res = await fetch('https://.../posts') const posts = await res.json() // Get the paths we want to pre-render based on posts const paths = posts.map((post) => ({ params: { id: post.id }, })) // We'll pre-render only these paths at build time. // { fallback: false } means other routes should 404. return { paths, fallback: false } } // This also gets called at build time export async function getStaticProps({ params }) { // params contains the post `id`. // If the route is like /posts/1, then params.id is 1 const res = await fetch(`https://.../posts/${params.id}`) const post = await res.json() // Pass post data to the page via props return { props: { post } } } export default Post fallback: true Examples Static generation of a large number of pages If fallback is true, then the behavior of getStaticProps changes in the following ways: The paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps. The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will serve a “fallback” version of the page on the first request to such a path. Web crawlers, such as Google, won't be served a fallback and instead the path will behave as in fallback: 'blocking'. When a page with fallback: true is navigated to through next/link or next/router (client-side) Next.js will not serve a fallback and instead the page will behave as fallback: 'blocking'. In the background, Next.js will statically generate the requested path HTML and JSON. This includes running getStaticProps. When complete, the browser receives the JSON for the generated path. This will be used to automatically render the page with the required props. From the user’s perspective, the page will be swapped from the fallback page to the full page. At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time. Good to know: fallback: true is not supported when using output: 'export'. When is fallback: true useful? fallback: true is useful if your app has a very large number of static pages that depend on data (such as a very large e-commerce site). If you want to pre-render all product pages, the builds would take a very long time. Instead, you may statically generate a small subset of pages and use fallback: true for the rest. When someone requests a page that is not generated yet, the user will see the page with a loading indicator or skeleton component. Shortly after, getStaticProps finishes and the page will be rendered with the requested data. From now on, everyone who requests the same page will get the statically pre-rendered page. This ensures that users always have a fast experience while preserving fast builds and the benefits of Static Generation. fallback: true will not update generated pages, for that take a look at Incremental Static Regeneration. fallback: 'blocking' If fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR (hence why blocking), and then be cached for future requests so it only happens once per path. getStaticProps will behave as follows: The paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps. The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will SSR on the first request and return the generated HTML. When complete, the browser receives the HTML for the generated path. From the user’s perspective, it will transition from \"the browser is requesting the page\" to \"the full page is loaded\". There is no flash of loading/fallback state. At the same time, Next.js adds this path to the list of pre-rendered pages. Subsequent requests to the same path will serve the generated page, like other pages pre-rendered at build time. fallback: 'blocking' will not update generated pages by default. To update generated pages, use Incremental Static Regeneration in conjunction with fallback: 'blocking'. Good to know: fallback: 'blocking' is not supported when using output: 'export'. Fallback pages In the “fallback” version of a page: The page’s props will be empty. Using the router, you can detect if the fallback is being rendered, router.isFallback will be true. The following example showcases using isFallback: pages/posts/[id].jsimport { useRouter } from 'next/router' function Post({ post }) { const router = useRouter() // If the page is not yet generated, this will be displayed // initially until getStaticProps() finishes running if (router.isFallback) { return <div>Loading...</div> } // Render post... } // This function gets called at build time export async function getStaticPaths() { return { // Only `/posts/1` and `/posts/2` are generated at build time paths: [{ params: { id: '1' } }, { params: { id: '2' } }], // Enable statically generating additional pages // For example: `/posts/3` fallback: true, } } // This also gets called at build time export async function getStaticProps({ params }) { // params contains the post `id`. // If the route is like /posts/1, then params.id is 1 const res = await fetch(`https://.../posts/${params.id}`) const post = await res.json() // Pass post data to the page via props return { props: { post }, // Re-generate the post at most once per second // if a request comes in revalidate: 1, } } export default Post Version History VersionChangesv13.4.0App Router is now stable with simplified data fetching, including generateStaticParams()v12.2.0On-Demand Incremental Static Regeneration is stable.v12.1.0On-Demand Incremental Static Regeneration added (beta).v9.5.0Stable Incremental Static Regenerationv9.3.0getStaticPaths introduced.",
      "code": "getStaticPaths"
    },
    {
      "description": "pages/posts/[id].jsimport { useRouter } from 'next/router' function Post({ post }) { const router = useRouter() // If the page is not yet generated, this will be displayed // initially until getStaticProps() finishes running if (router.isFallback) { return <div>Loading...</div> } // Render post... } // This function gets called at build time export async function getStaticPaths() { return { // Only `/posts/1` and `/posts/2` are generated at build time paths: [{ params: { id: '1' } }, { params: { id: '2' } }], // Enable statically generating additional pages // For example: `/posts/3` fallback: true, } } // This also gets called at build time export async function getStaticProps({ params }) { // params contains the post `id`. // If the route is like /posts/1, then params.id is 1 const res = await fetch(`https://.../posts/${params.id}`) const post = await res.json() // Pass post data to the page via props return { props: { post }, // Re-generate the post at most once per second // if a request comes in revalidate: 1, } } export default Post",
      "code": "import { useRouter } from 'next/router'\n \nfunction Post({ post }) {\n  const router = useRouter()\n \n  // If the page is not yet generated, this will be displayed\n  // initially until getStaticProps() finishes running\n  if (router.isFallback) {\n    return <div>Loading...</div>\n  }\n \n  // Render post...\n}\n \n// This function gets called at build time\nexport async function getStaticPaths() {\n  return {\n    // Only `/posts/1` and `/posts/2` are generated at build time\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\n    // Enable statically generating additional pages\n    // For example: `/posts/3`\n    fallback: true,\n  }\n}\n \n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n \n  // Pass post data to the page via props\n  return {\n    props: { post },\n    // Re-generate the post at most once per second\n    // if a request comes in\n    revalidate: 1,\n  }\n}\n \nexport default Post"
    }
  ],
  "links": [
    "https://nextjs.org/docs/pages/api-reference",
    "https://nextjs.org/docs/pages/api-reference/functions",
    "https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes",
    "https://nextjs.org/docs/pages/api-reference/functions/get-static-paths",
    "https://nextjs.org/docs/pages/guides/internationalization",
    "https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props",
    "https://nextjs.org/docs/pages/guides/static-exports",
    "https://nextjs.org/docs/pages/guides/incremental-static-regeneration",
    "https://nextjs.org/docs/pages/api-reference/functions/use-router",
    "https://nextjs.org/docs/app/getting-started/fetching-data",
    "https://nextjs.org/docs/app/api-reference/functions/generate-static-params",
    "https://nextjs.org/docs/pages/api-reference/functions/get-server-side-props",
    "https://nextjs.org/docs/pages/api-reference/functions/get-static-props"
  ]
}