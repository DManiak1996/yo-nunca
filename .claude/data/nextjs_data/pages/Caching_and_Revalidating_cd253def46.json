{
  "url": "https://nextjs.org/docs/15/app/getting-started/caching-and-revalidating",
  "title": "Caching and Revalidating",
  "content": "Caching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application.\n\nNext.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them.\n\nBy default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'.\n\nGood to know: Although fetch requests are not cached by default, Next.js will prerender routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API.\n\nTo revalidate the data returned by a fetch request, you can use the next.revalidate option.\n\nThis will revalidate the data after a specified amount of seconds.\n\nSee the fetch API reference to learn more.\n\nunstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example:\n\nThe function accepts a third optional object to define how the cache should be revalidated. It accepts:\n\nSee the unstable_cache API reference to learn more.\n\nrevalidateTag is used to revalidate cache entries based on a tag and following an event. To use it with fetch, start by tagging the function with the next.tags option:\n\nAlternatively, you can mark an unstable_cache function with the tags option:\n\nThen, call revalidateTag in a Route Handler or Server Action:\n\nYou can reuse the same tag in multiple functions to revalidate them all at once.\n\nSee the revalidateTag API reference to learn more.\n\nrevalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action:\n\nSee the revalidatePath API reference to learn more.",
  "headings": [
    {
      "level": "h1",
      "text": "Caching and Revalidating",
      "id": ""
    },
    {
      "level": "h2",
      "text": "fetch",
      "id": "fetch"
    },
    {
      "level": "h2",
      "text": "unstable_cache",
      "id": "unstable_cache"
    },
    {
      "level": "h2",
      "text": "revalidateTag",
      "id": "revalidatetag"
    },
    {
      "level": "h2",
      "text": "revalidatePath",
      "id": "revalidatepath"
    },
    {
      "level": "h2",
      "text": "API Reference",
      "id": "api-reference"
    },
    {
      "level": "h3",
      "text": "fetch",
      "id": ""
    },
    {
      "level": "h3",
      "text": "unstable_cache",
      "id": ""
    },
    {
      "level": "h3",
      "text": "revalidatePath",
      "id": ""
    },
    {
      "level": "h3",
      "text": "revalidateTag",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "export default async function Page() {\n  const data = await fetch('https://...', { cache: 'force-cache' })\n}",
      "language": "javascript"
    },
    {
      "code": "export default async function Page() {\n  const data = await fetch('https://...', { next: { revalidate: 3600 } })\n}",
      "language": "javascript"
    },
    {
      "code": "import { db } from '@/lib/db'\nexport async function getUserById(id: string) {\n  return db\n    .select()\n    .from(users)\n    .where(eq(users.id, id))\n    .then((res) => res[0])\n}",
      "language": "python"
    },
    {
      "code": "import { unstable_cache } from 'next/cache'\nimport { getUserById } from '@/app/lib/data'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ userId: string }>\n}) {\n  const { userId } = await params\n \n  const getCachedUser = unstable_cache(\n    async () => {\n      return getUserById(userId)\n    },\n    [userId] // add the user ID to the cache key\n  )\n}",
      "language": "python"
    },
    {
      "code": "const getCachedUser = unstable_cache(\n  async () => {\n    return getUserById(userId)\n  },\n  [userId],\n  {\n    tags: ['user'],\n    revalidate: 3600,\n  }\n)",
      "language": "javascript"
    },
    {
      "code": "export async function getUserById(id: string) {\n  const data = await fetch(`https://...`, {\n    next: {\n      tags: ['user'],\n    },\n  })\n}",
      "language": "javascript"
    },
    {
      "code": "export const getUserById = unstable_cache(\n  async (id: string) => {\n    return db.query.users.findFirst({ where: eq(users.id, id) })\n  },\n  ['user'], // Needed if variables are not passed as parameters\n  {\n    tags: ['user'],\n  }\n)",
      "language": "javascript"
    },
    {
      "code": "import { revalidateTag } from 'next/cache'\n \nexport async function updateUser(id: string) {\n  // Mutate data\n  revalidateTag('user')\n}",
      "language": "python"
    },
    {
      "code": "import { revalidatePath } from 'next/cache'\n \nexport async function updateUser(id: string) {\n  // Mutate data\n  revalidatePath('/profile')",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "App RouterGetting StartedCaching and RevalidatingYou are currently viewing documentation for version 15 of Next.js.Caching and RevalidatingCaching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application. Next.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them. fetch unstable_cache revalidatePath revalidateTag fetch By default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'. app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() { const data = await fetch('https://...', { cache: 'force-cache' }) } Good to know: Although fetch requests are not cached by default, Next.js will prerender routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API. To revalidate the data returned by a fetch request, you can use the next.revalidate option. app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() { const data = await fetch('https://...', { next: { revalidate: 3600 } }) } This will revalidate the data after a specified amount of seconds. See the fetch API reference to learn more. unstable_cache unstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example: import { db } from '@/lib/db' export async function getUserById(id: string) { return db .select() .from(users) .where(eq(users.id, id)) .then((res) => res[0]) } app/page.tsxTypeScriptJavaScriptTypeScriptimport { unstable_cache } from 'next/cache' import { getUserById } from '@/app/lib/data' export default async function Page({ params, }: { params: Promise<{ userId: string }> }) { const { userId } = await params const getCachedUser = unstable_cache( async () => { return getUserById(userId) }, [userId] // add the user ID to the cache key ) } The function accepts a third optional object to define how the cache should be revalidated. It accepts: tags: an array of tags used by Next.js to revalidate the cache. revalidate: the number of seconds after cache should be revalidated. app/page.tsxTypeScriptJavaScriptTypeScriptconst getCachedUser = unstable_cache( async () => { return getUserById(userId) }, [userId], { tags: ['user'], revalidate: 3600, } ) See the unstable_cache API reference to learn more. revalidateTag revalidateTag is used to revalidate cache entries based on a tag and following an event. To use it with fetch, start by tagging the function with the next.tags option: app/lib/data.tsTypeScriptJavaScriptTypeScriptexport async function getUserById(id: string) { const data = await fetch(`https://...`, { next: { tags: ['user'], }, }) } Alternatively, you can mark an unstable_cache function with the tags option: app/lib/data.tsTypeScriptJavaScriptTypeScriptexport const getUserById = unstable_cache( async (id: string) => { return db.query.users.findFirst({ where: eq(users.id, id) }) }, ['user'], // Needed if variables are not passed as parameters { tags: ['user'], } ) Then, call revalidateTag in a Route Handler or Server Action: app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidateTag } from 'next/cache' export async function updateUser(id: string) { // Mutate data revalidateTag('user') } You can reuse the same tag in multiple functions to revalidate them all at once. See the revalidateTag API reference to learn more. revalidatePath revalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action: app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidatePath } from 'next/cache' export async function updateUser(id: string) { // Mutate data revalidatePath('/profile') See the revalidatePath API reference to learn more.API ReferenceLearn more about the features mentioned in this page by reading the API Reference.Next.js Docs...FunctionsfetchAPI reference for the extended fetch function.Next.js Docs...Functionsunstable_cacheAPI Reference for the unstable_cache function.Next.js Docs...FunctionsrevalidatePathAPI Reference for the revalidatePath function.Next.js Docs...FunctionsrevalidateTagAPI Reference for the revalidateTag function.",
      "code": "fetch"
    },
    {
      "description": "You are currently viewing documentation for version 15 of Next.js.Caching and RevalidatingCaching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application. Next.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them. fetch unstable_cache revalidatePath revalidateTag fetch By default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'. app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() { const data = await fetch('https://...', { cache: 'force-cache' }) } Good to know: Although fetch requests are not cached by default, Next.js will prerender routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API. To revalidate the data returned by a fetch request, you can use the next.revalidate option. app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() { const data = await fetch('https://...', { next: { revalidate: 3600 } }) } This will revalidate the data after a specified amount of seconds. See the fetch API reference to learn more. unstable_cache unstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example: import { db } from '@/lib/db' export async function getUserById(id: string) { return db .select() .from(users) .where(eq(users.id, id)) .then((res) => res[0]) } app/page.tsxTypeScriptJavaScriptTypeScriptimport { unstable_cache } from 'next/cache' import { getUserById } from '@/app/lib/data' export default async function Page({ params, }: { params: Promise<{ userId: string }> }) { const { userId } = await params const getCachedUser = unstable_cache( async () => { return getUserById(userId) }, [userId] // add the user ID to the cache key ) } The function accepts a third optional object to define how the cache should be revalidated. It accepts: tags: an array of tags used by Next.js to revalidate the cache. revalidate: the number of seconds after cache should be revalidated. app/page.tsxTypeScriptJavaScriptTypeScriptconst getCachedUser = unstable_cache( async () => { return getUserById(userId) }, [userId], { tags: ['user'], revalidate: 3600, } ) See the unstable_cache API reference to learn more. revalidateTag revalidateTag is used to revalidate cache entries based on a tag and following an event. To use it with fetch, start by tagging the function with the next.tags option: app/lib/data.tsTypeScriptJavaScriptTypeScriptexport async function getUserById(id: string) { const data = await fetch(`https://...`, { next: { tags: ['user'], }, }) } Alternatively, you can mark an unstable_cache function with the tags option: app/lib/data.tsTypeScriptJavaScriptTypeScriptexport const getUserById = unstable_cache( async (id: string) => { return db.query.users.findFirst({ where: eq(users.id, id) }) }, ['user'], // Needed if variables are not passed as parameters { tags: ['user'], } ) Then, call revalidateTag in a Route Handler or Server Action: app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidateTag } from 'next/cache' export async function updateUser(id: string) { // Mutate data revalidateTag('user') } You can reuse the same tag in multiple functions to revalidate them all at once. See the revalidateTag API reference to learn more. revalidatePath revalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action: app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidatePath } from 'next/cache' export async function updateUser(id: string) { // Mutate data revalidatePath('/profile') See the revalidatePath API reference to learn more.",
      "code": "fetch"
    },
    {
      "description": "unstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example:",
      "code": "unstable_cache"
    }
  ],
  "links": [
    "https://nextjs.org/docs/15/app",
    "https://nextjs.org/docs/15/app/getting-started",
    "https://nextjs.org/docs/15/app/getting-started/caching-and-revalidating",
    "https://nextjs.org/docs/15/app/api-reference/functions/fetch",
    "https://nextjs.org/docs/15/app/getting-started/partial-prerendering",
    "https://nextjs.org/docs/15/app/api-reference/functions/connection",
    "https://nextjs.org/docs/15/app/api-reference/functions/unstable_cache",
    "https://nextjs.org/docs/15/app/api-reference/file-conventions/route",
    "https://nextjs.org/docs/15/app/api-reference/functions/revalidateTag",
    "https://nextjs.org/docs/15/app/api-reference/functions/revalidatePath",
    "https://nextjs.org/docs/15/app/getting-started/updating-data",
    "https://nextjs.org/docs/15/app/getting-started/error-handling"
  ]
}