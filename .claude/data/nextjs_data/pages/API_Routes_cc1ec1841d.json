{
  "url": "https://nextjs.org/docs/pages/building-your-application/routing/api-routes",
  "title": "API Routes",
  "content": "Good to know: If you are using the App Router, you can use Server Components or Route Handlers instead of API Routes.\n\nAPI routes provide a solution to build a public API with Next.js.\n\nAny file inside the folder pages/api is mapped to /api/* and will be treated as an API endpoint instead of a page. They are server-side only bundles and won't increase your client-side bundle size.\n\nFor example, the following API route returns a JSON response with a status code of 200:\n\nTo handle different HTTP methods in an API route, you can use req.method in your request handler, like so:\n\nAPI Routes provide built-in request helpers which parse the incoming request (req):\n\nEvery API Route can export a config object to change the default configuration, which is the following:\n\nbodyParser is automatically enabled. If you want to consume the body as a Stream or with raw-body, you can set this to false.\n\nOne use case for disabling the automatic bodyParsing is to allow you to verify the raw body of a webhook request, for example from GitHub.\n\nbodyParser.sizeLimit is the maximum size allowed for the parsed body, in any format supported by bytes, like so:\n\nexternalResolver is an explicit flag that tells the server that this route is being handled by an external resolver like express or connect. Enabling this option disables warnings for unresolved requests.\n\nresponseLimit is automatically enabled, warning when an API Routes' response body is over 4MB.\n\nIf you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated media host, you can set this limit to false.\n\nresponseLimit can also take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'. This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above)\n\nThe Server Response object, (often abbreviated as res) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints.\n\nThe included helpers are:\n\nWhen sending a response back to the client, you can set the status code of the response.\n\nThe following example sets the status code of the response to 200 (OK) and returns a message property with the value of Hello from Next.js! as a JSON response:\n\nWhen sending a response back to the client you can send a JSON response, this must be a serializable object. In a real world application you might want to let the client know the status of the request depending on the result of the requested endpoint.\n\nThe following example sends a JSON response with the status code 200 (OK) and the result of the async operation. It's contained in a try catch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the client:\n\nSending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be a string, an object or a Buffer.\n\nThe following example sends a HTTP response with the status code 200 (OK) and the result of the async operation.\n\nTaking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form.\n\nThe following example redirects the client to the / path if the form is successfully submitted:\n\nYou can make your API Routes more type-safe by importing the NextApiRequest and NextApiResponse types from next, in addition to those, you can also type your response data:\n\nGood to know: The body of NextApiRequest is any because the client may include any payload. You should validate the type/shape of the body at runtime before using it.\n\nAPI Routes support dynamic routes, and follow the same file naming rules used for pages/.\n\nNow, a request to /api/post/abc will respond with the text: Post: abc.\n\nAPI Routes can be extended to catch all paths by adding three dots (...) inside the brackets. For example:\n\nGood to know: You can use names other than slug, such as: [...param]\n\nMatched parameters will be sent as a query parameter (slug in the example) to the page, and it will always be an array, so, the path /api/post/a will have the following query object:\n\nAnd in the case of /api/post/a/b, and any other matching path, new parameters will be added to the array, like so:\n\nNow, a request to /api/post/a/b/c will respond with the text: Post: a, b, c.\n\nCatch all routes can be made optional by including the parameter in double brackets ([[...slug]]).\n\nFor example, pages/api/post/[[...slug]].js will match /api/post, /api/post/a, /api/post/a/b, and so on.\n\nThe main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched (/api/post in the example above).\n\nThe query objects are as follows:\n\nWhile the Pages Router does support streaming responses with API Routes, we recommend incrementally adopting the App Router and using Route Handlers if you are on Next.js 14+.\n\nHere's how you can stream a response from an API Route with writeHead:",
  "headings": [
    {
      "level": "h1",
      "text": "API Routes",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h2",
      "text": "HTTP Methods",
      "id": "http-methods"
    },
    {
      "level": "h2",
      "text": "Request Helpers",
      "id": "request-helpers"
    },
    {
      "level": "h3",
      "text": "Custom config",
      "id": "custom-config"
    },
    {
      "level": "h2",
      "text": "Response Helpers",
      "id": "response-helpers"
    },
    {
      "level": "h3",
      "text": "Setting the status code of a response",
      "id": "setting-the-status-code-of-a-response"
    },
    {
      "level": "h3",
      "text": "Sending a JSON response",
      "id": "sending-a-json-response"
    },
    {
      "level": "h3",
      "text": "Sending a HTTP response",
      "id": "sending-a-http-response"
    },
    {
      "level": "h3",
      "text": "Redirects to a specified path or URL",
      "id": "redirects-to-a-specified-path-or-url"
    },
    {
      "level": "h3",
      "text": "Adding TypeScript types",
      "id": "adding-typescript-types"
    },
    {
      "level": "h2",
      "text": "Dynamic API Routes",
      "id": "dynamic-api-routes"
    },
    {
      "level": "h3",
      "text": "Catch all API routes",
      "id": "catch-all-api-routes"
    },
    {
      "level": "h3",
      "text": "Optional catch all API routes",
      "id": "optional-catch-all-api-routes"
    },
    {
      "level": "h3",
      "text": "Caveats",
      "id": "caveats"
    },
    {
      "level": "h2",
      "text": "Streaming responses",
      "id": "streaming-responses"
    }
  ],
  "code_samples": [
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \ntype ResponseData = {\n  message: string\n}\n \nexport default function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ResponseData>\n) {\n  res.status(200).json({ message: 'Hello from Next.js!' })\n}",
      "language": "python"
    },
    {
      "code": "export default function handler(req: NextApiRequest, res: NextApiResponse) {\n  // ...\n}",
      "language": "unknown"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method === 'POST') {\n    // Process a POST request\n  } else {\n    // Handle any other HTTP method\n  }\n}",
      "language": "python"
    },
    {
      "code": "export const config = {\n  api: {\n    bodyParser: {\n      sizeLimit: '1mb',\n    },\n  },\n  // Specifies the maximum allowed duration for this function to execute (in seconds)\n  maxDuration: 5,\n}",
      "language": "javascript"
    },
    {
      "code": "export const config = {\n  api: {\n    bodyParser: false,\n  },\n}",
      "language": "javascript"
    },
    {
      "code": "export const config = {\n  api: {\n    bodyParser: {\n      sizeLimit: '500kb',\n    },\n  },\n}",
      "language": "javascript"
    },
    {
      "code": "export const config = {\n  api: {\n    externalResolver: true,\n  },\n}",
      "language": "javascript"
    },
    {
      "code": "export const config = {\n  api: {\n    responseLimit: false,\n  },\n}",
      "language": "javascript"
    },
    {
      "code": "export const config = {\n  api: {\n    responseLimit: '8mb',\n  },\n}",
      "language": "javascript"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \ntype ResponseData = {\n  message: string\n}\n \nexport default function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ResponseData>\n) {\n  res.status(200).json({ message: 'Hello from Next.js!' })\n}",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  try {\n    const result = await someAsyncOperation()\n    res.status(200).json({ result })\n  } catch (err) {\n    res.status(500).json({ error: 'failed to load data' })\n  }\n}",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  try {\n    const result = await someAsyncOperation()\n    res.status(200).send({ result })\n  } catch (err) {\n    res.status(500).send({ error: 'failed to fetch data' })\n  }\n}",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  const { name, message } = req.body\n \n  try {\n    await handleFormInputAsync({ name, message })\n    res.redirect(307, '/')\n  } catch (err) {\n    res.status(500).send({ error: 'Failed to fetch data' })\n  }\n}",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \ntype ResponseData = {\n  message: string\n}\n \nexport default function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ResponseData>\n) {\n  res.status(200).json({ message: 'Hello from Next.js!' })\n}",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { pid } = req.query\n  res.end(`Post: ${pid}`)\n}",
      "language": "python"
    },
    {
      "code": "{ \"slug\": [\"a\"] }",
      "language": "unknown"
    },
    {
      "code": "{ \"slug\": [\"a\", \"b\"] }",
      "language": "unknown"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { slug } = req.query\n  res.end(`Post: ${slug.join(', ')}`)\n}",
      "language": "python"
    },
    {
      "code": "{ } // GET `/api/post` (empty object)\n{ \"slug\": [\"a\"] } // `GET /api/post/a` (single-element array)\n{ \"slug\": [\"a\", \"b\"] } // `GET /api/post/a/b` (multi-element array)",
      "language": "unknown"
    },
    {
      "code": "import { NextApiRequest, NextApiResponse } from 'next'\n \nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  res.writeHead(200, {\n    'Content-Type': 'text/event-stream',\n    'Cache-Control': 'no-store',\n  })\n  let i = 0\n  while (i < 10) {\n    res.write(`data: ${i}\\n\\n`)\n    i++\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n  res.end()\n}",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Building Your ApplicationRoutingAPI RoutesCopy pageAPI RoutesExamples API Routes Request Helpers API Routes with GraphQL API Routes with REST API Routes with CORS Good to know: If you are using the App Router, you can use Server Components or Route Handlers instead of API Routes. API routes provide a solution to build a public API with Next.js. Any file inside the folder pages/api is mapped to /api/* and will be treated as an API endpoint instead of a page. They are server-side only bundles and won't increase your client-side bundle size. For example, the following API route returns a JSON response with a status code of 200: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' type ResponseData = { message: string } export default function handler( req: NextApiRequest, res: NextApiResponse<ResponseData> ) { res.status(200).json({ message: 'Hello from Next.js!' }) } Good to know: API Routes do not specify CORS headers, meaning they are same-origin only by default. You can customize such behavior by wrapping the request handler with the CORS request helpers. API Routes can't be used with static exports. However, Route Handlers in the App Router can. API Routes will be affected by pageExtensions configuration in next.config.js. Parameters export default function handler(req: NextApiRequest, res: NextApiResponse) { // ... } req: An instance of http.IncomingMessage res: An instance of http.ServerResponse HTTP Methods To handle different HTTP methods in an API route, you can use req.method in your request handler, like so: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default function handler(req: NextApiRequest, res: NextApiResponse) { if (req.method === 'POST') { // Process a POST request } else { // Handle any other HTTP method } } Request Helpers API Routes provide built-in request helpers which parse the incoming request (req): req.cookies - An object containing the cookies sent by the request. Defaults to {} req.query - An object containing the query string. Defaults to {} req.body - An object containing the body parsed by content-type, or null if no body was sent Custom config Every API Route can export a config object to change the default configuration, which is the following: export const config = { api: { bodyParser: { sizeLimit: '1mb', }, }, // Specifies the maximum allowed duration for this function to execute (in seconds) maxDuration: 5, } bodyParser is automatically enabled. If you want to consume the body as a Stream or with raw-body, you can set this to false. One use case for disabling the automatic bodyParsing is to allow you to verify the raw body of a webhook request, for example from GitHub. export const config = { api: { bodyParser: false, }, } bodyParser.sizeLimit is the maximum size allowed for the parsed body, in any format supported by bytes, like so: export const config = { api: { bodyParser: { sizeLimit: '500kb', }, }, } externalResolver is an explicit flag that tells the server that this route is being handled by an external resolver like express or connect. Enabling this option disables warnings for unresolved requests. export const config = { api: { externalResolver: true, }, } responseLimit is automatically enabled, warning when an API Routes' response body is over 4MB. If you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated media host, you can set this limit to false. export const config = { api: { responseLimit: false, }, } responseLimit can also take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'. This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above) export const config = { api: { responseLimit: '8mb', }, } Response Helpers The Server Response object, (often abbreviated as res) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints. The included helpers are: res.status(code) - A function to set the status code. code must be a valid HTTP status code res.json(body) - Sends a JSON response. body must be a serializable object res.send(body) - Sends the HTTP response. body can be a string, an object or a Buffer res.redirect([status,] path) - Redirects to a specified path or URL. status must be a valid HTTP status code. If not specified, status defaults to \"307\" \"Temporary redirect\". res.revalidate(urlPath) - Revalidate a page on demand using getStaticProps. urlPath must be a string. Setting the status code of a response When sending a response back to the client, you can set the status code of the response. The following example sets the status code of the response to 200 (OK) and returns a message property with the value of Hello from Next.js! as a JSON response: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' type ResponseData = { message: string } export default function handler( req: NextApiRequest, res: NextApiResponse<ResponseData> ) { res.status(200).json({ message: 'Hello from Next.js!' }) } Sending a JSON response When sending a response back to the client you can send a JSON response, this must be a serializable object. In a real world application you might want to let the client know the status of the request depending on the result of the requested endpoint. The following example sends a JSON response with the status code 200 (OK) and the result of the async operation. It's contained in a try catch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the client: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { try { const result = await someAsyncOperation() res.status(200).json({ result }) } catch (err) { res.status(500).json({ error: 'failed to load data' }) } } Sending a HTTP response Sending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be a string, an object or a Buffer. The following example sends a HTTP response with the status code 200 (OK) and the result of the async operation. pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { try { const result = await someAsyncOperation() res.status(200).send({ result }) } catch (err) { res.status(500).send({ error: 'failed to fetch data' }) } } Redirects to a specified path or URL Taking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form. The following example redirects the client to the / path if the form is successfully submitted: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { const { name, message } = req.body try { await handleFormInputAsync({ name, message }) res.redirect(307, '/') } catch (err) { res.status(500).send({ error: 'Failed to fetch data' }) } } Adding TypeScript types You can make your API Routes more type-safe by importing the NextApiRequest and NextApiResponse types from next, in addition to those, you can also type your response data: import type { NextApiRequest, NextApiResponse } from 'next' type ResponseData = { message: string } export default function handler( req: NextApiRequest, res: NextApiResponse<ResponseData> ) { res.status(200).json({ message: 'Hello from Next.js!' }) } Good to know: The body of NextApiRequest is any because the client may include any payload. You should validate the type/shape of the body at runtime before using it. Dynamic API Routes API Routes support dynamic routes, and follow the same file naming rules used for pages/. pages/api/post/[pid].tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default function handler(req: NextApiRequest, res: NextApiResponse) { const { pid } = req.query res.end(`Post: ${pid}`) } Now, a request to /api/post/abc will respond with the text: Post: abc. Catch all API routes API Routes can be extended to catch all paths by adding three dots (...) inside the brackets. For example: pages/api/post/[...slug].js matches /api/post/a, but also /api/post/a/b, /api/post/a/b/c and so on. Good to know: You can use names other than slug, such as: [...param] Matched parameters will be sent as a query parameter (slug in the example) to the page, and it will always be an array, so, the path /api/post/a will have the following query object: { \"slug\": [\"a\"] } And in the case of /api/post/a/b, and any other matching path, new parameters will be added to the array, like so: { \"slug\": [\"a\", \"b\"] } For example: pages/api/post/[...slug].tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default function handler(req: NextApiRequest, res: NextApiResponse) { const { slug } = req.query res.end(`Post: ${slug.join(', ')}`) } Now, a request to /api/post/a/b/c will respond with the text: Post: a, b, c. Optional catch all API routes Catch all routes can be made optional by including the parameter in double brackets ([[...slug]]). For example, pages/api/post/[[...slug]].js will match /api/post, /api/post/a, /api/post/a/b, and so on. The main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched (/api/post in the example above). The query objects are as follows: { } // GET `/api/post` (empty object) { \"slug\": [\"a\"] } // `GET /api/post/a` (single-element array) { \"slug\": [\"a\", \"b\"] } // `GET /api/post/a/b` (multi-element array) Caveats Predefined API routes take precedence over dynamic API routes, and dynamic API routes over catch all API routes. Take a look at the following examples: pages/api/post/create.js - Will match /api/post/create pages/api/post/[pid].js - Will match /api/post/1, /api/post/abc, etc. But not /api/post/create pages/api/post/[...slug].js - Will match /api/post/1/2, /api/post/a/b/c, etc. But not /api/post/create, /api/post/abc Streaming responses While the Pages Router does support streaming responses with API Routes, we recommend incrementally adopting the App Router and using Route Handlers if you are on Next.js 14+. Here's how you can stream a response from an API Route with writeHead: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { res.writeHead(200, { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-store', }) let i = 0 while (i < 10) { res.write(`data: ${i}\\n\\n`) i++ await new Promise((resolve) => setTimeout(resolve, 1000)) } res.end() }",
      "code": "pages/api"
    },
    {
      "description": "API RoutesExamples API Routes Request Helpers API Routes with GraphQL API Routes with REST API Routes with CORS Good to know: If you are using the App Router, you can use Server Components or Route Handlers instead of API Routes. API routes provide a solution to build a public API with Next.js. Any file inside the folder pages/api is mapped to /api/* and will be treated as an API endpoint instead of a page. They are server-side only bundles and won't increase your client-side bundle size. For example, the following API route returns a JSON response with a status code of 200: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' type ResponseData = { message: string } export default function handler( req: NextApiRequest, res: NextApiResponse<ResponseData> ) { res.status(200).json({ message: 'Hello from Next.js!' }) } Good to know: API Routes do not specify CORS headers, meaning they are same-origin only by default. You can customize such behavior by wrapping the request handler with the CORS request helpers. API Routes can't be used with static exports. However, Route Handlers in the App Router can. API Routes will be affected by pageExtensions configuration in next.config.js. Parameters export default function handler(req: NextApiRequest, res: NextApiResponse) { // ... } req: An instance of http.IncomingMessage res: An instance of http.ServerResponse HTTP Methods To handle different HTTP methods in an API route, you can use req.method in your request handler, like so: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default function handler(req: NextApiRequest, res: NextApiResponse) { if (req.method === 'POST') { // Process a POST request } else { // Handle any other HTTP method } } Request Helpers API Routes provide built-in request helpers which parse the incoming request (req): req.cookies - An object containing the cookies sent by the request. Defaults to {} req.query - An object containing the query string. Defaults to {} req.body - An object containing the body parsed by content-type, or null if no body was sent Custom config Every API Route can export a config object to change the default configuration, which is the following: export const config = { api: { bodyParser: { sizeLimit: '1mb', }, }, // Specifies the maximum allowed duration for this function to execute (in seconds) maxDuration: 5, } bodyParser is automatically enabled. If you want to consume the body as a Stream or with raw-body, you can set this to false. One use case for disabling the automatic bodyParsing is to allow you to verify the raw body of a webhook request, for example from GitHub. export const config = { api: { bodyParser: false, }, } bodyParser.sizeLimit is the maximum size allowed for the parsed body, in any format supported by bytes, like so: export const config = { api: { bodyParser: { sizeLimit: '500kb', }, }, } externalResolver is an explicit flag that tells the server that this route is being handled by an external resolver like express or connect. Enabling this option disables warnings for unresolved requests. export const config = { api: { externalResolver: true, }, } responseLimit is automatically enabled, warning when an API Routes' response body is over 4MB. If you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated media host, you can set this limit to false. export const config = { api: { responseLimit: false, }, } responseLimit can also take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'. This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above) export const config = { api: { responseLimit: '8mb', }, } Response Helpers The Server Response object, (often abbreviated as res) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints. The included helpers are: res.status(code) - A function to set the status code. code must be a valid HTTP status code res.json(body) - Sends a JSON response. body must be a serializable object res.send(body) - Sends the HTTP response. body can be a string, an object or a Buffer res.redirect([status,] path) - Redirects to a specified path or URL. status must be a valid HTTP status code. If not specified, status defaults to \"307\" \"Temporary redirect\". res.revalidate(urlPath) - Revalidate a page on demand using getStaticProps. urlPath must be a string. Setting the status code of a response When sending a response back to the client, you can set the status code of the response. The following example sets the status code of the response to 200 (OK) and returns a message property with the value of Hello from Next.js! as a JSON response: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' type ResponseData = { message: string } export default function handler( req: NextApiRequest, res: NextApiResponse<ResponseData> ) { res.status(200).json({ message: 'Hello from Next.js!' }) } Sending a JSON response When sending a response back to the client you can send a JSON response, this must be a serializable object. In a real world application you might want to let the client know the status of the request depending on the result of the requested endpoint. The following example sends a JSON response with the status code 200 (OK) and the result of the async operation. It's contained in a try catch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the client: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { try { const result = await someAsyncOperation() res.status(200).json({ result }) } catch (err) { res.status(500).json({ error: 'failed to load data' }) } } Sending a HTTP response Sending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be a string, an object or a Buffer. The following example sends a HTTP response with the status code 200 (OK) and the result of the async operation. pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { try { const result = await someAsyncOperation() res.status(200).send({ result }) } catch (err) { res.status(500).send({ error: 'failed to fetch data' }) } } Redirects to a specified path or URL Taking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form. The following example redirects the client to the / path if the form is successfully submitted: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { const { name, message } = req.body try { await handleFormInputAsync({ name, message }) res.redirect(307, '/') } catch (err) { res.status(500).send({ error: 'Failed to fetch data' }) } } Adding TypeScript types You can make your API Routes more type-safe by importing the NextApiRequest and NextApiResponse types from next, in addition to those, you can also type your response data: import type { NextApiRequest, NextApiResponse } from 'next' type ResponseData = { message: string } export default function handler( req: NextApiRequest, res: NextApiResponse<ResponseData> ) { res.status(200).json({ message: 'Hello from Next.js!' }) } Good to know: The body of NextApiRequest is any because the client may include any payload. You should validate the type/shape of the body at runtime before using it. Dynamic API Routes API Routes support dynamic routes, and follow the same file naming rules used for pages/. pages/api/post/[pid].tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default function handler(req: NextApiRequest, res: NextApiResponse) { const { pid } = req.query res.end(`Post: ${pid}`) } Now, a request to /api/post/abc will respond with the text: Post: abc. Catch all API routes API Routes can be extended to catch all paths by adding three dots (...) inside the brackets. For example: pages/api/post/[...slug].js matches /api/post/a, but also /api/post/a/b, /api/post/a/b/c and so on. Good to know: You can use names other than slug, such as: [...param] Matched parameters will be sent as a query parameter (slug in the example) to the page, and it will always be an array, so, the path /api/post/a will have the following query object: { \"slug\": [\"a\"] } And in the case of /api/post/a/b, and any other matching path, new parameters will be added to the array, like so: { \"slug\": [\"a\", \"b\"] } For example: pages/api/post/[...slug].tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' export default function handler(req: NextApiRequest, res: NextApiResponse) { const { slug } = req.query res.end(`Post: ${slug.join(', ')}`) } Now, a request to /api/post/a/b/c will respond with the text: Post: a, b, c. Optional catch all API routes Catch all routes can be made optional by including the parameter in double brackets ([[...slug]]). For example, pages/api/post/[[...slug]].js will match /api/post, /api/post/a, /api/post/a/b, and so on. The main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched (/api/post in the example above). The query objects are as follows: { } // GET `/api/post` (empty object) { \"slug\": [\"a\"] } // `GET /api/post/a` (single-element array) { \"slug\": [\"a\", \"b\"] } // `GET /api/post/a/b` (multi-element array) Caveats Predefined API routes take precedence over dynamic API routes, and dynamic API routes over catch all API routes. Take a look at the following examples: pages/api/post/create.js - Will match /api/post/create pages/api/post/[pid].js - Will match /api/post/1, /api/post/abc, etc. But not /api/post/create pages/api/post/[...slug].js - Will match /api/post/1/2, /api/post/a/b/c, etc. But not /api/post/create, /api/post/abc Streaming responses While the Pages Router does support streaming responses with API Routes, we recommend incrementally adopting the App Router and using Route Handlers if you are on Next.js 14+. Here's how you can stream a response from an API Route with writeHead: pages/api/hello.tsTypeScriptJavaScriptTypeScriptimport { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { res.writeHead(200, { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-store', }) let i = 0 while (i < 10) { res.write(`data: ${i}\\n\\n`) i++ await new Promise((resolve) => setTimeout(resolve, 1000)) } res.end() }",
      "code": "pages/api"
    },
    {
      "description": "API Routes can be extended to catch all paths by adding three dots (...) inside the brackets. For example:",
      "code": "..."
    },
    {
      "description": "For example:",
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { slug } = req.query\n  res.end(`Post: ${slug.join(', ')}`)\n}"
    }
  ],
  "links": [
    "https://nextjs.org/docs/pages/building-your-application",
    "https://nextjs.org/docs/pages/building-your-application/routing",
    "https://nextjs.org/docs/app/getting-started/server-and-client-components",
    "https://nextjs.org/docs/app/api-reference/file-conventions/route",
    "https://nextjs.org/docs/pages/guides/static-exports",
    "https://nextjs.org/docs/pages/api-reference/config/next-config-js/pageExtensions",
    "https://nextjs.org/docs/pages/building-your-application/routing/api-routes",
    "https://nextjs.org/docs/pages/guides/incremental-static-regeneration",
    "https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes",
    "https://nextjs.org/docs/pages/building-your-application/routing/custom-document",
    "https://nextjs.org/docs/pages/building-your-application/routing/custom-error"
  ]
}