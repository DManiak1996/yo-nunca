{
  "url": "https://nextjs.org/docs/pages/guides/content-security-policy",
  "title": "How to set a Content Security Policy (CSP) for your Next.js application",
  "content": "Content Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks.\n\nBy using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more.\n\nA nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives.\n\nCSP can block both inline and external scripts to prevent attacks. A nonce lets you safely allow specific scripts to run—only if they include the matching nonce value.\n\nIf an attacker wanted to load a script into your page, they'd need to guess the nonce value. That's why the nonce must be unpredictable and unique for every request.\n\nProxy enables you to add headers and generate nonces before the page renders.\n\nEvery time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces.\n\nBy default, Proxy runs on all requests. You can filter Proxy to run on specific paths using a matcher.\n\nWe recommend ignoring matching prefetches (from next/link) and static assets that don't need the CSP header.\n\nTo use a nonce, your page must be dynamically rendered. This is because Next.js applies nonces during server-side rendering, based on the CSP header present in the request. Static pages are generated at build time, when no request or response headers exist—so no nonce can be injected.\n\nHere’s how nonce support works in a dynamically rendered page:\n\nBecause of this automatic behavior, you don’t need to manually add a nonce to each tag.\n\nIf you're using nonces, you may need to explicitly opt pages into dynamic rendering:\n\nYou can provide the nonce to your page using getServerSideProps:\n\nYou can also access the nonce in _document.tsx for Pages Router applications:\n\nUsing nonces has important implications for how your Next.js application renders:\n\nWhen you use nonces in your CSP, all pages must be dynamically rendered. This means:\n\nThe shift from static to dynamic rendering affects performance:\n\nConsider nonces when:\n\nFor applications that do not require nonces, you can set the CSP header directly in your next.config.js file:\n\nCSP implementation differs between development and production environments:\n\nIn development, you will need to enable 'unsafe-eval' to support APIs that provide additional debugging information:\n\nCommon issues in production:\n\nWhen using third-party scripts with CSP, ensure you add the necessary domains and pass the nonce:\n\nUpdate your CSP to allow third-party domains:",
  "headings": [
    {
      "level": "h1",
      "text": "How to set a Content Security Policy (CSP) for your Next.js application",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Nonces",
      "id": "nonces"
    },
    {
      "level": "h3",
      "text": "Why use a nonce?",
      "id": "why-use-a-nonce"
    },
    {
      "level": "h3",
      "text": "Adding a nonce with Proxy",
      "id": "adding-a-nonce-with-proxy"
    },
    {
      "level": "h3",
      "text": "How nonces work in Next.js",
      "id": "how-nonces-work-in-nextjs"
    },
    {
      "level": "h3",
      "text": "Forcing dynamic rendering",
      "id": "forcing-dynamic-rendering"
    },
    {
      "level": "h3",
      "text": "Reading the nonce",
      "id": "reading-the-nonce"
    },
    {
      "level": "h2",
      "text": "Static vs Dynamic Rendering with CSP",
      "id": "static-vs-dynamic-rendering-with-csp"
    },
    {
      "level": "h3",
      "text": "Dynamic Rendering Requirement",
      "id": "dynamic-rendering-requirement"
    },
    {
      "level": "h3",
      "text": "Performance Implications",
      "id": "performance-implications"
    },
    {
      "level": "h3",
      "text": "When to use nonces",
      "id": "when-to-use-nonces"
    },
    {
      "level": "h2",
      "text": "Without Nonces",
      "id": "without-nonces"
    },
    {
      "level": "h2",
      "text": "Development vs Production Considerations",
      "id": "development-vs-production-considerations"
    },
    {
      "level": "h3",
      "text": "Development Environment",
      "id": "development-environment"
    },
    {
      "level": "h3",
      "text": "Production Deployment",
      "id": "production-deployment"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h3",
      "text": "Third-party Scripts",
      "id": "third-party-scripts"
    },
    {
      "level": "h3",
      "text": "Common CSP Violations",
      "id": "common-csp-violations"
    },
    {
      "level": "h2",
      "text": "Version History",
      "id": "version-history"
    }
  ],
  "code_samples": [
    {
      "code": "import { NextRequest, NextResponse } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n  const cspHeader = `\n    default-src 'self';\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\n    style-src 'self' 'nonce-${nonce}';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    upgrade-insecure-requests;\n`\n  // Replace newline characters and spaces\n  const contentSecurityPolicyHeaderValue = cspHeader\n    .replace(/\\s{2,}/g, ' ')\n    .trim()\n \n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set('x-nonce', nonce)\n \n  requestHeaders.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  const response = NextResponse.next({\n    request: {\n      headers: requestHeaders,\n    },\n  })\n  response.headers.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  return response\n}",
      "language": "python"
    },
    {
      "code": "export const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    {\n      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',\n      missing: [\n        { type: 'header', key: 'next-router-prefetch' },\n        { type: 'header', key: 'purpose', value: 'prefetch' },\n      ],\n    },\n  ],\n}",
      "language": "javascript"
    },
    {
      "code": "import { connection } from 'next/server'\n \nexport default async function Page() {\n  // wait for an incoming request to render this page\n  await connection()\n  // Your page content\n}",
      "language": "python"
    },
    {
      "code": "import Script from 'next/script'\n \nimport type { GetServerSideProps } from 'next'\n \nexport default function Page({ nonce }) {\n  return (\n    <Script\n      src=\"https://www.googletagmanager.com/gtag/js\"\n      strategy=\"afterInteractive\"\n      nonce={nonce}\n    />\n  )\n}\n \nexport const getServerSideProps: GetServerSideProps = async ({ req }) => {\n  const nonce = req.headers['x-nonce']\n  return { props: { nonce } }\n}",
      "language": "python"
    },
    {
      "code": "import Document, {\n  Html,\n  Head,\n  Main,\n  NextScript,\n  DocumentContext,\n  DocumentInitialProps,\n} from 'next/document'\n \ninterface ExtendedDocumentProps extends DocumentInitialProps {\n  nonce?: string\n}\n \nclass MyDocument extends Document<ExtendedDocumentProps> {\n  static async getInitialProps(\n    ctx: DocumentContext\n  ): Promise<ExtendedDocumentProps> {\n    const initialProps = await Document.getInitialProps(ctx)\n    const nonce = ctx.req?.headers?.['x-nonce'] as string | undefined\n \n    return {\n      ...initialProps,\n      nonce,\n    }\n  }\n \n  render() {\n    const { nonce } = this.props\n \n    return (\n      <Html lang=\"en\">\n        <Head nonce={nonce} />\n        <body>\n          <Main />\n          <NextScript nonce={nonce} />\n        </body>\n      </Html>\n    )\n  }\n}\n \nexport default MyDocument",
      "language": "python"
    },
    {
      "code": "const cspHeader = `\n    default-src 'self';\n    script-src 'self' 'unsafe-eval' 'unsafe-inline';\n    style-src 'self' 'unsafe-inline';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    upgrade-insecure-requests;\n`\n \nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'Content-Security-Policy',\n            value: cspHeader.replace(/\\n/g, ''),\n          },\n        ],\n      },\n    ]\n  },\n}",
      "language": "javascript"
    },
    {
      "code": "export function proxy(request: NextRequest) {\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n  const isDev = process.env.NODE_ENV === 'development'\n \n  const cspHeader = `\n    default-src 'self';\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic' ${isDev ? \"'unsafe-eval'\" : ''};\n    style-src 'self' ${isDev ? \"'unsafe-inline'\" : `'nonce-${nonce}'`};\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    upgrade-insecure-requests;\n`\n \n  // Rest of proxy implementation\n}",
      "language": "javascript"
    },
    {
      "code": "import type { AppProps } from 'next/app'\nimport Script from 'next/script'\n \nexport default function App({ Component, pageProps }: AppProps) {\n  const nonce = pageProps.nonce\n \n  return (\n    <>\n      <Component {...pageProps} />\n      <Script\n        src=\"https://www.googletagmanager.com/gtag/js\"\n        strategy=\"afterInteractive\"\n        nonce={nonce}\n      />\n    </>\n  )\n}",
      "language": "python"
    },
    {
      "code": "const cspHeader = `\n  default-src 'self';\n  script-src 'self' 'nonce-${nonce}' 'strict-dynamic' https://www.googletagmanager.com;\n  connect-src 'self' https://www.google-analytics.com;\n  img-src 'self' data: https://www.google-analytics.com;\n`",
      "language": "javascript"
    }
  ],
  "patterns": [
    {
      "description": "Pages RouterGuidesContent Security PolicyCopy pageHow to set a Content Security Policy (CSP) for your Next.js application Content Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks. By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more. Examples Strict CSP Nonces A nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives. Why use a nonce? CSP can block both inline and external scripts to prevent attacks. A nonce lets you safely allow specific scripts to run—only if they include the matching nonce value. If an attacker wanted to load a script into your page, they'd need to guess the nonce value. That's why the nonce must be unpredictable and unique for every request. Adding a nonce with Proxy Proxy enables you to add headers and generate nonces before the page renders. Every time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces. For example: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server' export function proxy(request: NextRequest) { const nonce = Buffer.from(crypto.randomUUID()).toString('base64') const cspHeader = ` default-src 'self'; script-src 'self' 'nonce-${nonce}' 'strict-dynamic'; style-src 'self' 'nonce-${nonce}'; img-src 'self' blob: data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests; ` // Replace newline characters and spaces const contentSecurityPolicyHeaderValue = cspHeader .replace(/\\s{2,}/g, ' ') .trim() const requestHeaders = new Headers(request.headers) requestHeaders.set('x-nonce', nonce) requestHeaders.set( 'Content-Security-Policy', contentSecurityPolicyHeaderValue ) const response = NextResponse.next({ request: { headers: requestHeaders, }, }) response.headers.set( 'Content-Security-Policy', contentSecurityPolicyHeaderValue ) return response } By default, Proxy runs on all requests. You can filter Proxy to run on specific paths using a matcher. We recommend ignoring matching prefetches (from next/link) and static assets that don't need the CSP header. proxy.tsTypeScriptJavaScriptTypeScriptexport const config = { matcher: [ /* * Match all request paths except for the ones starting with: * - api (API routes) * - _next/static (static files) * - _next/image (image optimization files) * - favicon.ico (favicon file) */ { source: '/((?!api|_next/static|_next/image|favicon.ico).*)', missing: [ { type: 'header', key: 'next-router-prefetch' }, { type: 'header', key: 'purpose', value: 'prefetch' }, ], }, ], } How nonces work in Next.js To use a nonce, your page must be dynamically rendered. This is because Next.js applies nonces during server-side rendering, based on the CSP header present in the request. Static pages are generated at build time, when no request or response headers exist—so no nonce can be injected. Here’s how nonce support works in a dynamically rendered page: Proxy generates a nonce: Your proxy creates a unique nonce for the request, adds it to your Content-Security-Policy header, and also sets it in a custom x-nonce header. Next.js extracts the nonce: During rendering, Next.js parses the Content-Security-Policy header and extracts the nonce using the 'nonce-{value}' pattern. Nonce is applied automatically: Next.js attaches the nonce to: Framework scripts (React, Next.js runtime) Page-specific JavaScript bundles Inline styles and scripts generated by Next.js Any <Script> components using the nonce prop Because of this automatic behavior, you don’t need to manually add a nonce to each tag. Forcing dynamic rendering If you're using nonces, you may need to explicitly opt pages into dynamic rendering: app/page.tsxTypeScriptJavaScriptTypeScriptimport { connection } from 'next/server' export default async function Page() { // wait for an incoming request to render this page await connection() // Your page content } Reading the nonce You can provide the nonce to your page using getServerSideProps:pages/index.tsxTypeScriptJavaScriptTypeScriptimport Script from 'next/script' import type { GetServerSideProps } from 'next' export default function Page({ nonce }) { return ( <Script src=\"https://www.googletagmanager.com/gtag/js\" strategy=\"afterInteractive\" nonce={nonce} /> ) } export const getServerSideProps: GetServerSideProps = async ({ req }) => { const nonce = req.headers['x-nonce'] return { props: { nonce } } }You can also access the nonce in _document.tsx for Pages Router applications:pages/_document.tsxTypeScriptJavaScriptTypeScriptimport Document, { Html, Head, Main, NextScript, DocumentContext, DocumentInitialProps, } from 'next/document' interface ExtendedDocumentProps extends DocumentInitialProps { nonce?: string } class MyDocument extends Document<ExtendedDocumentProps> { static async getInitialProps( ctx: DocumentContext ): Promise<ExtendedDocumentProps> { const initialProps = await Document.getInitialProps(ctx) const nonce = ctx.req?.headers?.['x-nonce'] as string | undefined return { ...initialProps, nonce, } } render() { const { nonce } = this.props return ( <Html lang=\"en\"> <Head nonce={nonce} /> <body> <Main /> <NextScript nonce={nonce} /> </body> </Html> ) } } export default MyDocument Static vs Dynamic Rendering with CSP Using nonces has important implications for how your Next.js application renders: Dynamic Rendering Requirement When you use nonces in your CSP, all pages must be dynamically rendered. This means: Pages will build successfully but may encounter runtime errors if not properly configured for dynamic rendering Each request generates a fresh page with a new nonce Static optimization and Incremental Static Regeneration (ISR) are disabled Pages cannot be cached by CDNs without additional configuration Partial Prerendering (PPR) is incompatible with nonce-based CSP since static shell scripts won't have access to the nonce Performance Implications The shift from static to dynamic rendering affects performance: Slower initial page loads: Pages must be generated on each request Increased server load: Every request requires server-side rendering No CDN caching: Dynamic pages cannot be cached at the edge by default Higher hosting costs: More server resources needed for dynamic rendering When to use nonces Consider nonces when: You have strict security requirements that prohibit 'unsafe-inline' Your application handles sensitive data You need to allow specific inline scripts while blocking others Compliance requirements mandate strict CSP Without Nonces For applications that do not require nonces, you can set the CSP header directly in your next.config.js file: next.config.jsconst cspHeader = ` default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' blob: data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests; ` module.exports = { async headers() { return [ { source: '/(.*)', headers: [ { key: 'Content-Security-Policy', value: cspHeader.replace(/\\n/g, ''), }, ], }, ] }, } Development vs Production Considerations CSP implementation differs between development and production environments: Development Environment In development, you will need to enable 'unsafe-eval' to support APIs that provide additional debugging information: proxy.tsTypeScriptJavaScriptTypeScriptexport function proxy(request: NextRequest) { const nonce = Buffer.from(crypto.randomUUID()).toString('base64') const isDev = process.env.NODE_ENV === 'development' const cspHeader = ` default-src 'self'; script-src 'self' 'nonce-${nonce}' 'strict-dynamic' ${isDev ? \"'unsafe-eval'\" : ''}; style-src 'self' ${isDev ? \"'unsafe-inline'\" : `'nonce-${nonce}'`}; img-src 'self' blob: data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests; ` // Rest of proxy implementation } Production Deployment Common issues in production: Nonce not applied: Ensure your proxy runs on all necessary routes Static assets blocked: Verify your CSP allows Next.js static assets Third-party scripts: Add necessary domains to your CSP policy Troubleshooting Third-party Scripts When using third-party scripts with CSP, ensure you add the necessary domains and pass the nonce:pages/_app.tsxTypeScriptJavaScriptTypeScriptimport type { AppProps } from 'next/app' import Script from 'next/script' export default function App({ Component, pageProps }: AppProps) { const nonce = pageProps.nonce return ( <> <Component {...pageProps} /> <Script src=\"https://www.googletagmanager.com/gtag/js\" strategy=\"afterInteractive\" nonce={nonce} /> </> ) } Update your CSP to allow third-party domains: proxy.tsTypeScriptJavaScriptTypeScriptconst cspHeader = ` default-src 'self'; script-src 'self' 'nonce-${nonce}' 'strict-dynamic' https://www.googletagmanager.com; connect-src 'self' https://www.google-analytics.com; img-src 'self' data: https://www.google-analytics.com; ` Common CSP Violations Inline styles: Use CSS-in-JS libraries that support nonces or move styles to external files Dynamic imports: Ensure dynamic imports are allowed in your script-src policy WebAssembly: Add 'wasm-unsafe-eval' if using WebAssembly Service workers: Add appropriate policies for service worker scripts Version History VersionChangesv14.0.0Experimental SRI support added for hash-based CSPv13.4.20Recommended for proper nonce handling and CSP header parsing.",
      "code": "import { NextRequest, NextResponse } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n  const cspHeader = `\n    default-src 'self';\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\n    style-src 'self' 'nonce-${nonce}';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    upgrade-insecure-requests;\n`\n  // Replace newline characters and spaces\n  const contentSecurityPolicyHeaderValue = cspHeader\n    .replace(/\\s{2,}/g, ' ')\n    .trim()\n \n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set('x-nonce', nonce)\n \n  requestHeaders.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  const response = NextResponse.next({\n    request: {\n      headers: requestHeaders,\n    },\n  })\n  response.headers.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  return response\n}"
    },
    {
      "description": "How to set a Content Security Policy (CSP) for your Next.js application Content Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks. By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more. Examples Strict CSP Nonces A nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives. Why use a nonce? CSP can block both inline and external scripts to prevent attacks. A nonce lets you safely allow specific scripts to run—only if they include the matching nonce value. If an attacker wanted to load a script into your page, they'd need to guess the nonce value. That's why the nonce must be unpredictable and unique for every request. Adding a nonce with Proxy Proxy enables you to add headers and generate nonces before the page renders. Every time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces. For example: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server' export function proxy(request: NextRequest) { const nonce = Buffer.from(crypto.randomUUID()).toString('base64') const cspHeader = ` default-src 'self'; script-src 'self' 'nonce-${nonce}' 'strict-dynamic'; style-src 'self' 'nonce-${nonce}'; img-src 'self' blob: data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests; ` // Replace newline characters and spaces const contentSecurityPolicyHeaderValue = cspHeader .replace(/\\s{2,}/g, ' ') .trim() const requestHeaders = new Headers(request.headers) requestHeaders.set('x-nonce', nonce) requestHeaders.set( 'Content-Security-Policy', contentSecurityPolicyHeaderValue ) const response = NextResponse.next({ request: { headers: requestHeaders, }, }) response.headers.set( 'Content-Security-Policy', contentSecurityPolicyHeaderValue ) return response } By default, Proxy runs on all requests. You can filter Proxy to run on specific paths using a matcher. We recommend ignoring matching prefetches (from next/link) and static assets that don't need the CSP header. proxy.tsTypeScriptJavaScriptTypeScriptexport const config = { matcher: [ /* * Match all request paths except for the ones starting with: * - api (API routes) * - _next/static (static files) * - _next/image (image optimization files) * - favicon.ico (favicon file) */ { source: '/((?!api|_next/static|_next/image|favicon.ico).*)', missing: [ { type: 'header', key: 'next-router-prefetch' }, { type: 'header', key: 'purpose', value: 'prefetch' }, ], }, ], } How nonces work in Next.js To use a nonce, your page must be dynamically rendered. This is because Next.js applies nonces during server-side rendering, based on the CSP header present in the request. Static pages are generated at build time, when no request or response headers exist—so no nonce can be injected. Here’s how nonce support works in a dynamically rendered page: Proxy generates a nonce: Your proxy creates a unique nonce for the request, adds it to your Content-Security-Policy header, and also sets it in a custom x-nonce header. Next.js extracts the nonce: During rendering, Next.js parses the Content-Security-Policy header and extracts the nonce using the 'nonce-{value}' pattern. Nonce is applied automatically: Next.js attaches the nonce to: Framework scripts (React, Next.js runtime) Page-specific JavaScript bundles Inline styles and scripts generated by Next.js Any <Script> components using the nonce prop Because of this automatic behavior, you don’t need to manually add a nonce to each tag. Forcing dynamic rendering If you're using nonces, you may need to explicitly opt pages into dynamic rendering: app/page.tsxTypeScriptJavaScriptTypeScriptimport { connection } from 'next/server' export default async function Page() { // wait for an incoming request to render this page await connection() // Your page content } Reading the nonce You can provide the nonce to your page using getServerSideProps:pages/index.tsxTypeScriptJavaScriptTypeScriptimport Script from 'next/script' import type { GetServerSideProps } from 'next' export default function Page({ nonce }) { return ( <Script src=\"https://www.googletagmanager.com/gtag/js\" strategy=\"afterInteractive\" nonce={nonce} /> ) } export const getServerSideProps: GetServerSideProps = async ({ req }) => { const nonce = req.headers['x-nonce'] return { props: { nonce } } }You can also access the nonce in _document.tsx for Pages Router applications:pages/_document.tsxTypeScriptJavaScriptTypeScriptimport Document, { Html, Head, Main, NextScript, DocumentContext, DocumentInitialProps, } from 'next/document' interface ExtendedDocumentProps extends DocumentInitialProps { nonce?: string } class MyDocument extends Document<ExtendedDocumentProps> { static async getInitialProps( ctx: DocumentContext ): Promise<ExtendedDocumentProps> { const initialProps = await Document.getInitialProps(ctx) const nonce = ctx.req?.headers?.['x-nonce'] as string | undefined return { ...initialProps, nonce, } } render() { const { nonce } = this.props return ( <Html lang=\"en\"> <Head nonce={nonce} /> <body> <Main /> <NextScript nonce={nonce} /> </body> </Html> ) } } export default MyDocument Static vs Dynamic Rendering with CSP Using nonces has important implications for how your Next.js application renders: Dynamic Rendering Requirement When you use nonces in your CSP, all pages must be dynamically rendered. This means: Pages will build successfully but may encounter runtime errors if not properly configured for dynamic rendering Each request generates a fresh page with a new nonce Static optimization and Incremental Static Regeneration (ISR) are disabled Pages cannot be cached by CDNs without additional configuration Partial Prerendering (PPR) is incompatible with nonce-based CSP since static shell scripts won't have access to the nonce Performance Implications The shift from static to dynamic rendering affects performance: Slower initial page loads: Pages must be generated on each request Increased server load: Every request requires server-side rendering No CDN caching: Dynamic pages cannot be cached at the edge by default Higher hosting costs: More server resources needed for dynamic rendering When to use nonces Consider nonces when: You have strict security requirements that prohibit 'unsafe-inline' Your application handles sensitive data You need to allow specific inline scripts while blocking others Compliance requirements mandate strict CSP Without Nonces For applications that do not require nonces, you can set the CSP header directly in your next.config.js file: next.config.jsconst cspHeader = ` default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' blob: data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests; ` module.exports = { async headers() { return [ { source: '/(.*)', headers: [ { key: 'Content-Security-Policy', value: cspHeader.replace(/\\n/g, ''), }, ], }, ] }, } Development vs Production Considerations CSP implementation differs between development and production environments: Development Environment In development, you will need to enable 'unsafe-eval' to support APIs that provide additional debugging information: proxy.tsTypeScriptJavaScriptTypeScriptexport function proxy(request: NextRequest) { const nonce = Buffer.from(crypto.randomUUID()).toString('base64') const isDev = process.env.NODE_ENV === 'development' const cspHeader = ` default-src 'self'; script-src 'self' 'nonce-${nonce}' 'strict-dynamic' ${isDev ? \"'unsafe-eval'\" : ''}; style-src 'self' ${isDev ? \"'unsafe-inline'\" : `'nonce-${nonce}'`}; img-src 'self' blob: data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests; ` // Rest of proxy implementation } Production Deployment Common issues in production: Nonce not applied: Ensure your proxy runs on all necessary routes Static assets blocked: Verify your CSP allows Next.js static assets Third-party scripts: Add necessary domains to your CSP policy Troubleshooting Third-party Scripts When using third-party scripts with CSP, ensure you add the necessary domains and pass the nonce:pages/_app.tsxTypeScriptJavaScriptTypeScriptimport type { AppProps } from 'next/app' import Script from 'next/script' export default function App({ Component, pageProps }: AppProps) { const nonce = pageProps.nonce return ( <> <Component {...pageProps} /> <Script src=\"https://www.googletagmanager.com/gtag/js\" strategy=\"afterInteractive\" nonce={nonce} /> </> ) } Update your CSP to allow third-party domains: proxy.tsTypeScriptJavaScriptTypeScriptconst cspHeader = ` default-src 'self'; script-src 'self' 'nonce-${nonce}' 'strict-dynamic' https://www.googletagmanager.com; connect-src 'self' https://www.google-analytics.com; img-src 'self' data: https://www.google-analytics.com; ` Common CSP Violations Inline styles: Use CSS-in-JS libraries that support nonces or move styles to external files Dynamic imports: Ensure dynamic imports are allowed in your script-src policy WebAssembly: Add 'wasm-unsafe-eval' if using WebAssembly Service workers: Add appropriate policies for service worker scripts Version History VersionChangesv14.0.0Experimental SRI support added for hash-based CSPv13.4.20Recommended for proper nonce handling and CSP header parsing.",
      "code": "import { NextRequest, NextResponse } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n  const cspHeader = `\n    default-src 'self';\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\n    style-src 'self' 'nonce-${nonce}';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    upgrade-insecure-requests;\n`\n  // Replace newline characters and spaces\n  const contentSecurityPolicyHeaderValue = cspHeader\n    .replace(/\\s{2,}/g, ' ')\n    .trim()\n \n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set('x-nonce', nonce)\n \n  requestHeaders.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  const response = NextResponse.next({\n    request: {\n      headers: requestHeaders,\n    },\n  })\n  response.headers.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  return response\n}"
    },
    {
      "description": "For example:",
      "code": "import { NextRequest, NextResponse } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n  const cspHeader = `\n    default-src 'self';\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\n    style-src 'self' 'nonce-${nonce}';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    upgrade-insecure-requests;\n`\n  // Replace newline characters and spaces\n  const contentSecurityPolicyHeaderValue = cspHeader\n    .replace(/\\s{2,}/g, ' ')\n    .trim()\n \n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set('x-nonce', nonce)\n \n  requestHeaders.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  const response = NextResponse.next({\n    request: {\n      headers: requestHeaders,\n    },\n  })\n  response.headers.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  return response\n}"
    }
  ],
  "links": [
    "https://nextjs.org/docs/pages",
    "https://nextjs.org/docs/pages/guides",
    "https://nextjs.org/docs/pages/guides/content-security-policy",
    "https://nextjs.org/docs/app/api-reference/file-conventions/proxy",
    "https://nextjs.org/docs/app/guides/caching",
    "https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props",
    "https://nextjs.org/docs/app/api-reference/config/next-config-js",
    "https://nextjs.org/docs/pages/guides/ci-build-caching",
    "https://nextjs.org/docs/pages/guides/css-in-js"
  ]
}