{
  "url": "https://nextjs.org/docs/app/guides/progressive-web-apps",
  "title": "How to build a Progressive Web Application (PWA) with Next.js",
  "content": "Progressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that provide a seamless, app-like experience across all platforms without the need for multiple codebases or app store approvals.\n\nNext.js provides built-in support for creating a web app manifest using the App Router. You can create either a static or dynamic manifest file:\n\nFor example, create a app/manifest.ts or app/manifest.json file:\n\nThis file should contain information about the name, icons, and how it should be displayed as an icon on the user's device. This will allow users to install your PWA on their home screen, providing a native app-like experience.\n\nYou can use tools like favicon generators to create the different icon sets and place the generated files in your public/ folder.\n\nWeb Push Notifications are supported with all modern browsers, including:\n\nThis makes PWAs a viable alternative to native apps. Notably, you can trigger install prompts without needing offline support.\n\nWeb Push Notifications allow you to re-engage users even when they're not actively using your app. Here's how to implement them in a Next.js application:\n\nFirst, let's create the main page component in app/page.tsx. We'll break it down into smaller parts for better understanding. First, we’ll add some of the imports and utilities we’ll need. It’s okay that the referenced Server Actions do not yet exist:\n\nLet’s now add a component to manage subscribing, unsubscribing, and sending push notifications.\n\nFinally, let’s create a component to show a message for iOS devices to instruct them to install to their home screen, and only show this if the app is not already installed.\n\nNow, let’s create the Server Actions which this file calls.\n\nCreate a new file to contain your actions at app/actions.ts. This file will handle creating subscriptions, deleting subscriptions, and sending notifications.\n\nSending a notification will be handled by our service worker, created in step 5.\n\nIn a production environment, you would want to store the subscription in a database for persistence across server restarts and to manage multiple users' subscriptions.\n\nTo use the Web Push API, you need to generate VAPID keys. The simplest way is to use the web-push CLI directly:\n\nFirst, install web-push globally:\n\nGenerate the VAPID keys by running:\n\nCopy the output and paste the keys into your .env file:\n\nCreate a public/sw.js file for your service worker:\n\nThis service worker supports custom images and notifications. It handles incoming push events and notification clicks.\n\nRemember to test your service worker thoroughly to ensure it behaves as expected across different devices and browsers. Also, make sure to update the 'https://your-website.com' link in the notificationclick event listener to the appropriate URL for your application.\n\nThe InstallPrompt component defined in step 2 shows a message for iOS devices to instruct them to install to their home screen.\n\nTo ensure your application can be installed to a mobile home screen, you must have:\n\nModern browsers will automatically show an installation prompt to users when these criteria are met. You can provide a custom installation button with beforeinstallprompt, however, we do not recommend this as it is not cross browser and platform (does not work on Safari iOS).\n\nTo ensure you can view notifications locally, ensure that:\n\nSecurity is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using the next.config.js file. For example:\n\nLet’s go over each of these options:\n\nLearn more about defining Content Security Policies with Next.js.",
  "headings": [
    {
      "level": "h1",
      "text": "How to build a Progressive Web Application (PWA) with Next.js",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Creating a PWA with Next.js",
      "id": "creating-a-pwa-with-nextjs"
    },
    {
      "level": "h3",
      "text": "1. Creating the Web App Manifest",
      "id": "1-creating-the-web-app-manifest"
    },
    {
      "level": "h3",
      "text": "2. Implementing Web Push Notifications",
      "id": "2-implementing-web-push-notifications"
    },
    {
      "level": "h3",
      "text": "3. Implementing Server Actions",
      "id": "3-implementing-server-actions"
    },
    {
      "level": "h3",
      "text": "4. Generating VAPID Keys",
      "id": "4-generating-vapid-keys"
    },
    {
      "level": "h3",
      "text": "5. Creating a Service Worker",
      "id": "5-creating-a-service-worker"
    },
    {
      "level": "h3",
      "text": "6. Adding to Home Screen",
      "id": "6-adding-to-home-screen"
    },
    {
      "level": "h3",
      "text": "7. Testing Locally",
      "id": "7-testing-locally"
    },
    {
      "level": "h3",
      "text": "8. Securing your application",
      "id": "8-securing-your-application"
    },
    {
      "level": "h2",
      "text": "Extending your PWA",
      "id": "extending-your-pwa"
    },
    {
      "level": "h2",
      "text": "Next Steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "manifest.json",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "import type { MetadataRoute } from 'next'\n \nexport default function manifest(): MetadataRoute.Manifest {\n  return {\n    name: 'Next.js PWA',\n    short_name: 'NextPWA',\n    description: 'A Progressive Web App built with Next.js',\n    start_url: '/',\n    display: 'standalone',\n    background_color: '#ffffff',\n    theme_color: '#000000',\n    icons: [\n      {\n        src: '/icon-192x192.png',\n        sizes: '192x192',\n        type: 'image/png',\n      },\n      {\n        src: '/icon-512x512.png',\n        sizes: '512x512',\n        type: 'image/png',\n      },\n    ],\n  }\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nimport { useState, useEffect } from 'react'\nimport { subscribeUser, unsubscribeUser, sendNotification } from './actions'\n \nfunction urlBase64ToUint8Array(base64String: string) {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/')\n \n  const rawData = window.atob(base64)\n  const outputArray = new Uint8Array(rawData.length)\n \n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i)\n  }\n  return outputArray\n}",
      "language": "python"
    },
    {
      "code": "function PushNotificationManager() {\n  const [isSupported, setIsSupported] = useState(false)\n  const [subscription, setSubscription] = useState<PushSubscription | null>(\n    null\n  )\n  const [message, setMessage] = useState('')\n \n  useEffect(() => {\n    if ('serviceWorker' in navigator && 'PushManager' in window) {\n      setIsSupported(true)\n      registerServiceWorker()\n    }\n  }, [])\n \n  async function registerServiceWorker() {\n    const registration = await navigator.serviceWorker.register('/sw.js', {\n      scope: '/',\n      updateViaCache: 'none',\n    })\n    const sub = await registration.pushManager.getSubscription()\n    setSubscription(sub)\n  }\n \n  async function subscribeToPush() {\n    const registration = await navigator.serviceWorker.ready\n    const sub = await registration.pushManager.subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: urlBase64ToUint8Array(\n        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!\n      ),\n    })\n    setSubscription(sub)\n    const serializedSub = JSON.parse(JSON.stringify(sub))\n    await subscribeUser(serializedSub)\n  }\n \n  async function unsubscribeFromPush() {\n    await subscription?.unsubscribe()\n    setSubscription(null)\n    await unsubscribeUser()\n  }\n \n  async function sendTestNotification() {\n    if (subscription) {\n      await sendNotification(message)\n      setMessage('')\n    }\n  }\n \n  if (!isSupported) {\n    return <p>Push notifications are not supported in this browser.</p>\n  }\n \n  return (\n    <div>\n      <h3>Push Notifications</h3>\n      {subscription ? (\n        <>\n          <p>You are subscribed to push notifications.</p>\n          <button onClick={unsubscribeFromPush}>Unsubscribe</button>\n          <input\n            type=\"text\"\n            placeholder=\"Enter notification message\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n          />\n          <button onClick={sendTestNotification}>Send Test</button>\n        </>\n      ) : (\n        <>\n          <p>You are not subscribed to push notifications.</p>\n          <button onClick={subscribeToPush}>Subscribe</button>\n        </>\n      )}\n    </div>\n  )\n}",
      "language": "javascript"
    },
    {
      "code": "function InstallPrompt() {\n  const [isIOS, setIsIOS] = useState(false)\n  const [isStandalone, setIsStandalone] = useState(false)\n \n  useEffect(() => {\n    setIsIOS(\n      /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream\n    )\n \n    setIsStandalone(window.matchMedia('(display-mode: standalone)').matches)\n  }, [])\n \n  if (isStandalone) {\n    return null // Don't show install button if already installed\n  }\n \n  return (\n    <div>\n      <h3>Install App</h3>\n      <button>Add to Home Screen</button>\n      {isIOS && (\n        <p>\n          To install this app on your iOS device, tap the share button\n          <span role=\"img\" aria-label=\"share icon\">\n            {' '}\n            ⎋{' '}\n          </span>\n          and then \"Add to Home Screen\"\n          <span role=\"img\" aria-label=\"plus icon\">\n            {' '}\n            ➕{' '}\n          </span>\n          .\n        </p>\n      )}\n    </div>\n  )\n}\n \nexport default function Page() {\n  return (\n    <div>\n      <PushNotificationManager />\n      <InstallPrompt />\n    </div>\n  )\n}",
      "language": "javascript"
    },
    {
      "code": "'use server'\n \nimport webpush from 'web-push'\n \nwebpush.setVapidDetails(\n  '<mailto:your-email@example.com>',\n  process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,\n  process.env.VAPID_PRIVATE_KEY!\n)\n \nlet subscription: PushSubscription | null = null\n \nexport async function subscribeUser(sub: PushSubscription) {\n  subscription = sub\n  // In a production environment, you would want to store the subscription in a database\n  // For example: await db.subscriptions.create({ data: sub })\n  return { success: true }\n}\n \nexport async function unsubscribeUser() {\n  subscription = null\n  // In a production environment, you would want to remove the subscription from the database\n  // For example: await db.subscriptions.delete({ where: { ... } })\n  return { success: true }\n}\n \nexport async function sendNotification(message: string) {\n  if (!subscription) {\n    throw new Error('No subscription available')\n  }\n \n  try {\n    await webpush.sendNotification(\n      subscription,\n      JSON.stringify({\n        title: 'Test Notification',\n        body: message,\n        icon: '/icon.png',\n      })\n    )\n    return { success: true }\n  } catch (error) {\n    console.error('Error sending push notification:', error)\n    return { success: false, error: 'Failed to send notification' }\n  }\n}",
      "language": "python"
    },
    {
      "code": "npm install -g web-push",
      "language": "unknown"
    },
    {
      "code": "web-push generate-vapid-keys",
      "language": "unknown"
    },
    {
      "code": "NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here\nVAPID_PRIVATE_KEY=your_private_key_here",
      "language": "unknown"
    },
    {
      "code": "self.addEventListener('push', function (event) {\n  if (event.data) {\n    const data = event.data.json()\n    const options = {\n      body: data.body,\n      icon: data.icon || '/icon.png',\n      badge: '/badge.png',\n      vibrate: [100, 50, 100],\n      data: {\n        dateOfArrival: Date.now(),\n        primaryKey: '2',\n      },\n    }\n    event.waitUntil(self.registration.showNotification(data.title, options))\n  }\n})\n \nself.addEventListener('notificationclick', function (event) {\n  console.log('Notification click received.')\n  event.notification.close()\n  event.waitUntil(clients.openWindow('<https://your-website.com>'))\n})",
      "language": "javascript"
    },
    {
      "code": "module.exports = {\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff',\n          },\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY',\n          },\n          {\n            key: 'Referrer-Policy',\n            value: 'strict-origin-when-cross-origin',\n          },\n        ],\n      },\n      {\n        source: '/sw.js',\n        headers: [\n          {\n            key: 'Content-Type',\n            value: 'application/javascript; charset=utf-8',\n          },\n          {\n            key: 'Cache-Control',\n            value: 'no-cache, no-store, must-revalidate',\n          },\n          {\n            key: 'Content-Security-Policy',\n            value: \"default-src 'self'; script-src 'self'\",\n          },\n        ],\n      },\n    ]\n  },\n}",
      "language": "unknown"
    }
  ],
  "patterns": [
    {
      "description": "App RouterGuidesPWAsCopy pageHow to build a Progressive Web Application (PWA) with Next.jsProgressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that provide a seamless, app-like experience across all platforms without the need for multiple codebases or app store approvals. PWAs allow you to: Deploy updates instantly without waiting for app store approval Create cross-platform applications with a single codebase Provide native-like features such as home screen installation and push notifications Creating a PWA with Next.js 1. Creating the Web App Manifest Next.js provides built-in support for creating a web app manifest using the App Router. You can create either a static or dynamic manifest file: For example, create a app/manifest.ts or app/manifest.json file: app/manifest.tsTypeScriptJavaScriptTypeScriptimport type { MetadataRoute } from 'next' export default function manifest(): MetadataRoute.Manifest { return { name: 'Next.js PWA', short_name: 'NextPWA', description: 'A Progressive Web App built with Next.js', start_url: '/', display: 'standalone', background_color: '#ffffff', theme_color: '#000000', icons: [ { src: '/icon-192x192.png', sizes: '192x192', type: 'image/png', }, { src: '/icon-512x512.png', sizes: '512x512', type: 'image/png', }, ], } } This file should contain information about the name, icons, and how it should be displayed as an icon on the user's device. This will allow users to install your PWA on their home screen, providing a native app-like experience. You can use tools like favicon generators to create the different icon sets and place the generated files in your public/ folder. 2. Implementing Web Push Notifications Web Push Notifications are supported with all modern browsers, including: iOS 16.4+ for applications installed to the home screen Safari 16 for macOS 13 or later Chromium based browsers Firefox This makes PWAs a viable alternative to native apps. Notably, you can trigger install prompts without needing offline support. Web Push Notifications allow you to re-engage users even when they're not actively using your app. Here's how to implement them in a Next.js application: First, let's create the main page component in app/page.tsx. We'll break it down into smaller parts for better understanding. First, we’ll add some of the imports and utilities we’ll need. It’s okay that the referenced Server Actions do not yet exist: 'use client' import { useState, useEffect } from 'react' import { subscribeUser, unsubscribeUser, sendNotification } from './actions' function urlBase64ToUint8Array(base64String: string) { const padding = '='.repeat((4 - (base64String.length % 4)) % 4) const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/') const rawData = window.atob(base64) const outputArray = new Uint8Array(rawData.length) for (let i = 0; i < rawData.length; ++i) { outputArray[i] = rawData.charCodeAt(i) } return outputArray } Let’s now add a component to manage subscribing, unsubscribing, and sending push notifications. function PushNotificationManager() { const [isSupported, setIsSupported] = useState(false) const [subscription, setSubscription] = useState<PushSubscription | null>( null ) const [message, setMessage] = useState('') useEffect(() => { if ('serviceWorker' in navigator && 'PushManager' in window) { setIsSupported(true) registerServiceWorker() } }, []) async function registerServiceWorker() { const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/', updateViaCache: 'none', }) const sub = await registration.pushManager.getSubscription() setSubscription(sub) } async function subscribeToPush() { const registration = await navigator.serviceWorker.ready const sub = await registration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array( process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY! ), }) setSubscription(sub) const serializedSub = JSON.parse(JSON.stringify(sub)) await subscribeUser(serializedSub) } async function unsubscribeFromPush() { await subscription?.unsubscribe() setSubscription(null) await unsubscribeUser() } async function sendTestNotification() { if (subscription) { await sendNotification(message) setMessage('') } } if (!isSupported) { return <p>Push notifications are not supported in this browser.</p> } return ( <div> <h3>Push Notifications</h3> {subscription ? ( <> <p>You are subscribed to push notifications.</p> <button onClick={unsubscribeFromPush}>Unsubscribe</button> <input type=\"text\" placeholder=\"Enter notification message\" value={message} onChange={(e) => setMessage(e.target.value)} /> <button onClick={sendTestNotification}>Send Test</button> </> ) : ( <> <p>You are not subscribed to push notifications.</p> <button onClick={subscribeToPush}>Subscribe</button> </> )} </div> ) } Finally, let’s create a component to show a message for iOS devices to instruct them to install to their home screen, and only show this if the app is not already installed. function InstallPrompt() { const [isIOS, setIsIOS] = useState(false) const [isStandalone, setIsStandalone] = useState(false) useEffect(() => { setIsIOS( /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream ) setIsStandalone(window.matchMedia('(display-mode: standalone)').matches) }, []) if (isStandalone) { return null // Don't show install button if already installed } return ( <div> <h3>Install App</h3> <button>Add to Home Screen</button> {isIOS && ( <p> To install this app on your iOS device, tap the share button <span role=\"img\" aria-label=\"share icon\"> {' '} ⎋{' '} </span> and then \"Add to Home Screen\" <span role=\"img\" aria-label=\"plus icon\"> {' '} ➕{' '} </span> . </p> )} </div> ) } export default function Page() { return ( <div> <PushNotificationManager /> <InstallPrompt /> </div> ) } Now, let’s create the Server Actions which this file calls. 3. Implementing Server Actions Create a new file to contain your actions at app/actions.ts. This file will handle creating subscriptions, deleting subscriptions, and sending notifications. app/actions.tsTypeScriptJavaScriptTypeScript'use server' import webpush from 'web-push' webpush.setVapidDetails( '<mailto:your-email@example.com>', process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!, process.env.VAPID_PRIVATE_KEY! ) let subscription: PushSubscription | null = null export async function subscribeUser(sub: PushSubscription) { subscription = sub // In a production environment, you would want to store the subscription in a database // For example: await db.subscriptions.create({ data: sub }) return { success: true } } export async function unsubscribeUser() { subscription = null // In a production environment, you would want to remove the subscription from the database // For example: await db.subscriptions.delete({ where: { ... } }) return { success: true } } export async function sendNotification(message: string) { if (!subscription) { throw new Error('No subscription available') } try { await webpush.sendNotification( subscription, JSON.stringify({ title: 'Test Notification', body: message, icon: '/icon.png', }) ) return { success: true } } catch (error) { console.error('Error sending push notification:', error) return { success: false, error: 'Failed to send notification' } } } Sending a notification will be handled by our service worker, created in step 5. In a production environment, you would want to store the subscription in a database for persistence across server restarts and to manage multiple users' subscriptions. 4. Generating VAPID Keys To use the Web Push API, you need to generate VAPID keys. The simplest way is to use the web-push CLI directly: First, install web-push globally: Terminalnpm install -g web-push Generate the VAPID keys by running: Terminalweb-push generate-vapid-keys Copy the output and paste the keys into your .env file: NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here VAPID_PRIVATE_KEY=your_private_key_here 5. Creating a Service Worker Create a public/sw.js file for your service worker: public/sw.jsself.addEventListener('push', function (event) { if (event.data) { const data = event.data.json() const options = { body: data.body, icon: data.icon || '/icon.png', badge: '/badge.png', vibrate: [100, 50, 100], data: { dateOfArrival: Date.now(), primaryKey: '2', }, } event.waitUntil(self.registration.showNotification(data.title, options)) } }) self.addEventListener('notificationclick', function (event) { console.log('Notification click received.') event.notification.close() event.waitUntil(clients.openWindow('<https://your-website.com>')) }) This service worker supports custom images and notifications. It handles incoming push events and notification clicks. You can set custom icons for notifications using the icon and badge properties. The vibrate pattern can be adjusted to create custom vibration alerts on supported devices. Additional data can be attached to the notification using the data property. Remember to test your service worker thoroughly to ensure it behaves as expected across different devices and browsers. Also, make sure to update the 'https://your-website.com' link in the notificationclick event listener to the appropriate URL for your application. 6. Adding to Home Screen The InstallPrompt component defined in step 2 shows a message for iOS devices to instruct them to install to their home screen. To ensure your application can be installed to a mobile home screen, you must have: A valid web app manifest (created in step 1) The website served over HTTPS Modern browsers will automatically show an installation prompt to users when these criteria are met. You can provide a custom installation button with beforeinstallprompt, however, we do not recommend this as it is not cross browser and platform (does not work on Safari iOS). 7. Testing Locally To ensure you can view notifications locally, ensure that: You are running locally with HTTPS Use next dev --experimental-https for testing Your browser (Chrome, Safari, Firefox) has notifications enabled When prompted locally, accept permissions to use notifications Ensure notifications are not disabled globally for the entire browser If you are still not seeing notifications, try using another browser to debug 8. Securing your application Security is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using the next.config.js file. For example: next.config.jsmodule.exports = { async headers() { return [ { source: '/(.*)', headers: [ { key: 'X-Content-Type-Options', value: 'nosniff', }, { key: 'X-Frame-Options', value: 'DENY', }, { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin', }, ], }, { source: '/sw.js', headers: [ { key: 'Content-Type', value: 'application/javascript; charset=utf-8', }, { key: 'Cache-Control', value: 'no-cache, no-store, must-revalidate', }, { key: 'Content-Security-Policy', value: \"default-src 'self'; script-src 'self'\", }, ], }, ] }, } Let’s go over each of these options: Global Headers (applied to all routes): X-Content-Type-Options: nosniff: Prevents MIME type sniffing, reducing the risk of malicious file uploads. X-Frame-Options: DENY: Protects against clickjacking attacks by preventing your site from being embedded in iframes. Referrer-Policy: strict-origin-when-cross-origin: Controls how much referrer information is included with requests, balancing security and functionality. Service Worker Specific Headers: Content-Type: application/javascript; charset=utf-8: Ensures the service worker is interpreted correctly as JavaScript. Cache-Control: no-cache, no-store, must-revalidate: Prevents caching of the service worker, ensuring users always get the latest version. Content-Security-Policy: default-src 'self'; script-src 'self': Implements a strict Content Security Policy for the service worker, only allowing scripts from the same origin. Learn more about defining Content Security Policies with Next.js. Extending your PWA Exploring PWA Capabilities: PWAs can leverage various web APIs to provide advanced functionality. Consider exploring features like background sync, periodic background sync, or the File System Access API to enhance your application. For inspiration and up-to-date information on PWA capabilities, you can refer to resources like What PWA Can Do Today. Static Exports: If your application requires not running a server, and instead using a static export of files, you can update the Next.js configuration to enable this change. Learn more in the Next.js Static Export documentation. However, you will need to move from Server Actions to calling an external API, as well as moving your defined headers to your proxy. Offline Support: To provide offline functionality, one option is Serwist with Next.js. You can find an example of how to integrate Serwist with Next.js in their documentation. Note: this plugin currently requires webpack configuration. Security Considerations: Ensure that your service worker is properly secured. This includes using HTTPS, validating the source of push messages, and implementing proper error handling. User Experience: Consider implementing progressive enhancement techniques to ensure your app works well even when certain PWA features are not supported by the user's browser. Next Stepsmanifest.jsonAPI Reference for manifest.json file.",
      "code": "app/manifest.ts"
    },
    {
      "description": "How to build a Progressive Web Application (PWA) with Next.jsProgressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that provide a seamless, app-like experience across all platforms without the need for multiple codebases or app store approvals. PWAs allow you to: Deploy updates instantly without waiting for app store approval Create cross-platform applications with a single codebase Provide native-like features such as home screen installation and push notifications Creating a PWA with Next.js 1. Creating the Web App Manifest Next.js provides built-in support for creating a web app manifest using the App Router. You can create either a static or dynamic manifest file: For example, create a app/manifest.ts or app/manifest.json file: app/manifest.tsTypeScriptJavaScriptTypeScriptimport type { MetadataRoute } from 'next' export default function manifest(): MetadataRoute.Manifest { return { name: 'Next.js PWA', short_name: 'NextPWA', description: 'A Progressive Web App built with Next.js', start_url: '/', display: 'standalone', background_color: '#ffffff', theme_color: '#000000', icons: [ { src: '/icon-192x192.png', sizes: '192x192', type: 'image/png', }, { src: '/icon-512x512.png', sizes: '512x512', type: 'image/png', }, ], } } This file should contain information about the name, icons, and how it should be displayed as an icon on the user's device. This will allow users to install your PWA on their home screen, providing a native app-like experience. You can use tools like favicon generators to create the different icon sets and place the generated files in your public/ folder. 2. Implementing Web Push Notifications Web Push Notifications are supported with all modern browsers, including: iOS 16.4+ for applications installed to the home screen Safari 16 for macOS 13 or later Chromium based browsers Firefox This makes PWAs a viable alternative to native apps. Notably, you can trigger install prompts without needing offline support. Web Push Notifications allow you to re-engage users even when they're not actively using your app. Here's how to implement them in a Next.js application: First, let's create the main page component in app/page.tsx. We'll break it down into smaller parts for better understanding. First, we’ll add some of the imports and utilities we’ll need. It’s okay that the referenced Server Actions do not yet exist: 'use client' import { useState, useEffect } from 'react' import { subscribeUser, unsubscribeUser, sendNotification } from './actions' function urlBase64ToUint8Array(base64String: string) { const padding = '='.repeat((4 - (base64String.length % 4)) % 4) const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/') const rawData = window.atob(base64) const outputArray = new Uint8Array(rawData.length) for (let i = 0; i < rawData.length; ++i) { outputArray[i] = rawData.charCodeAt(i) } return outputArray } Let’s now add a component to manage subscribing, unsubscribing, and sending push notifications. function PushNotificationManager() { const [isSupported, setIsSupported] = useState(false) const [subscription, setSubscription] = useState<PushSubscription | null>( null ) const [message, setMessage] = useState('') useEffect(() => { if ('serviceWorker' in navigator && 'PushManager' in window) { setIsSupported(true) registerServiceWorker() } }, []) async function registerServiceWorker() { const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/', updateViaCache: 'none', }) const sub = await registration.pushManager.getSubscription() setSubscription(sub) } async function subscribeToPush() { const registration = await navigator.serviceWorker.ready const sub = await registration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array( process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY! ), }) setSubscription(sub) const serializedSub = JSON.parse(JSON.stringify(sub)) await subscribeUser(serializedSub) } async function unsubscribeFromPush() { await subscription?.unsubscribe() setSubscription(null) await unsubscribeUser() } async function sendTestNotification() { if (subscription) { await sendNotification(message) setMessage('') } } if (!isSupported) { return <p>Push notifications are not supported in this browser.</p> } return ( <div> <h3>Push Notifications</h3> {subscription ? ( <> <p>You are subscribed to push notifications.</p> <button onClick={unsubscribeFromPush}>Unsubscribe</button> <input type=\"text\" placeholder=\"Enter notification message\" value={message} onChange={(e) => setMessage(e.target.value)} /> <button onClick={sendTestNotification}>Send Test</button> </> ) : ( <> <p>You are not subscribed to push notifications.</p> <button onClick={subscribeToPush}>Subscribe</button> </> )} </div> ) } Finally, let’s create a component to show a message for iOS devices to instruct them to install to their home screen, and only show this if the app is not already installed. function InstallPrompt() { const [isIOS, setIsIOS] = useState(false) const [isStandalone, setIsStandalone] = useState(false) useEffect(() => { setIsIOS( /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream ) setIsStandalone(window.matchMedia('(display-mode: standalone)').matches) }, []) if (isStandalone) { return null // Don't show install button if already installed } return ( <div> <h3>Install App</h3> <button>Add to Home Screen</button> {isIOS && ( <p> To install this app on your iOS device, tap the share button <span role=\"img\" aria-label=\"share icon\"> {' '} ⎋{' '} </span> and then \"Add to Home Screen\" <span role=\"img\" aria-label=\"plus icon\"> {' '} ➕{' '} </span> . </p> )} </div> ) } export default function Page() { return ( <div> <PushNotificationManager /> <InstallPrompt /> </div> ) } Now, let’s create the Server Actions which this file calls. 3. Implementing Server Actions Create a new file to contain your actions at app/actions.ts. This file will handle creating subscriptions, deleting subscriptions, and sending notifications. app/actions.tsTypeScriptJavaScriptTypeScript'use server' import webpush from 'web-push' webpush.setVapidDetails( '<mailto:your-email@example.com>', process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!, process.env.VAPID_PRIVATE_KEY! ) let subscription: PushSubscription | null = null export async function subscribeUser(sub: PushSubscription) { subscription = sub // In a production environment, you would want to store the subscription in a database // For example: await db.subscriptions.create({ data: sub }) return { success: true } } export async function unsubscribeUser() { subscription = null // In a production environment, you would want to remove the subscription from the database // For example: await db.subscriptions.delete({ where: { ... } }) return { success: true } } export async function sendNotification(message: string) { if (!subscription) { throw new Error('No subscription available') } try { await webpush.sendNotification( subscription, JSON.stringify({ title: 'Test Notification', body: message, icon: '/icon.png', }) ) return { success: true } } catch (error) { console.error('Error sending push notification:', error) return { success: false, error: 'Failed to send notification' } } } Sending a notification will be handled by our service worker, created in step 5. In a production environment, you would want to store the subscription in a database for persistence across server restarts and to manage multiple users' subscriptions. 4. Generating VAPID Keys To use the Web Push API, you need to generate VAPID keys. The simplest way is to use the web-push CLI directly: First, install web-push globally: Terminalnpm install -g web-push Generate the VAPID keys by running: Terminalweb-push generate-vapid-keys Copy the output and paste the keys into your .env file: NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here VAPID_PRIVATE_KEY=your_private_key_here 5. Creating a Service Worker Create a public/sw.js file for your service worker: public/sw.jsself.addEventListener('push', function (event) { if (event.data) { const data = event.data.json() const options = { body: data.body, icon: data.icon || '/icon.png', badge: '/badge.png', vibrate: [100, 50, 100], data: { dateOfArrival: Date.now(), primaryKey: '2', }, } event.waitUntil(self.registration.showNotification(data.title, options)) } }) self.addEventListener('notificationclick', function (event) { console.log('Notification click received.') event.notification.close() event.waitUntil(clients.openWindow('<https://your-website.com>')) }) This service worker supports custom images and notifications. It handles incoming push events and notification clicks. You can set custom icons for notifications using the icon and badge properties. The vibrate pattern can be adjusted to create custom vibration alerts on supported devices. Additional data can be attached to the notification using the data property. Remember to test your service worker thoroughly to ensure it behaves as expected across different devices and browsers. Also, make sure to update the 'https://your-website.com' link in the notificationclick event listener to the appropriate URL for your application. 6. Adding to Home Screen The InstallPrompt component defined in step 2 shows a message for iOS devices to instruct them to install to their home screen. To ensure your application can be installed to a mobile home screen, you must have: A valid web app manifest (created in step 1) The website served over HTTPS Modern browsers will automatically show an installation prompt to users when these criteria are met. You can provide a custom installation button with beforeinstallprompt, however, we do not recommend this as it is not cross browser and platform (does not work on Safari iOS). 7. Testing Locally To ensure you can view notifications locally, ensure that: You are running locally with HTTPS Use next dev --experimental-https for testing Your browser (Chrome, Safari, Firefox) has notifications enabled When prompted locally, accept permissions to use notifications Ensure notifications are not disabled globally for the entire browser If you are still not seeing notifications, try using another browser to debug 8. Securing your application Security is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using the next.config.js file. For example: next.config.jsmodule.exports = { async headers() { return [ { source: '/(.*)', headers: [ { key: 'X-Content-Type-Options', value: 'nosniff', }, { key: 'X-Frame-Options', value: 'DENY', }, { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin', }, ], }, { source: '/sw.js', headers: [ { key: 'Content-Type', value: 'application/javascript; charset=utf-8', }, { key: 'Cache-Control', value: 'no-cache, no-store, must-revalidate', }, { key: 'Content-Security-Policy', value: \"default-src 'self'; script-src 'self'\", }, ], }, ] }, } Let’s go over each of these options: Global Headers (applied to all routes): X-Content-Type-Options: nosniff: Prevents MIME type sniffing, reducing the risk of malicious file uploads. X-Frame-Options: DENY: Protects against clickjacking attacks by preventing your site from being embedded in iframes. Referrer-Policy: strict-origin-when-cross-origin: Controls how much referrer information is included with requests, balancing security and functionality. Service Worker Specific Headers: Content-Type: application/javascript; charset=utf-8: Ensures the service worker is interpreted correctly as JavaScript. Cache-Control: no-cache, no-store, must-revalidate: Prevents caching of the service worker, ensuring users always get the latest version. Content-Security-Policy: default-src 'self'; script-src 'self': Implements a strict Content Security Policy for the service worker, only allowing scripts from the same origin. Learn more about defining Content Security Policies with Next.js. Extending your PWA Exploring PWA Capabilities: PWAs can leverage various web APIs to provide advanced functionality. Consider exploring features like background sync, periodic background sync, or the File System Access API to enhance your application. For inspiration and up-to-date information on PWA capabilities, you can refer to resources like What PWA Can Do Today. Static Exports: If your application requires not running a server, and instead using a static export of files, you can update the Next.js configuration to enable this change. Learn more in the Next.js Static Export documentation. However, you will need to move from Server Actions to calling an external API, as well as moving your defined headers to your proxy. Offline Support: To provide offline functionality, one option is Serwist with Next.js. You can find an example of how to integrate Serwist with Next.js in their documentation. Note: this plugin currently requires webpack configuration. Security Considerations: Ensure that your service worker is properly secured. This includes using HTTPS, validating the source of push messages, and implementing proper error handling. User Experience: Consider implementing progressive enhancement techniques to ensure your app works well even when certain PWA features are not supported by the user's browser.",
      "code": "app/manifest.ts"
    },
    {
      "description": "app/actions.tsTypeScriptJavaScriptTypeScript'use server' import webpush from 'web-push' webpush.setVapidDetails( '<mailto:your-email@example.com>', process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!, process.env.VAPID_PRIVATE_KEY! ) let subscription: PushSubscription | null = null export async function subscribeUser(sub: PushSubscription) { subscription = sub // In a production environment, you would want to store the subscription in a database // For example: await db.subscriptions.create({ data: sub }) return { success: true } } export async function unsubscribeUser() { subscription = null // In a production environment, you would want to remove the subscription from the database // For example: await db.subscriptions.delete({ where: { ... } }) return { success: true } } export async function sendNotification(message: string) { if (!subscription) { throw new Error('No subscription available') } try { await webpush.sendNotification( subscription, JSON.stringify({ title: 'Test Notification', body: message, icon: '/icon.png', }) ) return { success: true } } catch (error) { console.error('Error sending push notification:', error) return { success: false, error: 'Failed to send notification' } } }",
      "code": "'use server'\n \nimport webpush from 'web-push'\n \nwebpush.setVapidDetails(\n  '<mailto:your-email@example.com>',\n  process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,\n  process.env.VAPID_PRIVATE_KEY!\n)\n \nlet subscription: PushSubscription | null = null\n \nexport async function subscribeUser(sub: PushSubscription) {\n  subscription = sub\n  // In a production environment, you would want to store the subscription in a database\n  // For example: await db.subscriptions.create({ data: sub })\n  return { success: true }\n}\n \nexport async function unsubscribeUser() {\n  subscription = null\n  // In a production environment, you would want to remove the subscription from the database\n  // For example: await db.subscriptions.delete({ where: { ... } })\n  return { success: true }\n}\n \nexport async function sendNotification(message: string) {\n  if (!subscription) {\n    throw new Error('No subscription available')\n  }\n \n  try {\n    await webpush.sendNotification(\n      subscription,\n      JSON.stringify({\n        title: 'Test Notification',\n        body: message,\n        icon: '/icon.png',\n      })\n    )\n    return { success: true }\n  } catch (error) {\n    console.error('Error sending push notification:', error)\n    return { success: false, error: 'Failed to send notification' }\n  }\n}"
    },
    {
      "description": "Security is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using the next.config.js file. For example:",
      "code": "next.config.js"
    }
  ],
  "links": [
    "https://nextjs.org/docs/app",
    "https://nextjs.org/docs/app/guides",
    "https://nextjs.org/docs/app/guides/progressive-web-apps",
    "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/manifest",
    "https://nextjs.org/docs/app/api-reference/cli/next",
    "https://nextjs.org/docs/app/guides/content-security-policy",
    "https://nextjs.org/docs/app/guides/static-exports",
    "https://nextjs.org/docs/app/guides/production-checklist",
    "https://nextjs.org/docs/app/guides/redirecting"
  ]
}