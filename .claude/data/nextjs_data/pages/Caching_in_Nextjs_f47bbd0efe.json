{
  "url": "https://nextjs.org/docs/app/guides/caching",
  "title": "Caching in Next.js",
  "content": "Next.js improves your application's performance and reduces costs by caching rendering work and data requests. This page provides an in-depth look at Next.js caching mechanisms, the APIs you can use to configure them, and how they interact with each other.\n\nGood to know: This page helps you understand how Next.js works under the hood but is not essential knowledge to be productive with Next.js. Most of Next.js' caching heuristics are determined by your API usage and have defaults for the best performance with zero or minimal configuration. If you instead want to jump to examples, start here.\n\nHere's a high-level overview of the different caching mechanisms and their purpose:\n\nBy default, Next.js will cache as much as possible to improve performance and reduce cost. This means routes are statically rendered and data requests are cached unless you opt out. The diagram below shows the default caching behavior: when a route is statically rendered at build time and when a static route is first visited.\n\nCaching behavior changes depending on whether the route is statically or dynamically rendered, data is cached or uncached, and whether a request is part of an initial visit or a subsequent navigation. Depending on your use case, you can configure the caching behavior for individual routes and data requests.\n\nFetch caching is not supported in proxy. Any fetches done inside of your proxy will be uncached.\n\nTo understand how caching works in Next.js, it's helpful to understand the rendering strategies available. The rendering strategy determines when your route's HTML is generated, which directly impacts what can be cached.\n\nWith Static Rendering, routes are rendered at build time or in the background after data revalidation. The result is cached and can be reused across requests. Static routes are fully cached in the Full Route Cache.\n\nWith Dynamic Rendering, routes are rendered at request time. This happens when your route uses request-specific information like cookies, headers, or search params.\n\nA route becomes dynamic when it uses any of these APIs:\n\nDynamic routes are not cached in the Full Route Cache, but can still use the Data Cache for data requests.\n\nGood to know: You can use Cache Components to mix static and dynamic rendering within the same route.\n\nNext.js extends the fetch API to automatically memoize requests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once.\n\nFor example, if you need to use the same data across a route (e.g. in a Layout, Page, and multiple components), you do not have to fetch data at the top of the tree, and forward props between components. Instead, you can fetch data in the components that need it without worrying about the performance implications of making multiple requests across the network for the same data.\n\nHow Request Memoization Works\n\nThe cache lasts the lifetime of a server request until the React component tree has finished rendering.\n\nSince the memoization is not shared across server requests and only applies during rendering, there is no need to revalidate it.\n\nMemoization only applies to the GET method in fetch requests, other methods, such as POST and DELETE, are not memoized. This default behavior is a React optimization and we do not recommend opting out of it.\n\nTo manage individual requests, you can use the signal property from AbortController.\n\nNext.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is possible because Next.js extends the native fetch API to allow each request on the server to set its own persistent caching semantics.\n\nGood to know: In the browser, the cache option of fetch indicates how a request will interact with the browser's HTTP cache, in Next.js, the cache option indicates how a server-side request will interact with the server's Data Cache.\n\nYou can use the cache and next.revalidate options of fetch to configure the caching behavior.\n\nIn development mode, fetch data is reused for Hot Module Replacement (HMR), and caching options are ignored for hard refreshes.\n\nHow the Data Cache Works\n\nDifferences between the Data Cache and Request Memoization\n\nWhile both caching mechanisms help improve performance by re-using cached data, the Data Cache is persistent across incoming requests and deployments, whereas memoization only lasts the lifetime of a request.\n\nThe Data Cache is persistent across incoming requests and deployments unless you revalidate or opt-out.\n\nCached data can be revalidated in two ways, with:\n\nTo revalidate data at a timed interval, you can use the next.revalidate option of fetch to set the cache lifetime of a resource (in seconds).\n\nAlternatively, you can use Route Segment Config options to configure all fetch requests in a segment or for cases where you're not able to use fetch.\n\nHow Time-based Revalidation Works\n\nThis is similar to stale-while-revalidate behavior.\n\nData can be revalidated on-demand by path (revalidatePath) or by cache tag (revalidateTag).\n\nHow On-Demand Revalidation Works\n\nIf you do not want to cache the response from fetch, you can do the following:\n\nYou may see the terms Automatic Static Optimization, Static Site Generation, or Static Rendering being used interchangeably to refer to the process of rendering and caching routes of your application at build time.\n\nNext.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads.\n\nTo understand how the Full Route Cache works, it's helpful to look at how React handles rendering, and how Next.js caches the result:\n\nOn the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual routes segments and Suspense boundaries.\n\nEach chunk is rendered in two steps:\n\nThis means we don't have to wait for everything to render before caching the work or sending a response. Instead, we can stream a response as work is completed.\n\nWhat is the React Server Component Payload?\n\nThe React Server Component Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The React Server Component Payload contains:\n\nTo learn more, see the Server Components documentation.\n\nThe default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation.\n\nAt request time, on the client:\n\nThe React Server Component Payload is stored in the client-side Router Cache - a separate in-memory cache, split by individual route segment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes.\n\nOn subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server.\n\nIf the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client.\n\nWhether a route is cached or not at build time depends on whether it's statically or dynamically rendered. Static routes are cached by default, whereas dynamic routes are rendered at request time, and not cached.\n\nThis diagram shows the difference between statically and dynamically rendered routes, with cached and uncached data:\n\nLearn more about static and dynamic rendering.\n\nBy default, the Full Route Cache is persistent. This means that the render output is cached across user requests.\n\nThere are two ways you can invalidate the Full Route Cache:\n\nYou can opt out of the Full Route Cache, or in other words, dynamically render components for every incoming request, by:\n\nNext.js has an in-memory client-side router cache that stores the RSC payload of route segments, split by layouts, loading states, and pages.\n\nWhen a user navigates between routes, Next.js caches the visited route segments and prefetches the routes the user is likely to navigate to. This results in instant back/forward navigation, no full-page reload between navigations, and preservation of browser state and React state in shared layouts.\n\nWith the Router Cache:\n\nGood to know: This cache specifically applies to Next.js and Server Components, and is different to the browser's bfcache, though it has a similar result.\n\nThe cache is stored in the browser's temporary memory. Two factors determine how long the router cache lasts:\n\nWhile a page refresh will clear all cached segments, the automatic invalidation period only affects the individual segment from the time it was prefetched.\n\nGood to know: The experimental staleTimes config option can be used to adjust the automatic invalidation times mentioned above.\n\nThere are two ways you can invalidate the Router Cache:\n\nAs of Next.js 15, page segments are opted out by default.\n\nGood to know: You can also opt out of prefetching by setting the prefetch prop of the <Link> component to false.\n\nWhen configuring the different caching mechanisms, it's important to understand how they interact with each other:\n\nThe following table provides an overview of how different Next.js APIs affect caching:\n\nBy default, the <Link> component automatically prefetches routes from the Full Route Cache and adds the React Server Component Payload to the Router Cache.\n\nTo disable prefetching, you can set the prefetch prop to false. But this will not skip the cache permanently, the route segment will still be cached client-side when the user visits the route.\n\nLearn more about the <Link> component.\n\nThe prefetch option of the useRouter hook can be used to manually prefetch a route. This adds the React Server Component Payload to the Router Cache.\n\nSee the useRouter hook API reference.\n\nThe refresh option of the useRouter hook can be used to manually refresh a route. This completely clears the Router Cache, and makes a new request to the server for the current route. refresh does not affect the Data or Full Route Cache.\n\nThe rendered result will be reconciled on the client while preserving React state and browser state.\n\nSee the useRouter hook API reference.\n\nData returned from fetch is not automatically cached in the Data Cache.\n\nBy default, when no cache or next.revalidate options are provided:\n\nSee the fetch API Reference for more options.\n\nYou can opt individual fetch into caching by setting the cache option to force-cache:\n\nSee the fetch API Reference for more options.\n\nYou can use the next.revalidate option of fetch to set the revalidation period (in seconds) of an individual fetch request. This will revalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-rendered on the server.\n\nSee the fetch API reference for more options.\n\nNext.js has a cache tagging system for fine-grained data caching and revalidation.\n\nFor example, you can set a tag when fetching data:\n\nThen, call revalidateTag with a tag to purge the cache entry:\n\nThere are two places you can use revalidateTag, depending on what you're trying to achieve:\n\nrevalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache.\n\nThere are two places you can use revalidatePath, depending on what you're trying to achieve:\n\nSee the revalidatePath API reference for more information.\n\nrevalidatePath vs. router.refresh:\n\nCalling router.refresh will clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Full Route Cache.\n\nThe difference is that revalidatePath purges the Data Cache and Full Route Cache, whereas router.refresh() does not change the Data Cache and Full Route Cache, as it is a client-side API.\n\nDynamic APIs like cookies and headers, and the searchParams prop in Pages depend on runtime incoming request information. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered.\n\nUsing cookies.set or cookies.delete in a Server Action invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. to reflect authentication changes).\n\nSee the cookies API reference.\n\nThe Route Segment Config options can be used to override the route segment defaults or when you're not able to use the fetch API (e.g. database client or 3rd party libraries).\n\nThe following Route Segment Config options will opt out of the Full Route Cache:\n\nThis config option will opt all fetches out of the Data Cache (i.e. no-store):\n\nSee the fetchCache to see more advanced options.\n\nSee the Route Segment Config documentation for more options.\n\nFor dynamic segments (e.g. app/blog/[slug]/page.js), paths provided by generateStaticParams are cached in the Full Route Cache at build time. At request time, Next.js will also cache paths that weren't known at build time the first time they're visited.\n\nTo statically render all paths at build time, supply the full list of paths to generateStaticParams:\n\nTo statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:\n\nTo statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static':\n\nGood to know: You must return an array from generateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered.\n\nTo disable caching at request time, add the export const dynamicParams = false option in a route segment. When this config option is used, only paths provided by generateStaticParams will be served, and other routes will 404 or match (in the case of catch-all routes).\n\nThe React cache function allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once.\n\nfetch requests using the GET or HEAD methods are automatically memoized, so you do not need to wrap it in React cache. However, for other fetch methods, or when using data fetching libraries (such as some database, CMS, or GraphQL clients) that don't inherently memoize requests, you can use cache to manually memoize data requests.",
  "headings": [
    {
      "level": "h1",
      "text": "Caching in Next.js",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Overview",
      "id": "overview"
    },
    {
      "level": "h2",
      "text": "Rendering Strategies",
      "id": "rendering-strategies"
    },
    {
      "level": "h3",
      "text": "Static Rendering",
      "id": "static-rendering"
    },
    {
      "level": "h3",
      "text": "Dynamic Rendering",
      "id": "dynamic-rendering"
    },
    {
      "level": "h2",
      "text": "Request Memoization",
      "id": "request-memoization"
    },
    {
      "level": "h3",
      "text": "Duration",
      "id": "duration"
    },
    {
      "level": "h3",
      "text": "Revalidating",
      "id": "revalidating"
    },
    {
      "level": "h3",
      "text": "Opting out",
      "id": "opting-out"
    },
    {
      "level": "h2",
      "text": "Data Cache",
      "id": "data-cache"
    },
    {
      "level": "h3",
      "text": "Duration",
      "id": "duration-1"
    },
    {
      "level": "h3",
      "text": "Revalidating",
      "id": "revalidating-1"
    },
    {
      "level": "h4",
      "text": "Time-based Revalidation",
      "id": "time-based-revalidation"
    },
    {
      "level": "h4",
      "text": "On-demand Revalidation",
      "id": "on-demand-revalidation"
    },
    {
      "level": "h3",
      "text": "Opting out",
      "id": "opting-out-1"
    },
    {
      "level": "h2",
      "text": "Full Route Cache",
      "id": "full-route-cache"
    },
    {
      "level": "h3",
      "text": "1. React Rendering on the Server",
      "id": "1-react-rendering-on-the-server"
    },
    {
      "level": "h3",
      "text": "2. Next.js Caching on the Server (Full Route Cache)",
      "id": "2-nextjs-caching-on-the-server-full-route-cache"
    },
    {
      "level": "h3",
      "text": "3. React Hydration and Reconciliation on the Client",
      "id": "3-react-hydration-and-reconciliation-on-the-client"
    },
    {
      "level": "h3",
      "text": "4. Next.js Caching on the Client (Router Cache)",
      "id": "4-nextjs-caching-on-the-client-router-cache"
    },
    {
      "level": "h3",
      "text": "5. Subsequent Navigations",
      "id": "5-subsequent-navigations"
    },
    {
      "level": "h3",
      "text": "Static and Dynamic Rendering",
      "id": "static-and-dynamic-rendering"
    },
    {
      "level": "h3",
      "text": "Duration",
      "id": "duration-2"
    },
    {
      "level": "h3",
      "text": "Invalidation",
      "id": "invalidation"
    },
    {
      "level": "h3",
      "text": "Opting out",
      "id": "opting-out-2"
    },
    {
      "level": "h2",
      "text": "Client-side Router Cache",
      "id": "client-side-router-cache"
    },
    {
      "level": "h3",
      "text": "Duration",
      "id": "duration-3"
    },
    {
      "level": "h3",
      "text": "Invalidation",
      "id": "invalidation-1"
    },
    {
      "level": "h3",
      "text": "Opting out",
      "id": "opting-out-3"
    },
    {
      "level": "h2",
      "text": "Cache Interactions",
      "id": "cache-interactions"
    },
    {
      "level": "h3",
      "text": "Data Cache and Full Route Cache",
      "id": "data-cache-and-full-route-cache"
    },
    {
      "level": "h3",
      "text": "Data Cache and Client-side Router cache",
      "id": "data-cache-and-client-side-router-cache"
    },
    {
      "level": "h2",
      "text": "APIs",
      "id": "apis"
    },
    {
      "level": "h3",
      "text": "<Link>",
      "id": "link"
    },
    {
      "level": "h3",
      "text": "router.prefetch",
      "id": "routerprefetch"
    },
    {
      "level": "h3",
      "text": "router.refresh",
      "id": "routerrefresh"
    },
    {
      "level": "h3",
      "text": "fetch",
      "id": "fetch"
    },
    {
      "level": "h3",
      "text": "fetch options.cache",
      "id": "fetch-optionscache"
    },
    {
      "level": "h3",
      "text": "fetch options.next.revalidate",
      "id": "fetch-optionsnextrevalidate"
    },
    {
      "level": "h3",
      "text": "fetch options.next.tags and revalidateTag",
      "id": "fetch-optionsnexttags-and-revalidatetag"
    },
    {
      "level": "h3",
      "text": "revalidatePath",
      "id": "revalidatepath"
    },
    {
      "level": "h3",
      "text": "Dynamic APIs",
      "id": "dynamic-apis"
    },
    {
      "level": "h4",
      "text": "cookies",
      "id": "cookies"
    },
    {
      "level": "h3",
      "text": "Segment Config Options",
      "id": "segment-config-options"
    },
    {
      "level": "h3",
      "text": "generateStaticParams",
      "id": "generatestaticparams"
    },
    {
      "level": "h3",
      "text": "React cache function",
      "id": "react-cache-function"
    }
  ],
  "code_samples": [
    {
      "code": "async function getItem() {\n  // The `fetch` function is automatically memoized and the result\n  // is cached\n  const res = await fetch('https://.../item/1')\n  return res.json()\n}\n \n// This function is called twice, but only executed the first time\nconst item = await getItem() // cache MISS\n \n// The second call could be anywhere in your route\nconst item = await getItem() // cache HIT",
      "language": "javascript"
    },
    {
      "code": "const { signal } = new AbortController()\nfetch(url, { signal })",
      "language": "javascript"
    },
    {
      "code": "// Revalidate at most every hour\nfetch('https://...', { next: { revalidate: 3600 } })",
      "language": "unknown"
    },
    {
      "code": "let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })",
      "language": "javascript"
    },
    {
      "code": "// Opt into caching\nfetch(`https://...`, { cache: 'force-cache' })",
      "language": "unknown"
    },
    {
      "code": "// Revalidate at most after 1 hour\nfetch(`https://...`, { next: { revalidate: 3600 } })",
      "language": "unknown"
    },
    {
      "code": "// Cache data with a tag\nfetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })",
      "language": "unknown"
    },
    {
      "code": "// Revalidate entries with a specific tag\nrevalidateTag('a')",
      "language": "unknown"
    },
    {
      "code": "revalidatePath('/')",
      "language": "unknown"
    },
    {
      "code": "export async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  return posts.map((post) => ({\n    slug: post.slug,\n  }))\n}",
      "language": "javascript"
    },
    {
      "code": "export async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  // Render the first 10 posts at build time\n  return posts.slice(0, 10).map((post) => ({\n    slug: post.slug,\n  }))\n}",
      "language": "javascript"
    },
    {
      "code": "export async function generateStaticParams() {\n  return []\n}",
      "language": "unknown"
    },
    {
      "code": "export const dynamic = 'force-static'",
      "language": "javascript"
    },
    {
      "code": "import { cache } from 'react'\nimport db from '@/lib/db'\n \nexport const getItem = cache(async (id: string) => {\n  const item = await db.item.findUnique({ id })\n  return item\n})",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://nextjs.org/docs/app",
    "https://nextjs.org/docs/app/guides",
    "https://nextjs.org/docs/app/getting-started/fetching-data",
    "https://nextjs.org/docs/app/guides/caching",
    "https://nextjs.org/docs/app/guides/incremental-static-regeneration",
    "https://nextjs.org/docs/app/api-reference/functions/cookies",
    "https://nextjs.org/docs/app/api-reference/functions/headers",
    "https://nextjs.org/docs/app/api-reference/functions/connection",
    "https://nextjs.org/docs/app/api-reference/functions/draft-mode",
    "https://nextjs.org/docs/app/api-reference/file-conventions/page",
    "https://nextjs.org/docs/app/api-reference/functions/unstable_noStore",
    "https://nextjs.org/docs/app/api-reference/functions/fetch",
    "https://nextjs.org/docs/app/getting-started/cache-components",
    "https://nextjs.org/docs/app/getting-started/server-and-client-components",
    "https://nextjs.org/docs/app/getting-started/linking-and-navigating",
    "https://nextjs.org/docs/app/api-reference/file-conventions/loading",
    "https://nextjs.org/docs/app/api-reference/config/next-config-js/staleTimes",
    "https://nextjs.org/docs/app/api-reference/components/link",
    "https://nextjs.org/docs/app/api-reference/functions/revalidatePath",
    "https://nextjs.org/docs/app/api-reference/functions/revalidateTag",
    "https://nextjs.org/docs/app/api-reference/functions/use-router",
    "https://nextjs.org/docs/app/getting-started/updating-data",
    "https://nextjs.org/docs/app/api-reference/file-conventions/route",
    "https://nextjs.org/docs/app/api-reference/functions/unstable_cache",
    "https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config",
    "https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes",
    "https://nextjs.org/docs/app/guides/backend-for-frontend",
    "https://nextjs.org/docs/app/guides/ci-build-caching"
  ]
}