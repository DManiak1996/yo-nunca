{
  "url": "https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts",
  "title": "Pages and Layouts",
  "content": "The Pages Router has a file-system based router built on the concept of pages.\n\nWhen a file is added to the pages directory, it's automatically available as a route.\n\nIn Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.\n\nExample: If you create pages/about.js that exports a React component like below, it will be accessible at /about.\n\nThe router will automatically route files named index to the root of the directory.\n\nThe router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way still.\n\nNext.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc.\n\nTo learn more about dynamic routing, check the Dynamic Routing documentation.\n\nThe React model allows us to deconstruct a page into a series of components. Many of these components are often reused between pages. For example, you might have the same navigation bar and footer on every page.\n\nIf you only have one layout for your entire application, you can create a Custom App and wrap your application with the layout. Since the <Layout /> component is re-used when changing pages, its component state will be preserved (e.g. input values).\n\nIf you need multiple layouts, you can add a property getLayout to your page, allowing you to return a React component for the layout. This allows you to define the layout on a per-page basis. Since we're returning a function, we can have complex nested layouts if desired.\n\nWhen navigating between pages, we want to persist page state (input values, scroll position, etc.) for a Single-Page Application (SPA) experience.\n\nThis layout pattern enables state persistence because the React component tree is maintained between page transitions. With the component tree, React can understand which elements have changed to preserve state.\n\nGood to know: This process is called reconciliation, which is how React understands which elements have changed.\n\nWhen using TypeScript, you must first create a new type for your pages which includes a getLayout function. Then, you must create a new type for your AppProps which overrides the Component property to use the previously created type.\n\nInside your layout, you can fetch data on the client-side using useEffect or a library like SWR. Because this file is not a Page, you cannot use getStaticProps or getServerSideProps currently.",
  "headings": [
    {
      "level": "h1",
      "text": "Pages and Layouts",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Index routes",
      "id": "index-routes"
    },
    {
      "level": "h2",
      "text": "Nested routes",
      "id": "nested-routes"
    },
    {
      "level": "h2",
      "text": "Pages with Dynamic Routes",
      "id": "pages-with-dynamic-routes"
    },
    {
      "level": "h2",
      "text": "Layout Pattern",
      "id": "layout-pattern"
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "Single Shared Layout with Custom App",
      "id": "single-shared-layout-with-custom-app"
    },
    {
      "level": "h3",
      "text": "Per-Page Layouts",
      "id": "per-page-layouts"
    },
    {
      "level": "h3",
      "text": "With TypeScript",
      "id": "with-typescript"
    },
    {
      "level": "h3",
      "text": "Data Fetching",
      "id": "data-fetching"
    }
  ],
  "code_samples": [
    {
      "code": "export default function About() {\n  return <div>About</div>\n}",
      "language": "unknown"
    },
    {
      "code": "import Navbar from './navbar'\nimport Footer from './footer'\n \nexport default function Layout({ children }) {\n  return (\n    <>\n      <Navbar />\n      <main>{children}</main>\n      <Footer />\n    </>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import Layout from '../components/layout'\n \nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <Layout>\n      <Component {...pageProps} />\n    </Layout>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import Layout from '../components/layout'\nimport NestedLayout from '../components/nested-layout'\n \nexport default function Page() {\n  return (\n    /** Your content */\n  )\n}\n \nPage.getLayout = function getLayout(page) {\n  return (\n    <Layout>\n      <NestedLayout>{page}</NestedLayout>\n    </Layout>\n  )\n}",
      "language": "python"
    },
    {
      "code": "export default function MyApp({ Component, pageProps }) {\n  // Use the layout defined at the page level, if available\n  const getLayout = Component.getLayout ?? ((page) => page)\n \n  return getLayout(<Component {...pageProps} />)\n}",
      "language": "javascript"
    },
    {
      "code": "import type { ReactElement } from 'react'\nimport Layout from '../components/layout'\nimport NestedLayout from '../components/nested-layout'\nimport type { NextPageWithLayout } from './_app'\n \nconst Page: NextPageWithLayout = () => {\n  return <p>hello world</p>\n}\n \nPage.getLayout = function getLayout(page: ReactElement) {\n  return (\n    <Layout>\n      <NestedLayout>{page}</NestedLayout>\n    </Layout>\n  )\n}\n \nexport default Page",
      "language": "python"
    },
    {
      "code": "import type { ReactElement, ReactNode } from 'react'\nimport type { NextPage } from 'next'\nimport type { AppProps } from 'next/app'\n \nexport type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & {\n  getLayout?: (page: ReactElement) => ReactNode\n}\n \ntype AppPropsWithLayout = AppProps & {\n  Component: NextPageWithLayout\n}\n \nexport default function MyApp({ Component, pageProps }: AppPropsWithLayout) {\n  // Use the layout defined at the page level, if available\n  const getLayout = Component.getLayout ?? ((page) => page)\n \n  return getLayout(<Component {...pageProps} />)\n}",
      "language": "python"
    },
    {
      "code": "import useSWR from 'swr'\nimport Navbar from './navbar'\nimport Footer from './footer'\n \nexport default function Layout({ children }) {\n  const { data, error } = useSWR('/api/navigation', fetcher)\n \n  if (error) return <div>Failed to load</div>\n  if (!data) return <div>Loading...</div>\n \n  return (\n    <>\n      <Navbar links={data.links} />\n      <main>{children}</main>\n      <Footer />\n    </>\n  )\n}",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Building Your ApplicationRoutingPages and LayoutsCopy pagePages and LayoutsThe Pages Router has a file-system based router built on the concept of pages. When a file is added to the pages directory, it's automatically available as a route. In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name. Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about. export default function About() { return <div>About</div> } Index routes The router will automatically route files named index to the root of the directory. pages/index.js → / pages/blog/index.js → /blog Nested routes The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way still. pages/blog/first-post.js → /blog/first-post pages/dashboard/settings/username.js → /dashboard/settings/username Pages with Dynamic Routes Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc. To learn more about dynamic routing, check the Dynamic Routing documentation. Layout Pattern The React model allows us to deconstruct a page into a series of components. Many of these components are often reused between pages. For example, you might have the same navigation bar and footer on every page. components/layout.jsimport Navbar from './navbar' import Footer from './footer' export default function Layout({ children }) { return ( <> <Navbar /> <main>{children}</main> <Footer /> </> ) } Examples Single Shared Layout with Custom App If you only have one layout for your entire application, you can create a Custom App and wrap your application with the layout. Since the <Layout /> component is re-used when changing pages, its component state will be preserved (e.g. input values). pages/_app.jsimport Layout from '../components/layout' export default function MyApp({ Component, pageProps }) { return ( <Layout> <Component {...pageProps} /> </Layout> ) } Per-Page Layouts If you need multiple layouts, you can add a property getLayout to your page, allowing you to return a React component for the layout. This allows you to define the layout on a per-page basis. Since we're returning a function, we can have complex nested layouts if desired. pages/index.js import Layout from '../components/layout' import NestedLayout from '../components/nested-layout' export default function Page() { return ( /** Your content */ ) } Page.getLayout = function getLayout(page) { return ( <Layout> <NestedLayout>{page}</NestedLayout> </Layout> ) } pages/_app.jsexport default function MyApp({ Component, pageProps }) { // Use the layout defined at the page level, if available const getLayout = Component.getLayout ?? ((page) => page) return getLayout(<Component {...pageProps} />) } When navigating between pages, we want to persist page state (input values, scroll position, etc.) for a Single-Page Application (SPA) experience. This layout pattern enables state persistence because the React component tree is maintained between page transitions. With the component tree, React can understand which elements have changed to preserve state. Good to know: This process is called reconciliation, which is how React understands which elements have changed. With TypeScript When using TypeScript, you must first create a new type for your pages which includes a getLayout function. Then, you must create a new type for your AppProps which overrides the Component property to use the previously created type. pages/index.tsxTypeScriptJavaScriptTypeScriptimport type { ReactElement } from 'react' import Layout from '../components/layout' import NestedLayout from '../components/nested-layout' import type { NextPageWithLayout } from './_app' const Page: NextPageWithLayout = () => { return <p>hello world</p> } Page.getLayout = function getLayout(page: ReactElement) { return ( <Layout> <NestedLayout>{page}</NestedLayout> </Layout> ) } export default Page pages/_app.tsxTypeScriptJavaScriptTypeScriptimport type { ReactElement, ReactNode } from 'react' import type { NextPage } from 'next' import type { AppProps } from 'next/app' export type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & { getLayout?: (page: ReactElement) => ReactNode } type AppPropsWithLayout = AppProps & { Component: NextPageWithLayout } export default function MyApp({ Component, pageProps }: AppPropsWithLayout) { // Use the layout defined at the page level, if available const getLayout = Component.getLayout ?? ((page) => page) return getLayout(<Component {...pageProps} />) } Data Fetching Inside your layout, you can fetch data on the client-side using useEffect or a library like SWR. Because this file is not a Page, you cannot use getStaticProps or getServerSideProps currently. components/layout.jsimport useSWR from 'swr' import Navbar from './navbar' import Footer from './footer' export default function Layout({ children }) { const { data, error } = useSWR('/api/navigation', fetcher) if (error) return <div>Failed to load</div> if (!data) return <div>Loading...</div> return ( <> <Navbar links={data.links} /> <main>{children}</main> <Footer /> </> ) }",
      "code": "pages"
    },
    {
      "description": "Pages and LayoutsThe Pages Router has a file-system based router built on the concept of pages. When a file is added to the pages directory, it's automatically available as a route. In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name. Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about. export default function About() { return <div>About</div> } Index routes The router will automatically route files named index to the root of the directory. pages/index.js → / pages/blog/index.js → /blog Nested routes The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way still. pages/blog/first-post.js → /blog/first-post pages/dashboard/settings/username.js → /dashboard/settings/username Pages with Dynamic Routes Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc. To learn more about dynamic routing, check the Dynamic Routing documentation. Layout Pattern The React model allows us to deconstruct a page into a series of components. Many of these components are often reused between pages. For example, you might have the same navigation bar and footer on every page. components/layout.jsimport Navbar from './navbar' import Footer from './footer' export default function Layout({ children }) { return ( <> <Navbar /> <main>{children}</main> <Footer /> </> ) } Examples Single Shared Layout with Custom App If you only have one layout for your entire application, you can create a Custom App and wrap your application with the layout. Since the <Layout /> component is re-used when changing pages, its component state will be preserved (e.g. input values). pages/_app.jsimport Layout from '../components/layout' export default function MyApp({ Component, pageProps }) { return ( <Layout> <Component {...pageProps} /> </Layout> ) } Per-Page Layouts If you need multiple layouts, you can add a property getLayout to your page, allowing you to return a React component for the layout. This allows you to define the layout on a per-page basis. Since we're returning a function, we can have complex nested layouts if desired. pages/index.js import Layout from '../components/layout' import NestedLayout from '../components/nested-layout' export default function Page() { return ( /** Your content */ ) } Page.getLayout = function getLayout(page) { return ( <Layout> <NestedLayout>{page}</NestedLayout> </Layout> ) } pages/_app.jsexport default function MyApp({ Component, pageProps }) { // Use the layout defined at the page level, if available const getLayout = Component.getLayout ?? ((page) => page) return getLayout(<Component {...pageProps} />) } When navigating between pages, we want to persist page state (input values, scroll position, etc.) for a Single-Page Application (SPA) experience. This layout pattern enables state persistence because the React component tree is maintained between page transitions. With the component tree, React can understand which elements have changed to preserve state. Good to know: This process is called reconciliation, which is how React understands which elements have changed. With TypeScript When using TypeScript, you must first create a new type for your pages which includes a getLayout function. Then, you must create a new type for your AppProps which overrides the Component property to use the previously created type. pages/index.tsxTypeScriptJavaScriptTypeScriptimport type { ReactElement } from 'react' import Layout from '../components/layout' import NestedLayout from '../components/nested-layout' import type { NextPageWithLayout } from './_app' const Page: NextPageWithLayout = () => { return <p>hello world</p> } Page.getLayout = function getLayout(page: ReactElement) { return ( <Layout> <NestedLayout>{page}</NestedLayout> </Layout> ) } export default Page pages/_app.tsxTypeScriptJavaScriptTypeScriptimport type { ReactElement, ReactNode } from 'react' import type { NextPage } from 'next' import type { AppProps } from 'next/app' export type NextPageWithLayout<P = {}, IP = P> = NextPage<P, IP> & { getLayout?: (page: ReactElement) => ReactNode } type AppPropsWithLayout = AppProps & { Component: NextPageWithLayout } export default function MyApp({ Component, pageProps }: AppPropsWithLayout) { // Use the layout defined at the page level, if available const getLayout = Component.getLayout ?? ((page) => page) return getLayout(<Component {...pageProps} />) } Data Fetching Inside your layout, you can fetch data on the client-side using useEffect or a library like SWR. Because this file is not a Page, you cannot use getStaticProps or getServerSideProps currently. components/layout.jsimport useSWR from 'swr' import Navbar from './navbar' import Footer from './footer' export default function Layout({ children }) { const { data, error } = useSWR('/api/navigation', fetcher) if (error) return <div>Failed to load</div> if (!data) return <div>Loading...</div> return ( <> <Navbar links={data.links} /> <main>{children}</main> <Footer /> </> ) }",
      "code": "pages"
    },
    {
      "description": "Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about.",
      "code": "pages/about.js"
    }
  ],
  "links": [
    "https://nextjs.org/docs/pages/building-your-application",
    "https://nextjs.org/docs/pages/building-your-application/routing",
    "https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts",
    "https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes",
    "https://nextjs.org/docs/pages/building-your-application/routing/custom-app"
  ]
}