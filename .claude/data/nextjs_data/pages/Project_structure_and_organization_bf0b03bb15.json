{
  "url": "https://nextjs.org/docs/app/getting-started/project-structure",
  "title": "Project structure and organization",
  "content": "This page provides an overview of all the folder and file conventions in Next.js, and recommendations for organizing your project.\n\nTop-level folders are used to organize your application's code and static assets.\n\nTop-level files are used to configure your application, manage dependencies, run proxy, integrate monitoring tools, and define environment variables.\n\nAdd page to expose a route, layout for shared UI such as header, nav, or footer, loading for skeletons, error for error boundaries, and route for APIs.\n\nFolders define URL segments. Nesting folders nests segments. Layouts at any level wrap their child segments. A route becomes public when a page or route file exists.\n\nParameterize segments with square brackets. Use [segment] for a single param, [...segment] for catch‑all, and [[...segment]] for optional catch‑all. Access values via the params prop.\n\nOrganize code without changing URLs with route groups (group), and colocate non-routable files with private folders _folder.\n\nThese features fit specific UI patterns, such as slot-based layouts or modal routing.\n\nUse @slot for named slots rendered by a parent layout. Use intercept patterns to render another route inside the current layout without changing the URL, for example, to show a details view as a modal over a list.\n\nNext.js is unopinionated about how you organize and colocate your project files. But it does provide several features to help you organize your project.\n\nThe components defined in special files are rendered in a specific hierarchy:\n\nThe components are rendered recursively in nested routes, meaning the components of a route segment will be nested inside the components of its parent segment.\n\nIn the app directory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path.\n\nHowever, even though route structure is defined through folders, a route is not publicly accessible until a page.js or route.js file is added to a route segment.\n\nAnd, even when a route is made publicly accessible, only the content returned by page.js or route.js is sent to the client.\n\nThis means that project files can be safely colocated inside route segments in the app directory without accidentally being routable.\n\nGood to know: While you can colocate your project files in app you don't have to. If you prefer, you can keep them outside the app directory.\n\nPrivate folders can be created by prefixing a folder with an underscore: _folderName\n\nThis indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the folder and all its subfolders out of routing.\n\nSince files in the app directory can be safely colocated by default, private folders are not required for colocation. However, they can be useful for:\n\nRoute groups can be created by wrapping a folder in parenthesis: (folderName)\n\nThis indicates the folder is for organizational purposes and should not be included in the route's URL path.\n\nRoute groups are useful for:\n\nNext.js supports storing application code (including app) inside an optional src folder. This separates application code from project configuration files which mostly live in the root of a project.\n\nThe following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project.\n\nGood to know: In our examples below, we're using components and lib folders as generalized placeholders, their naming has no special framework significance and your projects might use other folders like ui, utils, hooks, styles, etc.\n\nThis strategy stores all application code in shared folders in the root of your project and keeps the app directory purely for routing purposes.\n\nThis strategy stores all application code in shared folders in the root of the app directory.\n\nThis strategy stores globally shared application code in the root app directory and splits more specific application code into the route segments that use them.\n\nTo organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted from the URL (e.g. (marketing) or (shop)).\n\nEven though routes inside (marketing) and (shop) share the same URL hierarchy, you can create a different layout for each group by adding a layout.js file inside their folders.\n\nTo opt specific routes into a layout, create a new route group (e.g. (shop)) and move the routes that share the same layout into the group (e.g. account and cart). The routes outside of the group will not share the layout (e.g. checkout).\n\nTo apply a loading skeleton via a loading.js file to a specific route, create a new route group (e.g., /(overview)) and then move your loading.tsx inside that route group.\n\nNow, the loading.tsx file will only apply to your dashboard → overview page instead of all your dashboard pages without affecting the URL path structure.\n\nTo create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route group. This is useful for partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be added to each root layout.\n\nIn the example above, both (marketing) and (shop) have their own root layout.",
  "headings": [
    {
      "level": "h1",
      "text": "Project structure and organization",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Folder and file conventions",
      "id": "folder-and-file-conventions"
    },
    {
      "level": "h3",
      "text": "Top-level folders",
      "id": "top-level-folders"
    },
    {
      "level": "h3",
      "text": "Top-level files",
      "id": "top-level-files"
    },
    {
      "level": "h3",
      "text": "Routing Files",
      "id": "routing-files"
    },
    {
      "level": "h3",
      "text": "Nested routes",
      "id": "nested-routes"
    },
    {
      "level": "h3",
      "text": "Dynamic routes",
      "id": "dynamic-routes"
    },
    {
      "level": "h3",
      "text": "Route groups and private folders",
      "id": "route-groups-and-private-folders"
    },
    {
      "level": "h3",
      "text": "Parallel and Intercepted Routes",
      "id": "parallel-and-intercepted-routes"
    },
    {
      "level": "h3",
      "text": "Metadata file conventions",
      "id": "metadata-file-conventions"
    },
    {
      "level": "h4",
      "text": "App icons",
      "id": "app-icons"
    },
    {
      "level": "h4",
      "text": "Open Graph and Twitter images",
      "id": "open-graph-and-twitter-images"
    },
    {
      "level": "h4",
      "text": "SEO",
      "id": "seo"
    },
    {
      "level": "h2",
      "text": "Organizing your project",
      "id": "organizing-your-project"
    },
    {
      "level": "h3",
      "text": "Component hierarchy",
      "id": "component-hierarchy"
    },
    {
      "level": "h3",
      "text": "Colocation",
      "id": "colocation"
    },
    {
      "level": "h3",
      "text": "Private folders",
      "id": "private-folders"
    },
    {
      "level": "h3",
      "text": "Route groups",
      "id": "route-groups"
    },
    {
      "level": "h3",
      "text": "src folder",
      "id": "src-folder"
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "Store project files outside of app",
      "id": "store-project-files-outside-of-app"
    },
    {
      "level": "h3",
      "text": "Store project files in top-level folders inside of app",
      "id": "store-project-files-in-top-level-folders-inside-of-app"
    },
    {
      "level": "h3",
      "text": "Split project files by feature or route",
      "id": "split-project-files-by-feature-or-route"
    },
    {
      "level": "h3",
      "text": "Organize routes without affecting the URL path",
      "id": "organize-routes-without-affecting-the-url-path"
    },
    {
      "level": "h3",
      "text": "Opting specific segments into a layout",
      "id": "opting-specific-segments-into-a-layout"
    },
    {
      "level": "h3",
      "text": "Opting for loading skeletons on a specific route",
      "id": "opting-for-loading-skeletons-on-a-specific-route"
    },
    {
      "level": "h3",
      "text": "Creating multiple root layouts",
      "id": "creating-multiple-root-layouts"
    }
  ],
  "code_samples": [],
  "patterns": [
    {
      "description": "App RouterGetting StartedProject StructureCopy pageProject structure and organizationThis page provides an overview of all the folder and file conventions in Next.js, and recommendations for organizing your project. Folder and file conventions Top-level folders Top-level folders are used to organize your application's code and static assets. appApp RouterpagesPages RouterpublicStatic assets to be servedsrcOptional application source folder Top-level files Top-level files are used to configure your application, manage dependencies, run proxy, integrate monitoring tools, and define environment variables. Next.jsnext.config.jsConfiguration file for Next.jspackage.jsonProject dependencies and scriptsinstrumentation.tsOpenTelemetry and Instrumentation fileproxy.tsNext.js request proxy.envEnvironment variables.env.localLocal environment variables.env.productionProduction environment variables.env.developmentDevelopment environment variableseslint.config.mjsConfiguration file for ESLint.gitignoreGit files and folders to ignorenext-env.d.tsTypeScript declaration file for Next.jstsconfig.jsonConfiguration file for TypeScriptjsconfig.jsonConfiguration file for JavaScript Routing Files Add page to expose a route, layout for shared UI such as header, nav, or footer, loading for skeletons, error for error boundaries, and route for APIs.layout.js .jsx .tsxLayoutpage.js .jsx .tsxPageloading.js .jsx .tsxLoading UInot-found.js .jsx .tsxNot found UIerror.js .jsx .tsxError UIglobal-error.js .jsx .tsxGlobal error UIroute.js .tsAPI endpointtemplate.js .jsx .tsxRe-rendered layoutdefault.js .jsx .tsxParallel route fallback pageNested routes Folders define URL segments. Nesting folders nests segments. Layouts at any level wrap their child segments. A route becomes public when a page or route file exists.PathURL patternNotesapp/layout.tsx—Root layout wraps all routesapp/blog/layout.tsx—Wraps /blog and descendantsapp/page.tsx/Public routeapp/blog/page.tsx/blogPublic routeapp/blog/authors/page.tsx/blog/authorsPublic routeDynamic routes Parameterize segments with square brackets. Use [segment] for a single param, [...segment] for catch‑all, and [[...segment]] for optional catch‑all. Access values via the params prop.PathURL patternapp/blog/[slug]/page.tsx/blog/my-first-postapp/shop/[...slug]/page.tsx/shop/clothing, /shop/clothing/shirtsapp/docs/[[...slug]]/page.tsx/docs, /docs/layouts-and-pages, /docs/api-reference/use-routerRoute groups and private folders Organize code without changing URLs with route groups (group), and colocate non-routable files with private folders _folder.PathURL patternNotesapp/(marketing)/page.tsx/Group omitted from URLapp/(shop)/cart/page.tsx/cartShare layouts within (shop)app/blog/_components/Post.tsx—Not routable; safe place for UI utilitiesapp/blog/_lib/data.ts—Not routable; safe place for utilsParallel and Intercepted Routes These features fit specific UI patterns, such as slot-based layouts or modal routing.Use @slot for named slots rendered by a parent layout. Use intercept patterns to render another route inside the current layout without changing the URL, for example, to show a details view as a modal over a list.Pattern (docs)MeaningTypical use case@folderNamed slotSidebar + main content(.)folderIntercept same levelPreview sibling route in a modal(..)folderIntercept parentOpen a child of the parent as an overlay(..)(..)folderIntercept two levelsDeeply nested overlay(...)folderIntercept from rootShow arbitrary route in current viewMetadata file conventions App icons favicon.icoFavicon fileicon.ico .jpg .jpeg .png .svgApp Icon fileicon.js .ts .tsxGenerated App Iconapple-icon.jpg .jpeg, .pngApple App Icon fileapple-icon.js .ts .tsxGenerated Apple App IconOpen Graph and Twitter images opengraph-image.jpg .jpeg .png .gifOpen Graph image fileopengraph-image.js .ts .tsxGenerated Open Graph imagetwitter-image.jpg .jpeg .png .gifTwitter image filetwitter-image.js .ts .tsxGenerated Twitter imageSEO sitemap.xmlSitemap filesitemap.js .tsGenerated Sitemaprobots.txtRobots filerobots.js .tsGenerated Robots file Organizing your project Next.js is unopinionated about how you organize and colocate your project files. But it does provide several features to help you organize your project.Component hierarchy The components defined in special files are rendered in a specific hierarchy: layout.js template.js error.js (React error boundary) loading.js (React suspense boundary) not-found.js (React error boundary for \"not found\" UI) page.js or nested layout.js The components are rendered recursively in nested routes, meaning the components of a route segment will be nested inside the components of its parent segment.Colocation In the app directory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path.However, even though route structure is defined through folders, a route is not publicly accessible until a page.js or route.js file is added to a route segment.And, even when a route is made publicly accessible, only the content returned by page.js or route.js is sent to the client.This means that project files can be safely colocated inside route segments in the app directory without accidentally being routable. Good to know: While you can colocate your project files in app you don't have to. If you prefer, you can keep them outside the app directory. Private folders Private folders can be created by prefixing a folder with an underscore: _folderNameThis indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the folder and all its subfolders out of routing.Since files in the app directory can be safely colocated by default, private folders are not required for colocation. However, they can be useful for: Separating UI logic from routing logic. Consistently organizing internal files across a project and the Next.js ecosystem. Sorting and grouping files in code editors. Avoiding potential naming conflicts with future Next.js file conventions. Good to know: While not a framework convention, you might also consider marking files outside private folders as \"private\" using the same underscore pattern. You can create URL segments that start with an underscore by prefixing the folder name with %5F (the URL-encoded form of an underscore): %5FfolderName. If you don't use private folders, it would be helpful to know Next.js special file conventions to prevent unexpected naming conflicts. Route groups Route groups can be created by wrapping a folder in parenthesis: (folderName)This indicates the folder is for organizational purposes and should not be included in the route's URL path.Route groups are useful for: Organizing routes by site section, intent, or team. e.g. marketing pages, admin pages, etc. Enabling nested layouts in the same route segment level: Creating multiple nested layouts in the same segment, including multiple root layouts Adding a layout to a subset of routes in a common segment src folder Next.js supports storing application code (including app) inside an optional src folder. This separates application code from project configuration files which mostly live in the root of a project.Examples The following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project. Good to know: In our examples below, we're using components and lib folders as generalized placeholders, their naming has no special framework significance and your projects might use other folders like ui, utils, hooks, styles, etc. Store project files outside of app This strategy stores all application code in shared folders in the root of your project and keeps the app directory purely for routing purposes.Store project files in top-level folders inside of app This strategy stores all application code in shared folders in the root of the app directory.Split project files by feature or route This strategy stores globally shared application code in the root app directory and splits more specific application code into the route segments that use them.Organize routes without affecting the URL path To organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted from the URL (e.g. (marketing) or (shop)).Even though routes inside (marketing) and (shop) share the same URL hierarchy, you can create a different layout for each group by adding a layout.js file inside their folders.Opting specific segments into a layout To opt specific routes into a layout, create a new route group (e.g. (shop)) and move the routes that share the same layout into the group (e.g. account and cart). The routes outside of the group will not share the layout (e.g. checkout).Opting for loading skeletons on a specific route To apply a loading skeleton via a loading.js file to a specific route, create a new route group (e.g., /(overview)) and then move your loading.tsx inside that route group.Now, the loading.tsx file will only apply to your dashboard → overview page instead of all your dashboard pages without affecting the URL path structure.Creating multiple root layouts To create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route group. This is useful for partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be added to each root layout.In the example above, both (marketing) and (shop) have their own root layout.",
      "code": "app"
    },
    {
      "description": "Project structure and organizationThis page provides an overview of all the folder and file conventions in Next.js, and recommendations for organizing your project. Folder and file conventions Top-level folders Top-level folders are used to organize your application's code and static assets. appApp RouterpagesPages RouterpublicStatic assets to be servedsrcOptional application source folder Top-level files Top-level files are used to configure your application, manage dependencies, run proxy, integrate monitoring tools, and define environment variables. Next.jsnext.config.jsConfiguration file for Next.jspackage.jsonProject dependencies and scriptsinstrumentation.tsOpenTelemetry and Instrumentation fileproxy.tsNext.js request proxy.envEnvironment variables.env.localLocal environment variables.env.productionProduction environment variables.env.developmentDevelopment environment variableseslint.config.mjsConfiguration file for ESLint.gitignoreGit files and folders to ignorenext-env.d.tsTypeScript declaration file for Next.jstsconfig.jsonConfiguration file for TypeScriptjsconfig.jsonConfiguration file for JavaScript Routing Files Add page to expose a route, layout for shared UI such as header, nav, or footer, loading for skeletons, error for error boundaries, and route for APIs.layout.js .jsx .tsxLayoutpage.js .jsx .tsxPageloading.js .jsx .tsxLoading UInot-found.js .jsx .tsxNot found UIerror.js .jsx .tsxError UIglobal-error.js .jsx .tsxGlobal error UIroute.js .tsAPI endpointtemplate.js .jsx .tsxRe-rendered layoutdefault.js .jsx .tsxParallel route fallback pageNested routes Folders define URL segments. Nesting folders nests segments. Layouts at any level wrap their child segments. A route becomes public when a page or route file exists.PathURL patternNotesapp/layout.tsx—Root layout wraps all routesapp/blog/layout.tsx—Wraps /blog and descendantsapp/page.tsx/Public routeapp/blog/page.tsx/blogPublic routeapp/blog/authors/page.tsx/blog/authorsPublic routeDynamic routes Parameterize segments with square brackets. Use [segment] for a single param, [...segment] for catch‑all, and [[...segment]] for optional catch‑all. Access values via the params prop.PathURL patternapp/blog/[slug]/page.tsx/blog/my-first-postapp/shop/[...slug]/page.tsx/shop/clothing, /shop/clothing/shirtsapp/docs/[[...slug]]/page.tsx/docs, /docs/layouts-and-pages, /docs/api-reference/use-routerRoute groups and private folders Organize code without changing URLs with route groups (group), and colocate non-routable files with private folders _folder.PathURL patternNotesapp/(marketing)/page.tsx/Group omitted from URLapp/(shop)/cart/page.tsx/cartShare layouts within (shop)app/blog/_components/Post.tsx—Not routable; safe place for UI utilitiesapp/blog/_lib/data.ts—Not routable; safe place for utilsParallel and Intercepted Routes These features fit specific UI patterns, such as slot-based layouts or modal routing.Use @slot for named slots rendered by a parent layout. Use intercept patterns to render another route inside the current layout without changing the URL, for example, to show a details view as a modal over a list.Pattern (docs)MeaningTypical use case@folderNamed slotSidebar + main content(.)folderIntercept same levelPreview sibling route in a modal(..)folderIntercept parentOpen a child of the parent as an overlay(..)(..)folderIntercept two levelsDeeply nested overlay(...)folderIntercept from rootShow arbitrary route in current viewMetadata file conventions App icons favicon.icoFavicon fileicon.ico .jpg .jpeg .png .svgApp Icon fileicon.js .ts .tsxGenerated App Iconapple-icon.jpg .jpeg, .pngApple App Icon fileapple-icon.js .ts .tsxGenerated Apple App IconOpen Graph and Twitter images opengraph-image.jpg .jpeg .png .gifOpen Graph image fileopengraph-image.js .ts .tsxGenerated Open Graph imagetwitter-image.jpg .jpeg .png .gifTwitter image filetwitter-image.js .ts .tsxGenerated Twitter imageSEO sitemap.xmlSitemap filesitemap.js .tsGenerated Sitemaprobots.txtRobots filerobots.js .tsGenerated Robots file Organizing your project Next.js is unopinionated about how you organize and colocate your project files. But it does provide several features to help you organize your project.Component hierarchy The components defined in special files are rendered in a specific hierarchy: layout.js template.js error.js (React error boundary) loading.js (React suspense boundary) not-found.js (React error boundary for \"not found\" UI) page.js or nested layout.js The components are rendered recursively in nested routes, meaning the components of a route segment will be nested inside the components of its parent segment.Colocation In the app directory, nested folders define route structure. Each folder represents a route segment that is mapped to a corresponding segment in a URL path.However, even though route structure is defined through folders, a route is not publicly accessible until a page.js or route.js file is added to a route segment.And, even when a route is made publicly accessible, only the content returned by page.js or route.js is sent to the client.This means that project files can be safely colocated inside route segments in the app directory without accidentally being routable. Good to know: While you can colocate your project files in app you don't have to. If you prefer, you can keep them outside the app directory. Private folders Private folders can be created by prefixing a folder with an underscore: _folderNameThis indicates the folder is a private implementation detail and should not be considered by the routing system, thereby opting the folder and all its subfolders out of routing.Since files in the app directory can be safely colocated by default, private folders are not required for colocation. However, they can be useful for: Separating UI logic from routing logic. Consistently organizing internal files across a project and the Next.js ecosystem. Sorting and grouping files in code editors. Avoiding potential naming conflicts with future Next.js file conventions. Good to know: While not a framework convention, you might also consider marking files outside private folders as \"private\" using the same underscore pattern. You can create URL segments that start with an underscore by prefixing the folder name with %5F (the URL-encoded form of an underscore): %5FfolderName. If you don't use private folders, it would be helpful to know Next.js special file conventions to prevent unexpected naming conflicts. Route groups Route groups can be created by wrapping a folder in parenthesis: (folderName)This indicates the folder is for organizational purposes and should not be included in the route's URL path.Route groups are useful for: Organizing routes by site section, intent, or team. e.g. marketing pages, admin pages, etc. Enabling nested layouts in the same route segment level: Creating multiple nested layouts in the same segment, including multiple root layouts Adding a layout to a subset of routes in a common segment src folder Next.js supports storing application code (including app) inside an optional src folder. This separates application code from project configuration files which mostly live in the root of a project.Examples The following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works for you and your team and be consistent across the project. Good to know: In our examples below, we're using components and lib folders as generalized placeholders, their naming has no special framework significance and your projects might use other folders like ui, utils, hooks, styles, etc. Store project files outside of app This strategy stores all application code in shared folders in the root of your project and keeps the app directory purely for routing purposes.Store project files in top-level folders inside of app This strategy stores all application code in shared folders in the root of the app directory.Split project files by feature or route This strategy stores globally shared application code in the root app directory and splits more specific application code into the route segments that use them.Organize routes without affecting the URL path To organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted from the URL (e.g. (marketing) or (shop)).Even though routes inside (marketing) and (shop) share the same URL hierarchy, you can create a different layout for each group by adding a layout.js file inside their folders.Opting specific segments into a layout To opt specific routes into a layout, create a new route group (e.g. (shop)) and move the routes that share the same layout into the group (e.g. account and cart). The routes outside of the group will not share the layout (e.g. checkout).Opting for loading skeletons on a specific route To apply a loading skeleton via a loading.js file to a specific route, create a new route group (e.g., /(overview)) and then move your loading.tsx inside that route group.Now, the loading.tsx file will only apply to your dashboard → overview page instead of all your dashboard pages without affecting the URL path structure.Creating multiple root layouts To create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route group. This is useful for partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be added to each root layout.In the example above, both (marketing) and (shop) have their own root layout.",
      "code": "app"
    },
    {
      "description": "Pattern (docs)MeaningTypical use case@folderNamed slotSidebar + main content(.)folderIntercept same levelPreview sibling route in a modal(..)folderIntercept parentOpen a child of the parent as an overlay(..)(..)folderIntercept two levelsDeeply nested overlay(...)folderIntercept from rootShow arbitrary route in current view",
      "code": "@folder"
    }
  ],
  "links": [
    "https://nextjs.org/docs/app",
    "https://nextjs.org/docs/app/getting-started",
    "https://nextjs.org/docs/app/getting-started/project-structure",
    "https://nextjs.org/docs/pages/building-your-application/routing",
    "https://nextjs.org/docs/app/api-reference/file-conventions/public-folder",
    "https://nextjs.org/docs/app/api-reference/file-conventions/src-folder",
    "https://nextjs.org/docs/app/api-reference/config/next-config-js",
    "https://nextjs.org/docs/app/getting-started/installation",
    "https://nextjs.org/docs/app/guides/instrumentation",
    "https://nextjs.org/docs/app/api-reference/file-conventions/proxy",
    "https://nextjs.org/docs/app/guides/environment-variables",
    "https://nextjs.org/docs/app/api-reference/config/eslint",
    "https://nextjs.org/docs/app/api-reference/file-conventions/layout",
    "https://nextjs.org/docs/app/api-reference/file-conventions/page",
    "https://nextjs.org/docs/app/api-reference/file-conventions/loading",
    "https://nextjs.org/docs/app/api-reference/file-conventions/not-found",
    "https://nextjs.org/docs/app/api-reference/file-conventions/error",
    "https://nextjs.org/docs/app/api-reference/file-conventions/route",
    "https://nextjs.org/docs/app/api-reference/file-conventions/template",
    "https://nextjs.org/docs/app/api-reference/file-conventions/default",
    "https://nextjs.org/docs/app/api-reference/file-conventions/route-groups",
    "https://nextjs.org/docs/app/api-reference/file-conventions/parallel-routes",
    "https://nextjs.org/docs/app/api-reference/file-conventions/intercepting-routes",
    "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons",
    "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image",
    "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap",
    "https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots",
    "https://nextjs.org/docs/app/getting-started/layouts-and-pages"
  ]
}