{
  "url": "https://nextjs.org/docs/pages/api-reference/config/typescript",
  "title": "TypeScript",
  "content": "Next.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app.\n\nTo add TypeScript to an existing project, rename a file to .ts / .tsx. Run next dev and next build to automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options.\n\nGood to know: If you already have a jsconfig.json file, copy the paths compiler option from the old jsconfig.json into the new tsconfig.json file, and delete the old jsconfig.json file.\n\nYou can use TypeScript and import types in your Next.js configuration by using next.config.ts.\n\nModule resolution in next.config.ts is currently limited to CommonJS. However, ECMAScript Modules (ESM) syntax is available when using Node.js native TypeScript resolver for Node.js v22.10.0 and higher.\n\nWhen using the next.config.js file, you can add some type checking in your IDE using JSDoc as below:\n\nNote: Available on Node.js v22.10.0+ and only when the feature is enabled. Next.js does not enable it.\n\nNext.js detects the Node.js native TypeScript resolver via process.features.typescript, added in v22.10.0. When present, next.config.ts can use native ESM, including top‑level await and dynamic import(). This mechanism inherits the capabilities and limitations of Node's resolver.\n\nIn Node.js versions v22.18.0+, process.features.typescript is enabled by default. For versions between v22.10.0 and 22.17.x, opt in with NODE_OPTIONS=--experimental-transform-types:\n\nAlthough next.config.ts supports native ESM syntax on CommonJS projects, Node.js will still assume next.config.ts is a CommonJS file by default, resulting in Node.js reparsing the file as ESM when module syntax is detected. Therefore, we recommend using the next.config.mts file for CommonJS projects to explicitly indicate it's an ESM module:\n\nWhen \"type\" is set to \"module\" in package.json, your project uses ESM. Learn more about this setting in the Node.js docs. In this case, you can write next.config.ts directly with ESM syntax.\n\nGood to know: When using \"type\": \"module\" in your package.json, all .js and .ts files in your project are treated as ESM modules by default. You may need to rename files with CommonJS syntax to .cjs or .cts extensions if needed.\n\nNext.js can statically type links to prevent typos and other errors when using next/link, improving type safety when navigating between pages.\n\nWorks in both the Pages and App Router for the href prop in next/link. In the App Router, it also types next/navigation methods like push, replace, and prefetch. It does not type next/router methods in Pages Router.\n\nLiteral href strings are validated, while non-literal hrefs may require a cast with as Route.\n\nTo opt-into this feature, typedRoutes need to be enabled and the project needs to be using TypeScript.\n\nNext.js will generate a link definition in .next/types that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links.\n\nGood to know: If you set up your project without create-next-app, ensure the generated Next.js types are included by adding .next/types/**/*.ts to the include array in your tsconfig.json:\n\nCurrently, support includes any string literal, including dynamic segments. For non-literal strings, you need to manually cast with as Route. The example below shows both next/link and next/navigation usage:\n\nThe same applies for redirecting routes defined by proxy:\n\nTo accept href in a custom component wrapping next/link, use a generic:\n\nYou can also type a simple data structure and iterate to render links:\n\nThen, map over the items to render Links:\n\nWhen running next dev or next build, Next.js generates a hidden .d.ts file inside .next that contains information about all existing routes in your application (all valid routes as the href type of Link). This .d.ts file is included in tsconfig.json and the TypeScript compiler will check that .d.ts and provide feedback in your editor about invalid links.\n\nDuring development, Next.js generates a .d.ts file in .next/types that contains information about the loaded environment variables for your editor's IntelliSense. If the same environment variable key is defined in multiple files, it is deduplicated according to the Environment Variable Load Order.\n\nTo opt-into this feature, experimental.typedEnv needs to be enabled and the project needs to be using TypeScript.\n\nGood to know: Types are generated based on the environment variables loaded at development runtime, which excludes variables from .env.production* files by default. To include production-specific variables, run next dev with NODE_ENV=production.\n\nFor getStaticProps, getStaticPaths, and getServerSideProps, you can use the GetStaticProps, GetStaticPaths, and GetServerSideProps types respectively:\n\nGood to know: satisfies was added to TypeScript in 4.9. We recommend upgrading to the latest version of TypeScript.\n\nThe following is an example of how to use the built-in types for API routes:\n\nYou can also type the response data:\n\nIf you have a custom App, you can use the built-in type AppProps and change file name to ./pages/_app.tsx like so:\n\nSince v10.2.1 Next.js supports incremental type checking when enabled in your tsconfig.json, this can help speed up type checking in larger applications.\n\nIn some cases, you might want to use a different TypeScript configuration for builds or tooling. To do that, set typescript.tsconfigPath in next.config.ts to point Next.js to another tsconfig file.\n\nFor example, switch to a different config for production builds:\n\nYou might need to relax checks in scenarios like monorepos, where the build also validates shared dependencies that don't match your project's standards, or when loosening checks in CI to continue delivering while migrating locally to stricter TypeScript settings (and still wanting your IDE to highlight misuse).\n\nFor example, if your project uses useUnknownInCatchVariables but some monorepo dependencies still assume any:\n\nThis keeps your editor strict via tsconfig.json while allowing the production build to use relaxed settings.\n\nNext.js fails your production build (next build) when TypeScript errors are present in your project.\n\nIf you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.\n\nIf disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.\n\nOpen next.config.ts and enable the ignoreBuildErrors option in the typescript config:\n\nGood to know: You can run tsc --noEmit to check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying.\n\nWhen you need to declare custom types, you might be tempted to modify next-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call it new-types.d.ts, and reference it in your tsconfig.json:",
  "headings": [
    {
      "level": "h1",
      "text": "TypeScript",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "Type Checking Next.js Configuration Files",
      "id": "type-checking-nextjs-configuration-files"
    },
    {
      "level": "h3",
      "text": "Using Node.js Native TypeScript Resolver for next.config.ts",
      "id": "using-nodejs-native-typescript-resolver-for-nextconfigts"
    },
    {
      "level": "h4",
      "text": "For CommonJS Projects (Default)",
      "id": "for-commonjs-projects-default"
    },
    {
      "level": "h4",
      "text": "For ESM Projects",
      "id": "for-esm-projects"
    },
    {
      "level": "h3",
      "text": "Statically Typed Links",
      "id": "statically-typed-links"
    },
    {
      "level": "h3",
      "text": "Type IntelliSense for Environment Variables",
      "id": "type-intellisense-for-environment-variables"
    },
    {
      "level": "h3",
      "text": "Static Generation and Server-side Rendering",
      "id": "static-generation-and-server-side-rendering"
    },
    {
      "level": "h3",
      "text": "With API Routes",
      "id": "with-api-routes"
    },
    {
      "level": "h3",
      "text": "With custom App",
      "id": "with-custom-app"
    },
    {
      "level": "h3",
      "text": "Incremental type checking",
      "id": "incremental-type-checking"
    },
    {
      "level": "h3",
      "text": "Custom tsconfig path",
      "id": "custom-tsconfig-path"
    },
    {
      "level": "h3",
      "text": "Disabling TypeScript errors in production",
      "id": "disabling-typescript-errors-in-production"
    },
    {
      "level": "h3",
      "text": "Custom type declarations",
      "id": "custom-type-declarations"
    },
    {
      "level": "h2",
      "text": "Version Changes",
      "id": "version-changes"
    }
  ],
  "code_samples": [
    {
      "code": "import type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  /* config options here */\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "// @ts-check\n \n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  /* config options here */\n}\n \nmodule.exports = nextConfig",
      "language": "javascript"
    },
    {
      "code": "NODE_OPTIONS=--experimental-transform-types next <command>",
      "language": "unknown"
    },
    {
      "code": "import type { NextConfig } from 'next'\n \n// Top-level await and dynamic import are supported\nconst flags = await import('./flags.js').then((m) => m.default ?? m)\n \nconst nextConfig: NextConfig = {\n  /* config options here */\n  typedRoutes: Boolean(flags?.typedRoutes),\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "import type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  typedRoutes: true,\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "{\n  \"include\": [\n    \"next-env.d.ts\",\n    \".next/types/**/*.ts\",\n    \"**/*.ts\",\n    \"**/*.tsx\"\n  ],\n  \"exclude\": [\"node_modules\"]\n}",
      "language": "unknown"
    },
    {
      "code": "'use client'\n \nimport type { Route } from 'next'\nimport Link from 'next/link'\nimport { useRouter } from 'next/navigation'\n \nexport default function Example() {\n  const router = useRouter()\n  const slug = 'nextjs'\n \n  return (\n    <>\n      {/* Link: literal and dynamic */}\n      <Link href=\"/about\" />\n      <Link href={`/blog/${slug}`} />\n      <Link href={('/blog/' + slug) as Route} />\n      {/* TypeScript error if href is not a valid route */}\n      <Link href=\"/aboot\" />\n \n      {/* Router: literal and dynamic strings are validated */}\n      <button onClick={() => router.push('/about')}>Push About</button>\n      <button onClick={() => router.replace(`/blog/${slug}`)}>\n        Replace Blog\n      </button>\n      <button onClick={() => router.prefetch('/contact')}>\n        Prefetch Contact\n      </button>\n \n      {/* For non-literal strings, cast to Route */}\n      <button onClick={() => router.push(('/blog/' + slug) as Route)}>\n        Push Non-literal Blog\n      </button>\n    </>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import { NextRequest, NextResponse } from 'next/server'\n \nexport function proxy(request: NextRequest) {\n  if (request.nextUrl.pathname === '/proxy-redirect') {\n    return NextResponse.redirect(new URL('/', request.url))\n  }\n \n  return NextResponse.next()\n}",
      "language": "python"
    },
    {
      "code": "import type { Route } from 'next'\n \nexport default function Page() {\n  return <Link href={'/proxy-redirect' as Route}>Link Text</Link>\n}",
      "language": "python"
    },
    {
      "code": "import type { Route } from 'next'\nimport Link from 'next/link'\n \nfunction Card<T extends string>({ href }: { href: Route<T> | URL }) {\n  return (\n    <Link href={href}>\n      <div>My Card</div>\n    </Link>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import type { Route } from 'next'\n \ntype NavItem<T extends string = string> = {\n  href: T\n  label: string\n}\n \nexport const navItems: NavItem<Route>[] = [\n  { href: '/', label: 'Home' },\n  { href: '/about', label: 'About' },\n  { href: '/blog', label: 'Blog' },\n]",
      "language": "python"
    },
    {
      "code": "import Link from 'next/link'\nimport { navItems } from './nav-items'\n \nexport function Nav() {\n  return (\n    <nav>\n      {navItems.map((item) => (\n        <Link key={item.href} href={item.href}>\n          {item.label}\n        </Link>\n      ))}\n    </nav>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  experimental: {\n    typedEnv: true,\n  },\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "import type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'\n \nexport const getStaticProps = (async (context) => {\n  // ...\n}) satisfies GetStaticProps\n \nexport const getStaticPaths = (async () => {\n  // ...\n}) satisfies GetStaticPaths\n \nexport const getServerSideProps = (async (context) => {\n  // ...\n}) satisfies GetServerSideProps",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  res.status(200).json({ name: 'John Doe' })\n}",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\n \ntype Data = {\n  name: string\n}\n \nexport default function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<Data>\n) {\n  res.status(200).json({ name: 'John Doe' })\n}",
      "language": "python"
    },
    {
      "code": "import type { AppProps } from 'next/app'\n \nexport default function MyApp({ Component, pageProps }: AppProps) {\n  return <Component {...pageProps} />\n}",
      "language": "python"
    },
    {
      "code": "import type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  typescript: {\n    tsconfigPath: 'tsconfig.build.json',\n  },\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "import type { NextConfig } from 'next'\n \nconst isProd = process.env.NODE_ENV === 'production'\n \nconst nextConfig: NextConfig = {\n  typescript: {\n    tsconfigPath: isProd ? 'tsconfig.build.json' : 'tsconfig.json',\n  },\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"useUnknownInCatchVariables\": false\n  }\n}",
      "language": "unknown"
    },
    {
      "code": "import type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  typescript: {\n    // !! WARN !!\n    // Dangerously allow production builds to successfully complete even if\n    // your project has type errors.\n    // !! WARN !!\n    ignoreBuildErrors: true,\n  },\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "{\n  \"compilerOptions\": {\n    \"skipLibCheck\": true\n    //...truncated...\n  },\n  \"include\": [\n    \"new-types.d.ts\",\n    \"next-env.d.ts\",\n    \".next/types/**/*.ts\",\n    \"**/*.ts\",\n    \"**/*.tsx\"\n  ],\n  \"exclude\": [\"node_modules\"]\n}",
      "language": "unknown"
    }
  ],
  "patterns": [
    {
      "description": "API ReferenceConfigurationTypeScriptCopy pageTypeScript Next.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app. To add TypeScript to an existing project, rename a file to .ts / .tsx. Run next dev and next build to automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options. Good to know: If you already have a jsconfig.json file, copy the paths compiler option from the old jsconfig.json into the new tsconfig.json file, and delete the old jsconfig.json file. Examples Type Checking Next.js Configuration Files You can use TypeScript and import types in your Next.js configuration by using next.config.ts. next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { /* config options here */ } export default nextConfig Module resolution in next.config.ts is currently limited to CommonJS. However, ECMAScript Modules (ESM) syntax is available when using Node.js native TypeScript resolver for Node.js v22.10.0 and higher. When using the next.config.js file, you can add some type checking in your IDE using JSDoc as below: next.config.js// @ts-check /** @type {import('next').NextConfig} */ const nextConfig = { /* config options here */ } module.exports = nextConfig Using Node.js Native TypeScript Resolver for next.config.ts Note: Available on Node.js v22.10.0+ and only when the feature is enabled. Next.js does not enable it. Next.js detects the Node.js native TypeScript resolver via process.features.typescript, added in v22.10.0. When present, next.config.ts can use native ESM, including top‑level await and dynamic import(). This mechanism inherits the capabilities and limitations of Node's resolver. In Node.js versions v22.18.0+, process.features.typescript is enabled by default. For versions between v22.10.0 and 22.17.x, opt in with NODE_OPTIONS=--experimental-transform-types: TerminalNODE_OPTIONS=--experimental-transform-types next <command> For CommonJS Projects (Default) Although next.config.ts supports native ESM syntax on CommonJS projects, Node.js will still assume next.config.ts is a CommonJS file by default, resulting in Node.js reparsing the file as ESM when module syntax is detected. Therefore, we recommend using the next.config.mts file for CommonJS projects to explicitly indicate it's an ESM module: next.config.mtsimport type { NextConfig } from 'next' // Top-level await and dynamic import are supported const flags = await import('./flags.js').then((m) => m.default ?? m) const nextConfig: NextConfig = { /* config options here */ typedRoutes: Boolean(flags?.typedRoutes), } export default nextConfig For ESM Projects When \"type\" is set to \"module\" in package.json, your project uses ESM. Learn more about this setting in the Node.js docs. In this case, you can write next.config.ts directly with ESM syntax. Good to know: When using \"type\": \"module\" in your package.json, all .js and .ts files in your project are treated as ESM modules by default. You may need to rename files with CommonJS syntax to .cjs or .cts extensions if needed. Statically Typed Links Next.js can statically type links to prevent typos and other errors when using next/link, improving type safety when navigating between pages. Works in both the Pages and App Router for the href prop in next/link. In the App Router, it also types next/navigation methods like push, replace, and prefetch. It does not type next/router methods in Pages Router. Literal href strings are validated, while non-literal hrefs may require a cast with as Route. To opt-into this feature, typedRoutes need to be enabled and the project needs to be using TypeScript. next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { typedRoutes: true, } export default nextConfig Next.js will generate a link definition in .next/types that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links. Good to know: If you set up your project without create-next-app, ensure the generated Next.js types are included by adding .next/types/**/*.ts to the include array in your tsconfig.json: tsconfig.json{ \"include\": [ \"next-env.d.ts\", \".next/types/**/*.ts\", \"**/*.ts\", \"**/*.tsx\" ], \"exclude\": [\"node_modules\"] } Currently, support includes any string literal, including dynamic segments. For non-literal strings, you need to manually cast with as Route. The example below shows both next/link and next/navigation usage: app/example-client.tsx'use client' import type { Route } from 'next' import Link from 'next/link' import { useRouter } from 'next/navigation' export default function Example() { const router = useRouter() const slug = 'nextjs' return ( <> {/* Link: literal and dynamic */} <Link href=\"/about\" /> <Link href={`/blog/${slug}`} /> <Link href={('/blog/' + slug) as Route} /> {/* TypeScript error if href is not a valid route */} <Link href=\"/aboot\" /> {/* Router: literal and dynamic strings are validated */} <button onClick={() => router.push('/about')}>Push About</button> <button onClick={() => router.replace(`/blog/${slug}`)}> Replace Blog </button> <button onClick={() => router.prefetch('/contact')}> Prefetch Contact </button> {/* For non-literal strings, cast to Route */} <button onClick={() => router.push(('/blog/' + slug) as Route)}> Push Non-literal Blog </button> </> ) } The same applies for redirecting routes defined by proxy: proxy.tsimport { NextRequest, NextResponse } from 'next/server' export function proxy(request: NextRequest) { if (request.nextUrl.pathname === '/proxy-redirect') { return NextResponse.redirect(new URL('/', request.url)) } return NextResponse.next() } app/some/page.tsximport type { Route } from 'next' export default function Page() { return <Link href={'/proxy-redirect' as Route}>Link Text</Link> } To accept href in a custom component wrapping next/link, use a generic: import type { Route } from 'next' import Link from 'next/link' function Card<T extends string>({ href }: { href: Route<T> | URL }) { return ( <Link href={href}> <div>My Card</div> </Link> ) } You can also type a simple data structure and iterate to render links: components/nav-items.tsimport type { Route } from 'next' type NavItem<T extends string = string> = { href: T label: string } export const navItems: NavItem<Route>[] = [ { href: '/', label: 'Home' }, { href: '/about', label: 'About' }, { href: '/blog', label: 'Blog' }, ] Then, map over the items to render Links: components/nav.tsximport Link from 'next/link' import { navItems } from './nav-items' export function Nav() { return ( <nav> {navItems.map((item) => ( <Link key={item.href} href={item.href}> {item.label} </Link> ))} </nav> ) } How does it work? When running next dev or next build, Next.js generates a hidden .d.ts file inside .next that contains information about all existing routes in your application (all valid routes as the href type of Link). This .d.ts file is included in tsconfig.json and the TypeScript compiler will check that .d.ts and provide feedback in your editor about invalid links. Type IntelliSense for Environment Variables During development, Next.js generates a .d.ts file in .next/types that contains information about the loaded environment variables for your editor's IntelliSense. If the same environment variable key is defined in multiple files, it is deduplicated according to the Environment Variable Load Order. To opt-into this feature, experimental.typedEnv needs to be enabled and the project needs to be using TypeScript. next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { experimental: { typedEnv: true, }, } export default nextConfig Good to know: Types are generated based on the environment variables loaded at development runtime, which excludes variables from .env.production* files by default. To include production-specific variables, run next dev with NODE_ENV=production. Static Generation and Server-side Rendering For getStaticProps, getStaticPaths, and getServerSideProps, you can use the GetStaticProps, GetStaticPaths, and GetServerSideProps types respectively:pages/blog/[slug].tsximport type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next' export const getStaticProps = (async (context) => { // ... }) satisfies GetStaticProps export const getStaticPaths = (async () => { // ... }) satisfies GetStaticPaths export const getServerSideProps = (async (context) => { // ... }) satisfies GetServerSideProps Good to know: satisfies was added to TypeScript in 4.9. We recommend upgrading to the latest version of TypeScript. With API Routes The following is an example of how to use the built-in types for API routes:pages/api/hello.tsimport type { NextApiRequest, NextApiResponse } from 'next' export default function handler(req: NextApiRequest, res: NextApiResponse) { res.status(200).json({ name: 'John Doe' }) }You can also type the response data:pages/api/hello.tsimport type { NextApiRequest, NextApiResponse } from 'next' type Data = { name: string } export default function handler( req: NextApiRequest, res: NextApiResponse<Data> ) { res.status(200).json({ name: 'John Doe' }) }With custom App If you have a custom App, you can use the built-in type AppProps and change file name to ./pages/_app.tsx like so:import type { AppProps } from 'next/app' export default function MyApp({ Component, pageProps }: AppProps) { return <Component {...pageProps} /> } Incremental type checking Since v10.2.1 Next.js supports incremental type checking when enabled in your tsconfig.json, this can help speed up type checking in larger applications. Custom tsconfig path In some cases, you might want to use a different TypeScript configuration for builds or tooling. To do that, set typescript.tsconfigPath in next.config.ts to point Next.js to another tsconfig file. next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { typescript: { tsconfigPath: 'tsconfig.build.json', }, } export default nextConfig For example, switch to a different config for production builds: next.config.tsimport type { NextConfig } from 'next' const isProd = process.env.NODE_ENV === 'production' const nextConfig: NextConfig = { typescript: { tsconfigPath: isProd ? 'tsconfig.build.json' : 'tsconfig.json', }, } export default nextConfig Why you might use a separate tsconfig for buildsYou might need to relax checks in scenarios like monorepos, where the build also validates shared dependencies that don't match your project's standards, or when loosening checks in CI to continue delivering while migrating locally to stricter TypeScript settings (and still wanting your IDE to highlight misuse).For example, if your project uses useUnknownInCatchVariables but some monorepo dependencies still assume any:tsconfig.build.json{ \"extends\": \"./tsconfig.json\", \"compilerOptions\": { \"useUnknownInCatchVariables\": false } }This keeps your editor strict via tsconfig.json while allowing the production build to use relaxed settings. Good to know: IDEs typically read tsconfig.json for diagnostics and IntelliSense, so you can still see IDE warnings while production builds use the alternate config. Mirror critical options if you want parity in the editor. In development, only tsconfig.json is watched for changes. If you edit a different file name via typescript.tsconfigPath, restart the dev server to apply changes. The configured file is used in next dev, next build, and next typegen. Disabling TypeScript errors in production Next.js fails your production build (next build) when TypeScript errors are present in your project. If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step. If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous. Open next.config.ts and enable the ignoreBuildErrors option in the typescript config: next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { typescript: { // !! WARN !! // Dangerously allow production builds to successfully complete even if // your project has type errors. // !! WARN !! ignoreBuildErrors: true, }, } export default nextConfig Good to know: You can run tsc --noEmit to check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying. Custom type declarations When you need to declare custom types, you might be tempted to modify next-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call it new-types.d.ts, and reference it in your tsconfig.json: tsconfig.json{ \"compilerOptions\": { \"skipLibCheck\": true //...truncated... }, \"include\": [ \"new-types.d.ts\", \"next-env.d.ts\", \".next/types/**/*.ts\", \"**/*.ts\", \"**/*.tsx\" ], \"exclude\": [\"node_modules\"] } Version Changes VersionChangesv15.0.0next.config.ts support added for TypeScript projects.v13.2.0Statically typed links are available in beta.v12.0.0SWC is now used by default to compile TypeScript and TSX for faster builds.v10.2.1Incremental type checking support added when enabled in your tsconfig.json.",
      "code": "create-next-app"
    },
    {
      "description": "TypeScript Next.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app. To add TypeScript to an existing project, rename a file to .ts / .tsx. Run next dev and next build to automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options. Good to know: If you already have a jsconfig.json file, copy the paths compiler option from the old jsconfig.json into the new tsconfig.json file, and delete the old jsconfig.json file. Examples Type Checking Next.js Configuration Files You can use TypeScript and import types in your Next.js configuration by using next.config.ts. next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { /* config options here */ } export default nextConfig Module resolution in next.config.ts is currently limited to CommonJS. However, ECMAScript Modules (ESM) syntax is available when using Node.js native TypeScript resolver for Node.js v22.10.0 and higher. When using the next.config.js file, you can add some type checking in your IDE using JSDoc as below: next.config.js// @ts-check /** @type {import('next').NextConfig} */ const nextConfig = { /* config options here */ } module.exports = nextConfig Using Node.js Native TypeScript Resolver for next.config.ts Note: Available on Node.js v22.10.0+ and only when the feature is enabled. Next.js does not enable it. Next.js detects the Node.js native TypeScript resolver via process.features.typescript, added in v22.10.0. When present, next.config.ts can use native ESM, including top‑level await and dynamic import(). This mechanism inherits the capabilities and limitations of Node's resolver. In Node.js versions v22.18.0+, process.features.typescript is enabled by default. For versions between v22.10.0 and 22.17.x, opt in with NODE_OPTIONS=--experimental-transform-types: TerminalNODE_OPTIONS=--experimental-transform-types next <command> For CommonJS Projects (Default) Although next.config.ts supports native ESM syntax on CommonJS projects, Node.js will still assume next.config.ts is a CommonJS file by default, resulting in Node.js reparsing the file as ESM when module syntax is detected. Therefore, we recommend using the next.config.mts file for CommonJS projects to explicitly indicate it's an ESM module: next.config.mtsimport type { NextConfig } from 'next' // Top-level await and dynamic import are supported const flags = await import('./flags.js').then((m) => m.default ?? m) const nextConfig: NextConfig = { /* config options here */ typedRoutes: Boolean(flags?.typedRoutes), } export default nextConfig For ESM Projects When \"type\" is set to \"module\" in package.json, your project uses ESM. Learn more about this setting in the Node.js docs. In this case, you can write next.config.ts directly with ESM syntax. Good to know: When using \"type\": \"module\" in your package.json, all .js and .ts files in your project are treated as ESM modules by default. You may need to rename files with CommonJS syntax to .cjs or .cts extensions if needed. Statically Typed Links Next.js can statically type links to prevent typos and other errors when using next/link, improving type safety when navigating between pages. Works in both the Pages and App Router for the href prop in next/link. In the App Router, it also types next/navigation methods like push, replace, and prefetch. It does not type next/router methods in Pages Router. Literal href strings are validated, while non-literal hrefs may require a cast with as Route. To opt-into this feature, typedRoutes need to be enabled and the project needs to be using TypeScript. next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { typedRoutes: true, } export default nextConfig Next.js will generate a link definition in .next/types that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links. Good to know: If you set up your project without create-next-app, ensure the generated Next.js types are included by adding .next/types/**/*.ts to the include array in your tsconfig.json: tsconfig.json{ \"include\": [ \"next-env.d.ts\", \".next/types/**/*.ts\", \"**/*.ts\", \"**/*.tsx\" ], \"exclude\": [\"node_modules\"] } Currently, support includes any string literal, including dynamic segments. For non-literal strings, you need to manually cast with as Route. The example below shows both next/link and next/navigation usage: app/example-client.tsx'use client' import type { Route } from 'next' import Link from 'next/link' import { useRouter } from 'next/navigation' export default function Example() { const router = useRouter() const slug = 'nextjs' return ( <> {/* Link: literal and dynamic */} <Link href=\"/about\" /> <Link href={`/blog/${slug}`} /> <Link href={('/blog/' + slug) as Route} /> {/* TypeScript error if href is not a valid route */} <Link href=\"/aboot\" /> {/* Router: literal and dynamic strings are validated */} <button onClick={() => router.push('/about')}>Push About</button> <button onClick={() => router.replace(`/blog/${slug}`)}> Replace Blog </button> <button onClick={() => router.prefetch('/contact')}> Prefetch Contact </button> {/* For non-literal strings, cast to Route */} <button onClick={() => router.push(('/blog/' + slug) as Route)}> Push Non-literal Blog </button> </> ) } The same applies for redirecting routes defined by proxy: proxy.tsimport { NextRequest, NextResponse } from 'next/server' export function proxy(request: NextRequest) { if (request.nextUrl.pathname === '/proxy-redirect') { return NextResponse.redirect(new URL('/', request.url)) } return NextResponse.next() } app/some/page.tsximport type { Route } from 'next' export default function Page() { return <Link href={'/proxy-redirect' as Route}>Link Text</Link> } To accept href in a custom component wrapping next/link, use a generic: import type { Route } from 'next' import Link from 'next/link' function Card<T extends string>({ href }: { href: Route<T> | URL }) { return ( <Link href={href}> <div>My Card</div> </Link> ) } You can also type a simple data structure and iterate to render links: components/nav-items.tsimport type { Route } from 'next' type NavItem<T extends string = string> = { href: T label: string } export const navItems: NavItem<Route>[] = [ { href: '/', label: 'Home' }, { href: '/about', label: 'About' }, { href: '/blog', label: 'Blog' }, ] Then, map over the items to render Links: components/nav.tsximport Link from 'next/link' import { navItems } from './nav-items' export function Nav() { return ( <nav> {navItems.map((item) => ( <Link key={item.href} href={item.href}> {item.label} </Link> ))} </nav> ) } How does it work? When running next dev or next build, Next.js generates a hidden .d.ts file inside .next that contains information about all existing routes in your application (all valid routes as the href type of Link). This .d.ts file is included in tsconfig.json and the TypeScript compiler will check that .d.ts and provide feedback in your editor about invalid links. Type IntelliSense for Environment Variables During development, Next.js generates a .d.ts file in .next/types that contains information about the loaded environment variables for your editor's IntelliSense. If the same environment variable key is defined in multiple files, it is deduplicated according to the Environment Variable Load Order. To opt-into this feature, experimental.typedEnv needs to be enabled and the project needs to be using TypeScript. next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { experimental: { typedEnv: true, }, } export default nextConfig Good to know: Types are generated based on the environment variables loaded at development runtime, which excludes variables from .env.production* files by default. To include production-specific variables, run next dev with NODE_ENV=production. Static Generation and Server-side Rendering For getStaticProps, getStaticPaths, and getServerSideProps, you can use the GetStaticProps, GetStaticPaths, and GetServerSideProps types respectively:pages/blog/[slug].tsximport type { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next' export const getStaticProps = (async (context) => { // ... }) satisfies GetStaticProps export const getStaticPaths = (async () => { // ... }) satisfies GetStaticPaths export const getServerSideProps = (async (context) => { // ... }) satisfies GetServerSideProps Good to know: satisfies was added to TypeScript in 4.9. We recommend upgrading to the latest version of TypeScript. With API Routes The following is an example of how to use the built-in types for API routes:pages/api/hello.tsimport type { NextApiRequest, NextApiResponse } from 'next' export default function handler(req: NextApiRequest, res: NextApiResponse) { res.status(200).json({ name: 'John Doe' }) }You can also type the response data:pages/api/hello.tsimport type { NextApiRequest, NextApiResponse } from 'next' type Data = { name: string } export default function handler( req: NextApiRequest, res: NextApiResponse<Data> ) { res.status(200).json({ name: 'John Doe' }) }With custom App If you have a custom App, you can use the built-in type AppProps and change file name to ./pages/_app.tsx like so:import type { AppProps } from 'next/app' export default function MyApp({ Component, pageProps }: AppProps) { return <Component {...pageProps} /> } Incremental type checking Since v10.2.1 Next.js supports incremental type checking when enabled in your tsconfig.json, this can help speed up type checking in larger applications. Custom tsconfig path In some cases, you might want to use a different TypeScript configuration for builds or tooling. To do that, set typescript.tsconfigPath in next.config.ts to point Next.js to another tsconfig file. next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { typescript: { tsconfigPath: 'tsconfig.build.json', }, } export default nextConfig For example, switch to a different config for production builds: next.config.tsimport type { NextConfig } from 'next' const isProd = process.env.NODE_ENV === 'production' const nextConfig: NextConfig = { typescript: { tsconfigPath: isProd ? 'tsconfig.build.json' : 'tsconfig.json', }, } export default nextConfig Why you might use a separate tsconfig for buildsYou might need to relax checks in scenarios like monorepos, where the build also validates shared dependencies that don't match your project's standards, or when loosening checks in CI to continue delivering while migrating locally to stricter TypeScript settings (and still wanting your IDE to highlight misuse).For example, if your project uses useUnknownInCatchVariables but some monorepo dependencies still assume any:tsconfig.build.json{ \"extends\": \"./tsconfig.json\", \"compilerOptions\": { \"useUnknownInCatchVariables\": false } }This keeps your editor strict via tsconfig.json while allowing the production build to use relaxed settings. Good to know: IDEs typically read tsconfig.json for diagnostics and IntelliSense, so you can still see IDE warnings while production builds use the alternate config. Mirror critical options if you want parity in the editor. In development, only tsconfig.json is watched for changes. If you edit a different file name via typescript.tsconfigPath, restart the dev server to apply changes. The configured file is used in next dev, next build, and next typegen. Disabling TypeScript errors in production Next.js fails your production build (next build) when TypeScript errors are present in your project. If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step. If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous. Open next.config.ts and enable the ignoreBuildErrors option in the typescript config: next.config.tsimport type { NextConfig } from 'next' const nextConfig: NextConfig = { typescript: { // !! WARN !! // Dangerously allow production builds to successfully complete even if // your project has type errors. // !! WARN !! ignoreBuildErrors: true, }, } export default nextConfig Good to know: You can run tsc --noEmit to check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying. Custom type declarations When you need to declare custom types, you might be tempted to modify next-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call it new-types.d.ts, and reference it in your tsconfig.json: tsconfig.json{ \"compilerOptions\": { \"skipLibCheck\": true //...truncated... }, \"include\": [ \"new-types.d.ts\", \"next-env.d.ts\", \".next/types/**/*.ts\", \"**/*.ts\", \"**/*.tsx\" ], \"exclude\": [\"node_modules\"] } Version Changes VersionChangesv15.0.0next.config.ts support added for TypeScript projects.v13.2.0Statically typed links are available in beta.v12.0.0SWC is now used by default to compile TypeScript and TSX for faster builds.v10.2.1Incremental type checking support added when enabled in your tsconfig.json.",
      "code": "create-next-app"
    },
    {
      "description": "Currently, support includes any string literal, including dynamic segments. For non-literal strings, you need to manually cast with as Route. The example below shows both next/link and next/navigation usage:",
      "code": "as Route"
    }
  ],
  "links": [
    "https://nextjs.org/docs/pages/api-reference",
    "https://nextjs.org/docs/pages/api-reference/config",
    "https://nextjs.org/docs/pages/api-reference/config/typescript",
    "https://nextjs.org/docs/app/guides/environment-variables",
    "https://nextjs.org/docs/pages/api-reference/functions/get-static-props",
    "https://nextjs.org/docs/pages/api-reference/functions/get-static-paths",
    "https://nextjs.org/docs/pages/api-reference/functions/get-server-side-props",
    "https://nextjs.org/docs/pages/building-your-application/routing/custom-app",
    "https://nextjs.org/docs/architecture/nextjs-compiler",
    "https://nextjs.org/docs/pages/api-reference/config/next-config-js/webVitalsAttribution",
    "https://nextjs.org/docs/pages/api-reference/config/eslint"
  ]
}