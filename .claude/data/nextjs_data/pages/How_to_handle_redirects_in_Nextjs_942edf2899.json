{
  "url": "https://nextjs.org/docs/pages/guides/redirecting",
  "title": "How to handle redirects in Next.js",
  "content": "There are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects.\n\nIf you need to redirect inside a component, you can use the push method from the useRouter hook. For example:\n\nSee the useRouter API reference for more information.\n\nThe redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time.\n\nredirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request.\n\nTo use redirects, add the option to your next.config.js file:\n\nSee the redirects API reference for more information.\n\nProxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects.\n\nFor example, to redirect the user to a /login page if they are not authenticated:\n\nSee the Proxy documentation for more information.\n\nTo manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application.\n\nTo do this, you'll need to consider:\n\nNext.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below.\n\nA redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file.\n\nConsider the following data structure:\n\nIn Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request:\n\nReading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance:\n\nConsidering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter.\n\nIf it does, forward the request to a API Routes which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request.\n\nThen, in the API Route:",
  "headings": [
    {
      "level": "h1",
      "text": "How to handle redirects in Next.js",
      "id": ""
    },
    {
      "level": "h2",
      "text": "useRouter() hook",
      "id": "userouter-hook"
    },
    {
      "level": "h2",
      "text": "redirects in next.config.js",
      "id": "redirects-in-nextconfigjs"
    },
    {
      "level": "h2",
      "text": "NextResponse.redirect in Proxy",
      "id": "nextresponseredirect-in-proxy"
    },
    {
      "level": "h2",
      "text": "Managing redirects at scale (advanced)",
      "id": "managing-redirects-at-scale-advanced"
    },
    {
      "level": "h3",
      "text": "1. Creating and storing a redirect map",
      "id": "1-creating-and-storing-a-redirect-map"
    },
    {
      "level": "h3",
      "text": "2. Optimizing data lookup performance",
      "id": "2-optimizing-data-lookup-performance"
    }
  ],
  "code_samples": [
    {
      "code": "import { useRouter } from 'next/router'\n \nexport default function Page() {\n  const router = useRouter()\n \n  return (\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\n      Dashboard\n    </button>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  async redirects() {\n    return [\n      // Basic redirect\n      {\n        source: '/about',\n        destination: '/',\n        permanent: true,\n      },\n      // Wildcard path matching\n      {\n        source: '/blog/:slug',\n        destination: '/news/:slug',\n        permanent: true,\n      },\n    ]\n  },\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "import { NextResponse, NextRequest } from 'next/server'\nimport { authenticate } from 'auth-provider'\n \nexport function proxy(request: NextRequest) {\n  const isAuthenticated = authenticate(request)\n \n  // If the user is authenticated, continue as normal\n  if (isAuthenticated) {\n    return NextResponse.next()\n  }\n \n  // Redirect to login page if not authenticated\n  return NextResponse.redirect(new URL('/login', request.url))\n}\n \nexport const config = {\n  matcher: '/dashboard/:path*',\n}",
      "language": "python"
    },
    {
      "code": "{\n  \"/old\": {\n    \"destination\": \"/new\",\n    \"permanent\": true\n  },\n  \"/blog/post-old\": {\n    \"destination\": \"/blog/post-new\",\n    \"permanent\": true\n  }\n}",
      "language": "unknown"
    },
    {
      "code": "import { NextResponse, NextRequest } from 'next/server'\nimport { get } from '@vercel/edge-config'\n \ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n \nexport async function proxy(request: NextRequest) {\n  const pathname = request.nextUrl.pathname\n  const redirectData = await get(pathname)\n \n  if (redirectData && typeof redirectData === 'string') {\n    const redirectEntry: RedirectEntry = JSON.parse(redirectData)\n    const statusCode = redirectEntry.permanent ? 308 : 307\n    return NextResponse.redirect(redirectEntry.destination, statusCode)\n  }\n \n  // No redirect found, continue without redirecting\n  return NextResponse.next()\n}",
      "language": "python"
    },
    {
      "code": "import { NextResponse, NextRequest } from 'next/server'\nimport { ScalableBloomFilter } from 'bloom-filters'\nimport GeneratedBloomFilter from './redirects/bloom-filter.json'\n \ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n \n// Initialize bloom filter from a generated JSON file\nconst bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any)\n \nexport async function proxy(request: NextRequest) {\n  // Get the path for the incoming request\n  const pathname = request.nextUrl.pathname\n \n  // Check if the path is in the bloom filter\n  if (bloomFilter.has(pathname)) {\n    // Forward the pathname to the Route Handler\n    const api = new URL(\n      `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,\n      request.nextUrl.origin\n    )\n \n    try {\n      // Fetch redirect data from the Route Handler\n      const redirectData = await fetch(api)\n \n      if (redirectData.ok) {\n        const redirectEntry: RedirectEntry | undefined =\n          await redirectData.json()\n \n        if (redirectEntry) {\n          // Determine the status code\n          const statusCode = redirectEntry.permanent ? 308 : 307\n \n          // Redirect to the destination\n          return NextResponse.redirect(redirectEntry.destination, statusCode)\n        }\n      }\n    } catch (error) {\n      console.error(error)\n    }\n  }\n \n  // No redirect found, continue the request without redirecting\n  return NextResponse.next()\n}",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\nimport redirects from '@/app/redirects/redirects.json'\n \ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n \nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const pathname = req.query.pathname\n  if (!pathname) {\n    return res.status(400).json({ message: 'Bad Request' })\n  }\n \n  // Get the redirect entry from the redirects.json file\n  const redirect = (redirects as Record<string, RedirectEntry>)[pathname]\n \n  // Account for bloom filter false positives\n  if (!redirect) {\n    return res.status(400).json({ message: 'No redirect' })\n  }\n \n  // Return the redirect entry\n  return res.json(redirect)\n}",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Pages RouterGuidesRedirectingCopy pageHow to handle redirects in Next.jsThere are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects. APIPurposeWhereStatus CodeuseRouterPerform a client-side navigationComponentsN/Aredirects in next.config.jsRedirect an incoming request based on a pathnext.config.js file307 (Temporary) or 308 (Permanent)NextResponse.redirectRedirect an incoming request based on a conditionProxyAny useRouter() hook If you need to redirect inside a component, you can use the push method from the useRouter hook. For example:app/page.tsxTypeScriptJavaScriptTypeScriptimport { useRouter } from 'next/router' export default function Page() { const router = useRouter() return ( <button type=\"button\" onClick={() => router.push('/dashboard')}> Dashboard </button> ) } Good to know: If you don't need to programmatically navigate a user, you should use a <Link> component. See the useRouter API reference for more information. redirects in next.config.js The redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time. redirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request. To use redirects, add the option to your next.config.js file: next.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next' const nextConfig: NextConfig = { async redirects() { return [ // Basic redirect { source: '/about', destination: '/', permanent: true, }, // Wildcard path matching { source: '/blog/:slug', destination: '/news/:slug', permanent: true, }, ] }, } export default nextConfig See the redirects API reference for more information. Good to know: redirects can return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with the permanent option. redirects may have a limit on platforms. For example, on Vercel, there's a limit of 1,024 redirects. To manage a large number of redirects (1000+), consider creating a custom solution using Proxy. See managing redirects at scale for more. redirects runs before Proxy. NextResponse.redirect in Proxy Proxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects. For example, to redirect the user to a /login page if they are not authenticated: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { authenticate } from 'auth-provider' export function proxy(request: NextRequest) { const isAuthenticated = authenticate(request) // If the user is authenticated, continue as normal if (isAuthenticated) { return NextResponse.next() } // Redirect to login page if not authenticated return NextResponse.redirect(new URL('/login', request.url)) } export const config = { matcher: '/dashboard/:path*', } Good to know: Proxy runs after redirects in next.config.js and before rendering. See the Proxy documentation for more information. Managing redirects at scale (advanced) To manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application. To do this, you'll need to consider: Creating and storing a redirect map. Optimizing data lookup performance. Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below. 1. Creating and storing a redirect map A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file. Consider the following data structure: { \"/old\": { \"destination\": \"/new\", \"permanent\": true }, \"/blog/post-old\": { \"destination\": \"/blog/post-new\", \"permanent\": true } } In Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { get } from '@vercel/edge-config' type RedirectEntry = { destination: string permanent: boolean } export async function proxy(request: NextRequest) { const pathname = request.nextUrl.pathname const redirectData = await get(pathname) if (redirectData && typeof redirectData === 'string') { const redirectEntry: RedirectEntry = JSON.parse(redirectData) const statusCode = redirectEntry.permanent ? 308 : 307 return NextResponse.redirect(redirectEntry.destination, statusCode) } // No redirect found, continue without redirecting return NextResponse.next() } 2. Optimizing data lookup performance Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance: Use a database that is optimized for fast reads Use a data lookup strategy such as a Bloom filter to efficiently check if a redirect exists before reading the larger redirects file or database. Considering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter. If it does, forward the request to a API Routes which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request. proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { ScalableBloomFilter } from 'bloom-filters' import GeneratedBloomFilter from './redirects/bloom-filter.json' type RedirectEntry = { destination: string permanent: boolean } // Initialize bloom filter from a generated JSON file const bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any) export async function proxy(request: NextRequest) { // Get the path for the incoming request const pathname = request.nextUrl.pathname // Check if the path is in the bloom filter if (bloomFilter.has(pathname)) { // Forward the pathname to the Route Handler const api = new URL( `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`, request.nextUrl.origin ) try { // Fetch redirect data from the Route Handler const redirectData = await fetch(api) if (redirectData.ok) { const redirectEntry: RedirectEntry | undefined = await redirectData.json() if (redirectEntry) { // Determine the status code const statusCode = redirectEntry.permanent ? 308 : 307 // Redirect to the destination return NextResponse.redirect(redirectEntry.destination, statusCode) } } } catch (error) { console.error(error) } } // No redirect found, continue the request without redirecting return NextResponse.next() } Then, in the API Route:pages/api/redirects.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' import redirects from '@/app/redirects/redirects.json' type RedirectEntry = { destination: string permanent: boolean } export default function handler(req: NextApiRequest, res: NextApiResponse) { const pathname = req.query.pathname if (!pathname) { return res.status(400).json({ message: 'Bad Request' }) } // Get the redirect entry from the redirects.json file const redirect = (redirects as Record<string, RedirectEntry>)[pathname] // Account for bloom filter false positives if (!redirect) { return res.status(400).json({ message: 'No redirect' }) } // Return the redirect entry return res.json(redirect) } Good to know: To generate a bloom filter, you can use a library like bloom-filters. You should validate requests made to your Route Handler to prevent malicious requests.",
      "code": "useRouter"
    },
    {
      "description": "How to handle redirects in Next.jsThere are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects. APIPurposeWhereStatus CodeuseRouterPerform a client-side navigationComponentsN/Aredirects in next.config.jsRedirect an incoming request based on a pathnext.config.js file307 (Temporary) or 308 (Permanent)NextResponse.redirectRedirect an incoming request based on a conditionProxyAny useRouter() hook If you need to redirect inside a component, you can use the push method from the useRouter hook. For example:app/page.tsxTypeScriptJavaScriptTypeScriptimport { useRouter } from 'next/router' export default function Page() { const router = useRouter() return ( <button type=\"button\" onClick={() => router.push('/dashboard')}> Dashboard </button> ) } Good to know: If you don't need to programmatically navigate a user, you should use a <Link> component. See the useRouter API reference for more information. redirects in next.config.js The redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time. redirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request. To use redirects, add the option to your next.config.js file: next.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next' const nextConfig: NextConfig = { async redirects() { return [ // Basic redirect { source: '/about', destination: '/', permanent: true, }, // Wildcard path matching { source: '/blog/:slug', destination: '/news/:slug', permanent: true, }, ] }, } export default nextConfig See the redirects API reference for more information. Good to know: redirects can return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with the permanent option. redirects may have a limit on platforms. For example, on Vercel, there's a limit of 1,024 redirects. To manage a large number of redirects (1000+), consider creating a custom solution using Proxy. See managing redirects at scale for more. redirects runs before Proxy. NextResponse.redirect in Proxy Proxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects. For example, to redirect the user to a /login page if they are not authenticated: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { authenticate } from 'auth-provider' export function proxy(request: NextRequest) { const isAuthenticated = authenticate(request) // If the user is authenticated, continue as normal if (isAuthenticated) { return NextResponse.next() } // Redirect to login page if not authenticated return NextResponse.redirect(new URL('/login', request.url)) } export const config = { matcher: '/dashboard/:path*', } Good to know: Proxy runs after redirects in next.config.js and before rendering. See the Proxy documentation for more information. Managing redirects at scale (advanced) To manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application. To do this, you'll need to consider: Creating and storing a redirect map. Optimizing data lookup performance. Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below. 1. Creating and storing a redirect map A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file. Consider the following data structure: { \"/old\": { \"destination\": \"/new\", \"permanent\": true }, \"/blog/post-old\": { \"destination\": \"/blog/post-new\", \"permanent\": true } } In Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { get } from '@vercel/edge-config' type RedirectEntry = { destination: string permanent: boolean } export async function proxy(request: NextRequest) { const pathname = request.nextUrl.pathname const redirectData = await get(pathname) if (redirectData && typeof redirectData === 'string') { const redirectEntry: RedirectEntry = JSON.parse(redirectData) const statusCode = redirectEntry.permanent ? 308 : 307 return NextResponse.redirect(redirectEntry.destination, statusCode) } // No redirect found, continue without redirecting return NextResponse.next() } 2. Optimizing data lookup performance Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance: Use a database that is optimized for fast reads Use a data lookup strategy such as a Bloom filter to efficiently check if a redirect exists before reading the larger redirects file or database. Considering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter. If it does, forward the request to a API Routes which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request. proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { ScalableBloomFilter } from 'bloom-filters' import GeneratedBloomFilter from './redirects/bloom-filter.json' type RedirectEntry = { destination: string permanent: boolean } // Initialize bloom filter from a generated JSON file const bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any) export async function proxy(request: NextRequest) { // Get the path for the incoming request const pathname = request.nextUrl.pathname // Check if the path is in the bloom filter if (bloomFilter.has(pathname)) { // Forward the pathname to the Route Handler const api = new URL( `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`, request.nextUrl.origin ) try { // Fetch redirect data from the Route Handler const redirectData = await fetch(api) if (redirectData.ok) { const redirectEntry: RedirectEntry | undefined = await redirectData.json() if (redirectEntry) { // Determine the status code const statusCode = redirectEntry.permanent ? 308 : 307 // Redirect to the destination return NextResponse.redirect(redirectEntry.destination, statusCode) } } } catch (error) { console.error(error) } } // No redirect found, continue the request without redirecting return NextResponse.next() } Then, in the API Route:pages/api/redirects.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' import redirects from '@/app/redirects/redirects.json' type RedirectEntry = { destination: string permanent: boolean } export default function handler(req: NextApiRequest, res: NextApiResponse) { const pathname = req.query.pathname if (!pathname) { return res.status(400).json({ message: 'Bad Request' }) } // Get the redirect entry from the redirects.json file const redirect = (redirects as Record<string, RedirectEntry>)[pathname] // Account for bloom filter false positives if (!redirect) { return res.status(400).json({ message: 'No redirect' }) } // Return the redirect entry return res.json(redirect) } Good to know: To generate a bloom filter, you can use a library like bloom-filters. You should validate requests made to your Route Handler to prevent malicious requests.",
      "code": "useRouter"
    },
    {
      "description": "If you need to redirect inside a component, you can use the push method from the useRouter hook. For example:",
      "code": "push"
    },
    {
      "description": "Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below.",
      "code": "{\n  \"/old\": {\n    \"destination\": \"/new\",\n    \"permanent\": true\n  },\n  \"/blog/post-old\": {\n    \"destination\": \"/blog/post-new\",\n    \"permanent\": true\n  }\n}"
    }
  ],
  "links": [
    "https://nextjs.org/docs/pages",
    "https://nextjs.org/docs/pages/guides",
    "https://nextjs.org/docs/pages/guides/redirecting",
    "https://nextjs.org/docs/app/api-reference/components/link",
    "https://nextjs.org/docs/pages/api-reference/functions/use-router",
    "https://nextjs.org/docs/app/api-reference/config/next-config-js/redirects",
    "https://nextjs.org/docs/app/api-reference/file-conventions/proxy",
    "https://nextjs.org/docs/pages/building-your-application/routing/api-routes",
    "https://nextjs.org/docs/pages/guides/production-checklist",
    "https://nextjs.org/docs/pages/guides/sass"
  ]
}