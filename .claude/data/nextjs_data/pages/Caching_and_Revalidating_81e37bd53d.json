{
  "url": "https://nextjs.org/docs/app/getting-started/caching-and-revalidating",
  "title": "Caching and Revalidating",
  "content": "Caching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application.\n\nNext.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them.\n\nBy default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'.\n\nGood to know: Although fetch requests are not cached by default, Next.js will pre-render routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API.\n\nTo revalidate the data returned by a fetch request, you can use the next.revalidate option.\n\nThis will revalidate the data after a specified amount of seconds.\n\nYou can also tag fetch requests to enable on-demand cache invalidation:\n\nSee the fetch API reference to learn more.\n\ncacheTag allows you to tag cached data in Cache Components so it can be revalidated on-demand. Previously, cache tagging was limited to fetch requests, and caching other work required the experimental unstable_cache API.\n\nWith Cache Components, you can use the use cache directive to cache any computation, and cacheTag to tag it. This works with database queries, file system operations, and other server-side work.\n\nOnce tagged, you can use revalidateTag or updateTag to invalidate the cache entry for products.\n\nGood to know: cacheTag is used with Cache Components and the use cache directive. It expands the caching and revalidation story beyond fetch.\n\nSee the cacheTag API reference to learn more.\n\nrevalidateTag is used to revalidate cache entries based on a tag and following an event. The function now supports two behaviors:\n\nAfter tagging your cached data, using fetch with next.tags, or the cacheTag function, you may call revalidateTag in a Route Handler or Server Action:\n\nYou can reuse the same tag in multiple functions to revalidate them all at once.\n\nSee the revalidateTag API reference to learn more.\n\nupdateTag is specifically designed for Server Actions to immediately expire cached data for read-your-own-writes scenarios. Unlike revalidateTag, it can only be used within Server Actions and immediately expires the cache entry.\n\nThe key differences between revalidateTag and updateTag:\n\nSee the updateTag API reference to learn more.\n\nrevalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action:\n\nSee the revalidatePath API reference to learn more.\n\nGood to know: unstable_cache is an experimental API. We recommend opting into Cache Components and replacing unstable_cache with the use cache directive. See the Cache Components documentation for more details.\n\nunstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example:\n\nThe function accepts a third optional object to define how the cache should be revalidated. It accepts:\n\nSee the unstable_cache API reference to learn more.",
  "headings": [
    {
      "level": "h1",
      "text": "Caching and Revalidating",
      "id": ""
    },
    {
      "level": "h2",
      "text": "fetch",
      "id": "fetch"
    },
    {
      "level": "h2",
      "text": "cacheTag",
      "id": "cachetag"
    },
    {
      "level": "h2",
      "text": "revalidateTag",
      "id": "revalidatetag"
    },
    {
      "level": "h2",
      "text": "updateTag",
      "id": "updatetag"
    },
    {
      "level": "h2",
      "text": "revalidatePath",
      "id": "revalidatepath"
    },
    {
      "level": "h2",
      "text": "unstable_cache",
      "id": "unstable_cache"
    },
    {
      "level": "h2",
      "text": "API Reference",
      "id": "api-reference"
    },
    {
      "level": "h3",
      "text": "fetch",
      "id": ""
    },
    {
      "level": "h3",
      "text": "cacheTag",
      "id": ""
    },
    {
      "level": "h3",
      "text": "revalidateTag",
      "id": ""
    },
    {
      "level": "h3",
      "text": "updateTag",
      "id": ""
    },
    {
      "level": "h3",
      "text": "revalidatePath",
      "id": ""
    },
    {
      "level": "h3",
      "text": "unstable_cache",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "export default async function Page() {\n  const data = await fetch('https://...', { cache: 'force-cache' })\n}",
      "language": "javascript"
    },
    {
      "code": "export default async function Page() {\n  const data = await fetch('https://...', { next: { revalidate: 3600 } })\n}",
      "language": "javascript"
    },
    {
      "code": "export async function getUserById(id: string) {\n  const data = await fetch(`https://...`, {\n    next: {\n      tags: ['user'],\n    },\n  })\n}",
      "language": "javascript"
    },
    {
      "code": "import { cacheTag } from 'next/cache'\n \nexport async function getProducts() {\n  'use cache'\n  cacheTag('products')\n \n  const products = await db.query('SELECT * FROM products')\n  return products\n}",
      "language": "python"
    },
    {
      "code": "import { revalidateTag } from 'next/cache'\n \nexport async function updateUser(id: string) {\n  // Mutate data\n  revalidateTag('user', 'max') // Recommended: Uses stale-while-revalidate\n}",
      "language": "python"
    },
    {
      "code": "import { updateTag } from 'next/cache'\nimport { redirect } from 'next/navigation'\n \nexport async function createPost(formData: FormData) {\n  // Create post in database\n  const post = await db.post.create({\n    data: {\n      title: formData.get('title'),\n      content: formData.get('content'),\n    },\n  })\n \n  // Immediately expire cache so the new post is visible\n  updateTag('posts')\n  updateTag(`post-${post.id}`)\n \n  redirect(`/posts/${post.id}`)\n}",
      "language": "python"
    },
    {
      "code": "import { revalidatePath } from 'next/cache'\n \nexport async function updateUser(id: string) {\n  // Mutate data\n  revalidatePath('/profile')",
      "language": "python"
    },
    {
      "code": "import { db } from '@/lib/db'\nexport async function getUserById(id: string) {\n  return db\n    .select()\n    .from(users)\n    .where(eq(users.id, id))\n    .then((res) => res[0])\n}",
      "language": "python"
    },
    {
      "code": "import { unstable_cache } from 'next/cache'\nimport { getUserById } from '@/app/lib/data'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ userId: string }>\n}) {\n  const { userId } = await params\n \n  const getCachedUser = unstable_cache(\n    async () => {\n      return getUserById(userId)\n    },\n    [userId] // add the user ID to the cache key\n  )\n}",
      "language": "python"
    },
    {
      "code": "const getCachedUser = unstable_cache(\n  async () => {\n    return getUserById(userId)\n  },\n  [userId],\n  {\n    tags: ['user'],\n    revalidate: 3600,\n  }\n)",
      "language": "javascript"
    }
  ],
  "patterns": [
    {
      "description": "App RouterGetting StartedCaching and RevalidatingCopy pageCaching and RevalidatingCaching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application. Next.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them. fetch cacheTag revalidateTag updateTag revalidatePath unstable_cache (Legacy) fetch By default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'. app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() { const data = await fetch('https://...', { cache: 'force-cache' }) } Good to know: Although fetch requests are not cached by default, Next.js will pre-render routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API. To revalidate the data returned by a fetch request, you can use the next.revalidate option. app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() { const data = await fetch('https://...', { next: { revalidate: 3600 } }) } This will revalidate the data after a specified amount of seconds. You can also tag fetch requests to enable on-demand cache invalidation: app/lib/data.tsTypeScriptJavaScriptTypeScriptexport async function getUserById(id: string) { const data = await fetch(`https://...`, { next: { tags: ['user'], }, }) } See the fetch API reference to learn more. cacheTag cacheTag allows you to tag cached data in Cache Components so it can be revalidated on-demand. Previously, cache tagging was limited to fetch requests, and caching other work required the experimental unstable_cache API. With Cache Components, you can use the use cache directive to cache any computation, and cacheTag to tag it. This works with database queries, file system operations, and other server-side work. app/lib/data.tsTypeScriptJavaScriptTypeScriptimport { cacheTag } from 'next/cache' export async function getProducts() { 'use cache' cacheTag('products') const products = await db.query('SELECT * FROM products') return products } Once tagged, you can use revalidateTag or updateTag to invalidate the cache entry for products. Good to know: cacheTag is used with Cache Components and the use cache directive. It expands the caching and revalidation story beyond fetch. See the cacheTag API reference to learn more. revalidateTag revalidateTag is used to revalidate cache entries based on a tag and following an event. The function now supports two behaviors: With profile=\"max\": Uses stale-while-revalidate semantics, serving stale content while fetching fresh content in the background Without the second argument: Legacy behavior that immediately expires the cache (deprecated) After tagging your cached data, using fetch with next.tags, or the cacheTag function, you may call revalidateTag in a Route Handler or Server Action: app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidateTag } from 'next/cache' export async function updateUser(id: string) { // Mutate data revalidateTag('user', 'max') // Recommended: Uses stale-while-revalidate } You can reuse the same tag in multiple functions to revalidate them all at once. See the revalidateTag API reference to learn more. updateTag updateTag is specifically designed for Server Actions to immediately expire cached data for read-your-own-writes scenarios. Unlike revalidateTag, it can only be used within Server Actions and immediately expires the cache entry. app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { updateTag } from 'next/cache' import { redirect } from 'next/navigation' export async function createPost(formData: FormData) { // Create post in database const post = await db.post.create({ data: { title: formData.get('title'), content: formData.get('content'), }, }) // Immediately expire cache so the new post is visible updateTag('posts') updateTag(`post-${post.id}`) redirect(`/posts/${post.id}`) } The key differences between revalidateTag and updateTag: updateTag: Only in Server Actions, immediately expires cache, for read-your-own-writes revalidateTag: In Server Actions and Route Handlers, supports stale-while-revalidate with profile=\"max\" See the updateTag API reference to learn more. revalidatePath revalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action: app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidatePath } from 'next/cache' export async function updateUser(id: string) { // Mutate data revalidatePath('/profile') See the revalidatePath API reference to learn more. unstable_cache Good to know: unstable_cache is an experimental API. We recommend opting into Cache Components and replacing unstable_cache with the use cache directive. See the Cache Components documentation for more details. unstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example: app/lib/data.tsTypeScriptJavaScriptTypeScriptimport { db } from '@/lib/db' export async function getUserById(id: string) { return db .select() .from(users) .where(eq(users.id, id)) .then((res) => res[0]) } app/page.tsxTypeScriptJavaScriptTypeScriptimport { unstable_cache } from 'next/cache' import { getUserById } from '@/app/lib/data' export default async function Page({ params, }: { params: Promise<{ userId: string }> }) { const { userId } = await params const getCachedUser = unstable_cache( async () => { return getUserById(userId) }, [userId] // add the user ID to the cache key ) } The function accepts a third optional object to define how the cache should be revalidated. It accepts: tags: an array of tags used by Next.js to revalidate the cache. revalidate: the number of seconds after cache should be revalidated. app/page.tsxTypeScriptJavaScriptTypeScriptconst getCachedUser = unstable_cache( async () => { return getUserById(userId) }, [userId], { tags: ['user'], revalidate: 3600, } ) See the unstable_cache API reference to learn more.API ReferenceLearn more about the features mentioned in this page by reading the API Reference.fetchAPI reference for the extended fetch function.cacheTagLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.revalidateTagAPI Reference for the revalidateTag function.updateTagAPI Reference for the updateTag function.revalidatePathAPI Reference for the revalidatePath function.unstable_cacheAPI Reference for the unstable_cache function.",
      "code": "fetch"
    },
    {
      "description": "Caching and RevalidatingCaching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application. Next.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them. fetch cacheTag revalidateTag updateTag revalidatePath unstable_cache (Legacy) fetch By default, fetch requests are not cached. You can cache individual requests by setting the cache option to 'force-cache'. app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() { const data = await fetch('https://...', { cache: 'force-cache' }) } Good to know: Although fetch requests are not cached by default, Next.js will pre-render routes that have fetch requests and cache the HTML. If you want to guarantee a route is dynamic, use the connection API. To revalidate the data returned by a fetch request, you can use the next.revalidate option. app/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page() { const data = await fetch('https://...', { next: { revalidate: 3600 } }) } This will revalidate the data after a specified amount of seconds. You can also tag fetch requests to enable on-demand cache invalidation: app/lib/data.tsTypeScriptJavaScriptTypeScriptexport async function getUserById(id: string) { const data = await fetch(`https://...`, { next: { tags: ['user'], }, }) } See the fetch API reference to learn more. cacheTag cacheTag allows you to tag cached data in Cache Components so it can be revalidated on-demand. Previously, cache tagging was limited to fetch requests, and caching other work required the experimental unstable_cache API. With Cache Components, you can use the use cache directive to cache any computation, and cacheTag to tag it. This works with database queries, file system operations, and other server-side work. app/lib/data.tsTypeScriptJavaScriptTypeScriptimport { cacheTag } from 'next/cache' export async function getProducts() { 'use cache' cacheTag('products') const products = await db.query('SELECT * FROM products') return products } Once tagged, you can use revalidateTag or updateTag to invalidate the cache entry for products. Good to know: cacheTag is used with Cache Components and the use cache directive. It expands the caching and revalidation story beyond fetch. See the cacheTag API reference to learn more. revalidateTag revalidateTag is used to revalidate cache entries based on a tag and following an event. The function now supports two behaviors: With profile=\"max\": Uses stale-while-revalidate semantics, serving stale content while fetching fresh content in the background Without the second argument: Legacy behavior that immediately expires the cache (deprecated) After tagging your cached data, using fetch with next.tags, or the cacheTag function, you may call revalidateTag in a Route Handler or Server Action: app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidateTag } from 'next/cache' export async function updateUser(id: string) { // Mutate data revalidateTag('user', 'max') // Recommended: Uses stale-while-revalidate } You can reuse the same tag in multiple functions to revalidate them all at once. See the revalidateTag API reference to learn more. updateTag updateTag is specifically designed for Server Actions to immediately expire cached data for read-your-own-writes scenarios. Unlike revalidateTag, it can only be used within Server Actions and immediately expires the cache entry. app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { updateTag } from 'next/cache' import { redirect } from 'next/navigation' export async function createPost(formData: FormData) { // Create post in database const post = await db.post.create({ data: { title: formData.get('title'), content: formData.get('content'), }, }) // Immediately expire cache so the new post is visible updateTag('posts') updateTag(`post-${post.id}`) redirect(`/posts/${post.id}`) } The key differences between revalidateTag and updateTag: updateTag: Only in Server Actions, immediately expires cache, for read-your-own-writes revalidateTag: In Server Actions and Route Handlers, supports stale-while-revalidate with profile=\"max\" See the updateTag API reference to learn more. revalidatePath revalidatePath is used to revalidate a route and following an event. To use it, call it in a Route Handler or Server Action: app/lib/actions.tsTypeScriptJavaScriptTypeScriptimport { revalidatePath } from 'next/cache' export async function updateUser(id: string) { // Mutate data revalidatePath('/profile') See the revalidatePath API reference to learn more. unstable_cache Good to know: unstable_cache is an experimental API. We recommend opting into Cache Components and replacing unstable_cache with the use cache directive. See the Cache Components documentation for more details. unstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example: app/lib/data.tsTypeScriptJavaScriptTypeScriptimport { db } from '@/lib/db' export async function getUserById(id: string) { return db .select() .from(users) .where(eq(users.id, id)) .then((res) => res[0]) } app/page.tsxTypeScriptJavaScriptTypeScriptimport { unstable_cache } from 'next/cache' import { getUserById } from '@/app/lib/data' export default async function Page({ params, }: { params: Promise<{ userId: string }> }) { const { userId } = await params const getCachedUser = unstable_cache( async () => { return getUserById(userId) }, [userId] // add the user ID to the cache key ) } The function accepts a third optional object to define how the cache should be revalidated. It accepts: tags: an array of tags used by Next.js to revalidate the cache. revalidate: the number of seconds after cache should be revalidated. app/page.tsxTypeScriptJavaScriptTypeScriptconst getCachedUser = unstable_cache( async () => { return getUserById(userId) }, [userId], { tags: ['user'], revalidate: 3600, } ) See the unstable_cache API reference to learn more.",
      "code": "fetch"
    },
    {
      "description": "unstable_cache allows you to cache the result of database queries and other async functions. To use it, wrap unstable_cache around the function. For example:",
      "code": "unstable_cache"
    }
  ],
  "links": [
    "https://nextjs.org/docs/app",
    "https://nextjs.org/docs/app/getting-started",
    "https://nextjs.org/docs/app/getting-started/caching-and-revalidating",
    "https://nextjs.org/docs/app/api-reference/functions/fetch",
    "https://nextjs.org/docs/app/guides/caching",
    "https://nextjs.org/docs/app/api-reference/functions/connection",
    "https://nextjs.org/docs/app/api-reference/functions/cacheTag",
    "https://nextjs.org/docs/app/getting-started/cache-components",
    "https://nextjs.org/docs/app/api-reference/directives/use-cache",
    "https://nextjs.org/docs/app/api-reference/file-conventions/route",
    "https://nextjs.org/docs/app/api-reference/functions/revalidateTag",
    "https://nextjs.org/docs/app/api-reference/functions/updateTag",
    "https://nextjs.org/docs/app/api-reference/functions/revalidatePath",
    "https://nextjs.org/docs/app/api-reference/functions/unstable_cache",
    "https://nextjs.org/docs/app/getting-started/updating-data",
    "https://nextjs.org/docs/app/getting-started/error-handling"
  ]
}