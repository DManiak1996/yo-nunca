{
  "url": "https://nextjs.org/docs/15/app/guides/forms",
  "title": "How to create forms with Server Actions",
  "content": "React Server Actions are Server Functions that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create forms in Next.js with Server Actions.\n\nReact extends the HTML <form> element to allow Server Actions to be invoked with the action attribute.\n\nWhen used in a form, the function automatically receives the FormData object. You can then extract the data using the native FormData methods:\n\nGood to know: When working with forms that have multiple fields, use JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData). Note that this object will contain extra properties prefixed with $ACTION_.\n\nOutside of form fields, you can pass additional arguments to a Server Function using the JavaScript bind method. For example, to pass the userId argument to the updateUser Server Function:\n\nThe Server Function will receive the userId as an additional argument:\n\nForms can be validated on the client or server.\n\nTo display validation errors or messages, turn the component that defines the <form> into a Client Component and use React useActionState.\n\nWhen using useActionState, the Server function signature will change to receive a new prevState or initialState parameter as its first argument.\n\nYou can then conditionally render the error message based on the state object.\n\nThe useActionState hook exposes a pending boolean that can be used to show a loading indicator or disable the submit button while the action is being executed.\n\nAlternatively, you can use the useFormStatus hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending:\n\nYou can then nest the SubmitButton component inside the form:\n\nGood to know: In React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available.\n\nYou can use the React useOptimistic hook to optimistically update the UI before the Server Function finishes executing, rather than waiting for the response:\n\nYou can call Server Actions in elements nested inside <form> such as <button>, <input type=\"submit\">, and <input type=\"image\">. These elements accept the formAction prop or event handlers.\n\nThis is useful in cases where you want to call multiple Server Actions within a form. For example, you can create a specific <button> element for saving a post draft in addition to publishing it. See the React <form> docs for more information.\n\nYou can trigger a form submission programmatically using the requestSubmit() method. For example, when the user submits a form using the ⌘ + Enter keyboard shortcut, you can listen for the onKeyDown event:\n\nThis will trigger the submission of the nearest <form> ancestor, which will invoke the Server Function.",
  "headings": [
    {
      "level": "h1",
      "text": "How to create forms with Server Actions",
      "id": ""
    },
    {
      "level": "h2",
      "text": "How it works",
      "id": "how-it-works"
    },
    {
      "level": "h2",
      "text": "Passing additional arguments",
      "id": "passing-additional-arguments"
    },
    {
      "level": "h2",
      "text": "Form validation",
      "id": "form-validation"
    },
    {
      "level": "h2",
      "text": "Validation errors",
      "id": "validation-errors"
    },
    {
      "level": "h2",
      "text": "Pending states",
      "id": "pending-states"
    },
    {
      "level": "h2",
      "text": "Optimistic updates",
      "id": "optimistic-updates"
    },
    {
      "level": "h2",
      "text": "Nested form elements",
      "id": "nested-form-elements"
    },
    {
      "level": "h2",
      "text": "Programmatic form submission",
      "id": "programmatic-form-submission"
    }
  ],
  "code_samples": [
    {
      "code": "export default function Page() {\n  async function createInvoice(formData: FormData) {\n    'use server'\n \n    const rawFormData = {\n      customerId: formData.get('customerId'),\n      amount: formData.get('amount'),\n      status: formData.get('status'),\n    }\n \n    // mutate data\n    // revalidate the cache\n  }\n \n  return <form action={createInvoice}>...</form>\n}",
      "language": "javascript"
    },
    {
      "code": "'use client'\n \nimport { updateUser } from './actions'\n \nexport function UserProfile({ userId }: { userId: string }) {\n  const updateUserWithId = updateUser.bind(null, userId)\n \n  return (\n    <form action={updateUserWithId}>\n      <input type=\"text\" name=\"name\" />\n      <button type=\"submit\">Update User Name</button>\n    </form>\n  )\n}",
      "language": "python"
    },
    {
      "code": "'use server'\n \nexport async function updateUser(userId: string, formData: FormData) {}",
      "language": "unknown"
    },
    {
      "code": "'use server'\n \nimport { z } from 'zod'\n \nconst schema = z.object({\n  email: z.string({\n    invalid_type_error: 'Invalid Email',\n  }),\n})\n \nexport default async function createUser(formData: FormData) {\n  const validatedFields = schema.safeParse({\n    email: formData.get('email'),\n  })\n \n  // Return early if the form data is invalid\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n    }\n  }\n \n  // Mutate data\n}",
      "language": "python"
    },
    {
      "code": "'use server'\n \nimport { z } from 'zod'\n \nexport async function createUser(initialState: any, formData: FormData) {\n  const validatedFields = schema.safeParse({\n    email: formData.get('email'),\n  })\n  // ...\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nimport { useActionState } from 'react'\nimport { createUser } from '@/app/actions'\n \nconst initialState = {\n  message: '',\n}\n \nexport function Signup() {\n  const [state, formAction, pending] = useActionState(createUser, initialState)\n \n  return (\n    <form action={formAction}>\n      <label htmlFor=\"email\">Email</label>\n      <input type=\"text\" id=\"email\" name=\"email\" required />\n      {/* ... */}\n      <p aria-live=\"polite\">{state?.message}</p>\n      <button disabled={pending}>Sign up</button>\n    </form>\n  )\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nimport { useActionState } from 'react'\nimport { createUser } from '@/app/actions'\n \nexport function Signup() {\n  const [state, formAction, pending] = useActionState(createUser, initialState)\n \n  return (\n    <form action={formAction}>\n      {/* Other form elements */}\n      <button disabled={pending}>Sign up</button>\n    </form>\n  )\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nimport { useFormStatus } from 'react-dom'\n \nexport function SubmitButton() {\n  const { pending } = useFormStatus()\n \n  return (\n    <button disabled={pending} type=\"submit\">\n      Sign Up\n    </button>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import { SubmitButton } from './button'\nimport { createUser } from '@/app/actions'\n \nexport function Signup() {\n  return (\n    <form action={createUser}>\n      {/* Other form elements */}\n      <SubmitButton />\n    </form>\n  )\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nimport { useOptimistic } from 'react'\nimport { send } from './actions'\n \ntype Message = {\n  message: string\n}\n \nexport function Thread({ messages }: { messages: Message[] }) {\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic<\n    Message[],\n    string\n  >(messages, (state, newMessage) => [...state, { message: newMessage }])\n \n  const formAction = async (formData: FormData) => {\n    const message = formData.get('message') as string\n    addOptimisticMessage(message)\n    await send(message)\n  }\n \n  return (\n    <div>\n      {optimisticMessages.map((m, i) => (\n        <div key={i}>{m.message}</div>\n      ))}\n      <form action={formAction}>\n        <input type=\"text\" name=\"message\" />\n        <button type=\"submit\">Send</button>\n      </form>\n    </div>\n  )\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nexport function Entry() {\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (\n      (e.ctrlKey || e.metaKey) &&\n      (e.key === 'Enter' || e.key === 'NumpadEnter')\n    ) {\n      e.preventDefault()\n      e.currentTarget.form?.requestSubmit()\n    }\n  }\n \n  return (\n    <div>\n      <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} />\n    </div>\n  )\n}",
      "language": "javascript"
    }
  ],
  "patterns": [
    {
      "description": "App RouterGuidesFormsYou are currently viewing documentation for version 15 of Next.js.How to create forms with Server ActionsReact Server Actions are Server Functions that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create forms in Next.js with Server Actions. How it works React extends the HTML <form> element to allow Server Actions to be invoked with the action attribute. When used in a form, the function automatically receives the FormData object. You can then extract the data using the native FormData methods: app/invoices/page.tsxTypeScriptJavaScriptTypeScriptexport default function Page() { async function createInvoice(formData: FormData) { 'use server' const rawFormData = { customerId: formData.get('customerId'), amount: formData.get('amount'), status: formData.get('status'), } // mutate data // revalidate the cache } return <form action={createInvoice}>...</form> } Good to know: When working with forms that have multiple fields, use JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData). Note that this object will contain extra properties prefixed with $ACTION_. Passing additional arguments Outside of form fields, you can pass additional arguments to a Server Function using the JavaScript bind method. For example, to pass the userId argument to the updateUser Server Function: app/client-component.tsxTypeScriptJavaScriptTypeScript'use client' import { updateUser } from './actions' export function UserProfile({ userId }: { userId: string }) { const updateUserWithId = updateUser.bind(null, userId) return ( <form action={updateUserWithId}> <input type=\"text\" name=\"name\" /> <button type=\"submit\">Update User Name</button> </form> ) } The Server Function will receive the userId as an additional argument: app/actions.tsTypeScriptJavaScriptTypeScript'use server' export async function updateUser(userId: string, formData: FormData) {} Good to know: An alternative is to pass arguments as hidden input fields in the form (e.g. <input type=\"hidden\" name=\"userId\" value={userId} />). However, the value will be part of the rendered HTML and will not be encoded. bind works in both Server and Client Components and supports progressive enhancement. Form validation Forms can be validated on the client or server. For client-side validation, you can use the HTML attributes like required and type=\"email\" for basic validation. For server-side validation, you can use a library like zod to validate the form fields. For example: app/actions.tsTypeScriptJavaScriptTypeScript'use server' import { z } from 'zod' const schema = z.object({ email: z.string({ invalid_type_error: 'Invalid Email', }), }) export default async function createUser(formData: FormData) { const validatedFields = schema.safeParse({ email: formData.get('email'), }) // Return early if the form data is invalid if (!validatedFields.success) { return { errors: validatedFields.error.flatten().fieldErrors, } } // Mutate data } Validation errors To display validation errors or messages, turn the component that defines the <form> into a Client Component and use React useActionState. When using useActionState, the Server function signature will change to receive a new prevState or initialState parameter as its first argument. app/actions.tsTypeScriptJavaScriptTypeScript'use server' import { z } from 'zod' export async function createUser(initialState: any, formData: FormData) { const validatedFields = schema.safeParse({ email: formData.get('email'), }) // ... } You can then conditionally render the error message based on the state object. app/ui/signup.tsxTypeScriptJavaScriptTypeScript'use client' import { useActionState } from 'react' import { createUser } from '@/app/actions' const initialState = { message: '', } export function Signup() { const [state, formAction, pending] = useActionState(createUser, initialState) return ( <form action={formAction}> <label htmlFor=\"email\">Email</label> <input type=\"text\" id=\"email\" name=\"email\" required /> {/* ... */} <p aria-live=\"polite\">{state?.message}</p> <button disabled={pending}>Sign up</button> </form> ) } Pending states The useActionState hook exposes a pending boolean that can be used to show a loading indicator or disable the submit button while the action is being executed. app/ui/signup.tsxTypeScriptJavaScriptTypeScript'use client' import { useActionState } from 'react' import { createUser } from '@/app/actions' export function Signup() { const [state, formAction, pending] = useActionState(createUser, initialState) return ( <form action={formAction}> {/* Other form elements */} <button disabled={pending}>Sign up</button> </form> ) } Alternatively, you can use the useFormStatus hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending: app/ui/button.tsxTypeScriptJavaScriptTypeScript'use client' import { useFormStatus } from 'react-dom' export function SubmitButton() { const { pending } = useFormStatus() return ( <button disabled={pending} type=\"submit\"> Sign Up </button> ) } You can then nest the SubmitButton component inside the form: app/ui/signup.tsxTypeScriptJavaScriptTypeScriptimport { SubmitButton } from './button' import { createUser } from '@/app/actions' export function Signup() { return ( <form action={createUser}> {/* Other form elements */} <SubmitButton /> </form> ) } Good to know: In React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available. Optimistic updates You can use the React useOptimistic hook to optimistically update the UI before the Server Function finishes executing, rather than waiting for the response: app/page.tsxTypeScriptJavaScriptTypeScript'use client' import { useOptimistic } from 'react' import { send } from './actions' type Message = { message: string } export function Thread({ messages }: { messages: Message[] }) { const [optimisticMessages, addOptimisticMessage] = useOptimistic< Message[], string >(messages, (state, newMessage) => [...state, { message: newMessage }]) const formAction = async (formData: FormData) => { const message = formData.get('message') as string addOptimisticMessage(message) await send(message) } return ( <div> {optimisticMessages.map((m, i) => ( <div key={i}>{m.message}</div> ))} <form action={formAction}> <input type=\"text\" name=\"message\" /> <button type=\"submit\">Send</button> </form> </div> ) } Nested form elements You can call Server Actions in elements nested inside <form> such as <button>, <input type=\"submit\">, and <input type=\"image\">. These elements accept the formAction prop or event handlers. This is useful in cases where you want to call multiple Server Actions within a form. For example, you can create a specific <button> element for saving a post draft in addition to publishing it. See the React <form> docs for more information. Programmatic form submission You can trigger a form submission programmatically using the requestSubmit() method. For example, when the user submits a form using the ⌘ + Enter keyboard shortcut, you can listen for the onKeyDown event: app/entry.tsxTypeScriptJavaScriptTypeScript'use client' export function Entry() { const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => { if ( (e.ctrlKey || e.metaKey) && (e.key === 'Enter' || e.key === 'NumpadEnter') ) { e.preventDefault() e.currentTarget.form?.requestSubmit() } } return ( <div> <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} /> </div> ) } This will trigger the submission of the nearest <form> ancestor, which will invoke the Server Function.",
      "code": "<form>"
    },
    {
      "description": "You are currently viewing documentation for version 15 of Next.js.How to create forms with Server ActionsReact Server Actions are Server Functions that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create forms in Next.js with Server Actions. How it works React extends the HTML <form> element to allow Server Actions to be invoked with the action attribute. When used in a form, the function automatically receives the FormData object. You can then extract the data using the native FormData methods: app/invoices/page.tsxTypeScriptJavaScriptTypeScriptexport default function Page() { async function createInvoice(formData: FormData) { 'use server' const rawFormData = { customerId: formData.get('customerId'), amount: formData.get('amount'), status: formData.get('status'), } // mutate data // revalidate the cache } return <form action={createInvoice}>...</form> } Good to know: When working with forms that have multiple fields, use JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData). Note that this object will contain extra properties prefixed with $ACTION_. Passing additional arguments Outside of form fields, you can pass additional arguments to a Server Function using the JavaScript bind method. For example, to pass the userId argument to the updateUser Server Function: app/client-component.tsxTypeScriptJavaScriptTypeScript'use client' import { updateUser } from './actions' export function UserProfile({ userId }: { userId: string }) { const updateUserWithId = updateUser.bind(null, userId) return ( <form action={updateUserWithId}> <input type=\"text\" name=\"name\" /> <button type=\"submit\">Update User Name</button> </form> ) } The Server Function will receive the userId as an additional argument: app/actions.tsTypeScriptJavaScriptTypeScript'use server' export async function updateUser(userId: string, formData: FormData) {} Good to know: An alternative is to pass arguments as hidden input fields in the form (e.g. <input type=\"hidden\" name=\"userId\" value={userId} />). However, the value will be part of the rendered HTML and will not be encoded. bind works in both Server and Client Components and supports progressive enhancement. Form validation Forms can be validated on the client or server. For client-side validation, you can use the HTML attributes like required and type=\"email\" for basic validation. For server-side validation, you can use a library like zod to validate the form fields. For example: app/actions.tsTypeScriptJavaScriptTypeScript'use server' import { z } from 'zod' const schema = z.object({ email: z.string({ invalid_type_error: 'Invalid Email', }), }) export default async function createUser(formData: FormData) { const validatedFields = schema.safeParse({ email: formData.get('email'), }) // Return early if the form data is invalid if (!validatedFields.success) { return { errors: validatedFields.error.flatten().fieldErrors, } } // Mutate data } Validation errors To display validation errors or messages, turn the component that defines the <form> into a Client Component and use React useActionState. When using useActionState, the Server function signature will change to receive a new prevState or initialState parameter as its first argument. app/actions.tsTypeScriptJavaScriptTypeScript'use server' import { z } from 'zod' export async function createUser(initialState: any, formData: FormData) { const validatedFields = schema.safeParse({ email: formData.get('email'), }) // ... } You can then conditionally render the error message based on the state object. app/ui/signup.tsxTypeScriptJavaScriptTypeScript'use client' import { useActionState } from 'react' import { createUser } from '@/app/actions' const initialState = { message: '', } export function Signup() { const [state, formAction, pending] = useActionState(createUser, initialState) return ( <form action={formAction}> <label htmlFor=\"email\">Email</label> <input type=\"text\" id=\"email\" name=\"email\" required /> {/* ... */} <p aria-live=\"polite\">{state?.message}</p> <button disabled={pending}>Sign up</button> </form> ) } Pending states The useActionState hook exposes a pending boolean that can be used to show a loading indicator or disable the submit button while the action is being executed. app/ui/signup.tsxTypeScriptJavaScriptTypeScript'use client' import { useActionState } from 'react' import { createUser } from '@/app/actions' export function Signup() { const [state, formAction, pending] = useActionState(createUser, initialState) return ( <form action={formAction}> {/* Other form elements */} <button disabled={pending}>Sign up</button> </form> ) } Alternatively, you can use the useFormStatus hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending: app/ui/button.tsxTypeScriptJavaScriptTypeScript'use client' import { useFormStatus } from 'react-dom' export function SubmitButton() { const { pending } = useFormStatus() return ( <button disabled={pending} type=\"submit\"> Sign Up </button> ) } You can then nest the SubmitButton component inside the form: app/ui/signup.tsxTypeScriptJavaScriptTypeScriptimport { SubmitButton } from './button' import { createUser } from '@/app/actions' export function Signup() { return ( <form action={createUser}> {/* Other form elements */} <SubmitButton /> </form> ) } Good to know: In React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available. Optimistic updates You can use the React useOptimistic hook to optimistically update the UI before the Server Function finishes executing, rather than waiting for the response: app/page.tsxTypeScriptJavaScriptTypeScript'use client' import { useOptimistic } from 'react' import { send } from './actions' type Message = { message: string } export function Thread({ messages }: { messages: Message[] }) { const [optimisticMessages, addOptimisticMessage] = useOptimistic< Message[], string >(messages, (state, newMessage) => [...state, { message: newMessage }]) const formAction = async (formData: FormData) => { const message = formData.get('message') as string addOptimisticMessage(message) await send(message) } return ( <div> {optimisticMessages.map((m, i) => ( <div key={i}>{m.message}</div> ))} <form action={formAction}> <input type=\"text\" name=\"message\" /> <button type=\"submit\">Send</button> </form> </div> ) } Nested form elements You can call Server Actions in elements nested inside <form> such as <button>, <input type=\"submit\">, and <input type=\"image\">. These elements accept the formAction prop or event handlers. This is useful in cases where you want to call multiple Server Actions within a form. For example, you can create a specific <button> element for saving a post draft in addition to publishing it. See the React <form> docs for more information. Programmatic form submission You can trigger a form submission programmatically using the requestSubmit() method. For example, when the user submits a form using the ⌘ + Enter keyboard shortcut, you can listen for the onKeyDown event: app/entry.tsxTypeScriptJavaScriptTypeScript'use client' export function Entry() { const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => { if ( (e.ctrlKey || e.metaKey) && (e.key === 'Enter' || e.key === 'NumpadEnter') ) { e.preventDefault() e.currentTarget.form?.requestSubmit() } } return ( <div> <textarea name=\"entry\" rows={20} required onKeyDown={handleKeyDown} /> </div> ) } This will trigger the submission of the nearest <form> ancestor, which will invoke the Server Function.",
      "code": "<form>"
    },
    {
      "description": "Good to know: When working with forms that have multiple fields, use JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData). Note that this object will contain extra properties prefixed with $ACTION_.",
      "code": "Object.fromEntries()"
    }
  ],
  "links": [
    "https://nextjs.org/docs/15/app",
    "https://nextjs.org/docs/15/app/guides",
    "https://nextjs.org/docs/15/app/guides/forms",
    "https://nextjs.org/docs/15/app/guides/environment-variables",
    "https://nextjs.org/docs/15/app/guides/incremental-static-regeneration"
  ]
}