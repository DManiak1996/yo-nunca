{
  "url": "https://nextjs.org/docs/app/getting-started/linking-and-navigating",
  "title": "Linking and Navigating",
  "content": "In Next.js, routes are rendered on the server by default. This often means the client has to wait for a server response before a new route can be shown. Next.js comes with built-in prefetching, streaming, and client-side transitions ensuring navigation stays fast and responsive.\n\nThis guide explains how navigation works in Next.js and how you can optimize it for dynamic routes and slow networks.\n\nTo understand how navigation works in Next.js, it helps to be familiar with the following concepts:\n\nIn Next.js, Layouts and Pages are React Server Components by default. On initial and subsequent navigations, the Server Component Payload is generated on the server before being sent to the client.\n\nThere are two types of server rendering, based on when it happens:\n\nThe trade-off of server rendering is that the client must wait for the server to respond before the new route can be shown. Next.js addresses this delay by prefetching routes the user is likely to visit and performing client-side transitions.\n\nGood to know: HTML is also generated for the initial visit.\n\nPrefetching is the process of loading a route in the background before the user navigates to it. This makes navigation between routes in your application feel instant, because by the time a user clicks on a link, the data to render the next route is already available client side.\n\nNext.js automatically prefetches routes linked with the <Link> component when they enter the user's viewport.\n\nHow much of the route is prefetched depends on whether it's static or dynamic:\n\nBy skipping or partially prefetching dynamic routes, Next.js avoids unnecessary work on the server for routes the users may never visit. However, waiting for a server response before navigation can give the users the impression that the app is not responding.\n\nTo improve the navigation experience to dynamic routes, you can use streaming.\n\nStreaming allows the server to send parts of a dynamic route to the client as soon as they're ready, rather than waiting for the entire route to be rendered. This means users see something sooner, even if parts of the page are still loading.\n\nFor dynamic routes, it means they can be partially prefetched. That is, shared layouts and loading skeletons can be requested ahead of time.\n\nTo use streaming, create a loading.tsx in your route folder:\n\nBehind the scenes, Next.js will automatically wrap the page.tsx contents in a <Suspense> boundary. The prefetched fallback UI will be shown while the route is loading, and swapped for the actual content once ready.\n\nGood to know: You can also use <Suspense> to create loading UI for nested components.\n\nBenefits of loading.tsx:\n\nTo further improve the navigation experience, Next.js performs a client-side transition with the <Link> component.\n\nTraditionally, navigation to a server-rendered page triggers a full page load. This clears state, resets scroll position, and blocks interactivity.\n\nNext.js avoids this with client-side transitions using the <Link> component. Instead of reloading the page, it updates the content dynamically by:\n\nClient-side transitions are what makes a server-rendered apps feel like client-rendered apps. And when paired with prefetching and streaming, it enables fast transitions, even for dynamic routes.\n\nThese Next.js optimizations make navigation fast and responsive. However, under certain conditions, transitions can still feel slow. Here are some common causes and how to improve the user experience:\n\nWhen navigating to a dynamic route, the client must wait for the server response before showing the result. This can give the users the impression that the app is not responding.\n\nWe recommend adding loading.tsx to dynamic routes to enable partial prefetching, trigger immediate navigation, and display a loading UI while the route renders.\n\nGood to know: In development mode, you can use the Next.js Devtools to identify if the route is static or dynamic. See devIndicators for more information.\n\nIf a dynamic segment could be prerendered but isn't because it's missing generateStaticParams, the route will fallback to dynamic rendering at request time.\n\nEnsure the route is statically generated at build time by adding generateStaticParams:\n\nOn slow or unstable networks, prefetching may not finish before the user clicks a link. This can affect both static and dynamic routes. In these cases, the loading.js fallback may not appear immediately because it hasn't been prefetched yet.\n\nTo improve perceived performance, you can use the useLinkStatus hook to show immediate feedback while the transition is in progress.\n\nYou can \"debounce\" the hint by adding an initial animation delay (e.g. 100ms) and starting as invisible (e.g. opacity: 0). This means the loading indicator will only be shown if the navigation takes longer than the specified delay. See the useLinkStatus reference for a CSS example.\n\nGood to know: You can use other visual feedback patterns like a progress bar. View an example here.\n\nYou can opt out of prefetching by setting the prefetch prop to false on the <Link> component. This is useful to avoid unnecessary usage of resources when rendering large lists of links (e.g. an infinite scroll table).\n\nHowever, disabling prefetching comes with trade-offs:\n\nTo reduce resource usage without fully disabling prefetch, you can prefetch only on hover. This limits prefetching to routes the user is more likely to visit, rather than all links in the viewport.\n\n<Link> is a Client Component and must be hydrated before it can prefetch routes. On the initial visit, large JavaScript bundles can delay hydration, preventing prefetching from starting right away.\n\nReact mitigates this with Selective Hydration and you can further improve this by:\n\nNext.js allows you to use the native window.history.pushState and window.history.replaceState methods to update the browser's history stack without reloading the page.\n\npushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams.\n\nUse it to add a new entry to the browser's history stack. The user can navigate back to the previous state. For example, to sort a list of products:\n\nUse it to replace the current entry on the browser's history stack. The user is not able to navigate back to the previous state. For example, to switch the application's locale:",
  "headings": [
    {
      "level": "h1",
      "text": "Linking and Navigating",
      "id": ""
    },
    {
      "level": "h2",
      "text": "How navigation works",
      "id": "how-navigation-works"
    },
    {
      "level": "h3",
      "text": "Server Rendering",
      "id": "server-rendering"
    },
    {
      "level": "h3",
      "text": "Prefetching",
      "id": "prefetching"
    },
    {
      "level": "h3",
      "text": "Streaming",
      "id": "streaming"
    },
    {
      "level": "h3",
      "text": "Client-side transitions",
      "id": "client-side-transitions"
    },
    {
      "level": "h2",
      "text": "What can make transitions slow?",
      "id": "what-can-make-transitions-slow"
    },
    {
      "level": "h3",
      "text": "Dynamic routes without loading.tsx",
      "id": "dynamic-routes-without-loadingtsx"
    },
    {
      "level": "h3",
      "text": "Dynamic segments without generateStaticParams",
      "id": "dynamic-segments-without-generatestaticparams"
    },
    {
      "level": "h3",
      "text": "Slow networks",
      "id": "slow-networks"
    },
    {
      "level": "h3",
      "text": "Disabling prefetching",
      "id": "disabling-prefetching"
    },
    {
      "level": "h3",
      "text": "Hydration not completed",
      "id": "hydration-not-completed"
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "Native History API",
      "id": "native-history-api"
    },
    {
      "level": "h4",
      "text": "window.history.pushState",
      "id": "windowhistorypushstate"
    },
    {
      "level": "h4",
      "text": "window.history.replaceState",
      "id": "windowhistoryreplacestate"
    },
    {
      "level": "h2",
      "text": "Next Steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "Link Component",
      "id": ""
    },
    {
      "level": "h3",
      "text": "loading.js",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Prefetching",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "import Link from 'next/link'\n \nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <body>\n        <nav>\n          {/* Prefetched when the link is hovered or enters the viewport */}\n          <Link href=\"/blog\">Blog</Link>\n          {/* No prefetching */}\n          <a href=\"/contact\">Contact</a>\n        </nav>\n        {children}\n      </body>\n    </html>\n  )\n}",
      "language": "python"
    },
    {
      "code": "export default function Loading() {\n  // Add fallback UI that will be shown while the route is loading.\n  return <LoadingSkeleton />\n}",
      "language": "unknown"
    },
    {
      "code": "export default function Loading() {\n  return <LoadingSkeleton />\n}",
      "language": "unknown"
    },
    {
      "code": "export async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  return posts.map((post) => ({\n    slug: post.slug,\n  }))\n}\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  // ...\n}",
      "language": "javascript"
    },
    {
      "code": "'use client'\n \nimport { useLinkStatus } from 'next/link'\n \nexport default function LoadingIndicator() {\n  const { pending } = useLinkStatus()\n  return (\n    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />\n  )\n}",
      "language": "python"
    },
    {
      "code": "<Link prefetch={false} href=\"/blog\">\n  Blog\n</Link>",
      "language": "unknown"
    },
    {
      "code": "'use client'\n \nimport Link from 'next/link'\nimport { useState } from 'react'\n \nfunction HoverPrefetchLink({\n  href,\n  children,\n}: {\n  href: string\n  children: React.ReactNode\n}) {\n  const [active, setActive] = useState(false)\n \n  return (\n    <Link\n      href={href}\n      prefetch={active ? null : false}\n      onMouseEnter={() => setActive(true)}\n    >\n      {children}\n    </Link>\n  )\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nimport { useSearchParams } from 'next/navigation'\n \nexport default function SortProducts() {\n  const searchParams = useSearchParams()\n \n  function updateSorting(sortOrder: string) {\n    const params = new URLSearchParams(searchParams.toString())\n    params.set('sort', sortOrder)\n    window.history.pushState(null, '', `?${params.toString()}`)\n  }\n \n  return (\n    <>\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\n    </>\n  )\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nimport { usePathname } from 'next/navigation'\n \nexport function LocaleSwitcher() {\n  const pathname = usePathname()\n \n  function switchLocale(locale: string) {\n    // e.g. '/en/about' or '/fr/contact'\n    const newPath = `/${locale}${pathname}`\n    window.history.replaceState(null, '', newPath)\n  }\n \n  return (\n    <>\n      <button onClick={() => switchLocale('en')}>English</button>\n      <button onClick={() => switchLocale('fr')}>French</button>\n    </>\n  )\n}",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://nextjs.org/docs/app",
    "https://nextjs.org/docs/app/getting-started",
    "https://nextjs.org/docs/app/getting-started/linking-and-navigating",
    "https://nextjs.org/docs/app/getting-started/layouts-and-pages",
    "https://nextjs.org/docs/app/getting-started/server-and-client-components",
    "https://nextjs.org/docs/app/getting-started/caching-and-revalidating",
    "https://nextjs.org/docs/app/api-reference/components/link",
    "https://nextjs.org/docs/app/api-reference/file-conventions/loading",
    "https://nextjs.org/docs/app/api-reference/config/next-config-js/devIndicators",
    "https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes",
    "https://nextjs.org/docs/app/api-reference/functions/generate-static-params",
    "https://nextjs.org/docs/app/api-reference/functions/use-link-status",
    "https://nextjs.org/docs/app/guides/package-bundling",
    "https://nextjs.org/docs/app/api-reference/functions/use-pathname",
    "https://nextjs.org/docs/app/api-reference/functions/use-search-params",
    "https://nextjs.org/docs/app/guides/prefetching"
  ]
}