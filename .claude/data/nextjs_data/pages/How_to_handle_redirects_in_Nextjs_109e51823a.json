{
  "url": "https://nextjs.org/docs/app/guides/redirecting",
  "title": "How to handle redirects in Next.js",
  "content": "There are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects.\n\nThe redirect function allows you to redirect the user to another URL. You can call redirect in Server Components, Route Handlers, and Server Actions.\n\nredirect is often used after a mutation or event. For example, creating a post:\n\nSee the redirect API reference for more information.\n\nThe permanentRedirect function allows you to permanently redirect the user to another URL. You can call permanentRedirect in Server Components, Route Handlers, and Server Actions.\n\npermanentRedirect is often used after a mutation or event that changes an entity's canonical URL, such as updating a user's profile URL after they change their username:\n\nSee the permanentRedirect API reference for more information.\n\nIf you need to redirect inside an event handler in a Client Component, you can use the push method from the useRouter hook. For example:\n\nSee the useRouter API reference for more information.\n\nThe redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time.\n\nredirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request.\n\nTo use redirects, add the option to your next.config.js file:\n\nSee the redirects API reference for more information.\n\nProxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects.\n\nFor example, to redirect the user to a /login page if they are not authenticated:\n\nSee the Proxy documentation for more information.\n\nTo manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application.\n\nTo do this, you'll need to consider:\n\nNext.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below.\n\nA redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file.\n\nConsider the following data structure:\n\nIn Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request:\n\nReading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance:\n\nConsidering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter.\n\nIf it does, forward the request to a Route Handler which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request.\n\nThen, in the Route Handler:",
  "headings": [
    {
      "level": "h1",
      "text": "How to handle redirects in Next.js",
      "id": ""
    },
    {
      "level": "h2",
      "text": "redirect function",
      "id": "redirect-function"
    },
    {
      "level": "h2",
      "text": "permanentRedirect function",
      "id": "permanentredirect-function"
    },
    {
      "level": "h2",
      "text": "useRouter() hook",
      "id": "userouter-hook"
    },
    {
      "level": "h2",
      "text": "redirects in next.config.js",
      "id": "redirects-in-nextconfigjs"
    },
    {
      "level": "h2",
      "text": "NextResponse.redirect in Proxy",
      "id": "nextresponseredirect-in-proxy"
    },
    {
      "level": "h2",
      "text": "Managing redirects at scale (advanced)",
      "id": "managing-redirects-at-scale-advanced"
    },
    {
      "level": "h3",
      "text": "1. Creating and storing a redirect map",
      "id": "1-creating-and-storing-a-redirect-map"
    },
    {
      "level": "h3",
      "text": "2. Optimizing data lookup performance",
      "id": "2-optimizing-data-lookup-performance"
    },
    {
      "level": "h2",
      "text": "Next Steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "redirect",
      "id": ""
    },
    {
      "level": "h3",
      "text": "permanentRedirect",
      "id": ""
    },
    {
      "level": "h3",
      "text": "proxy.js",
      "id": ""
    },
    {
      "level": "h3",
      "text": "redirects",
      "id": ""
    }
  ],
  "code_samples": [
    {
      "code": "'use server'\n \nimport { redirect } from 'next/navigation'\nimport { revalidatePath } from 'next/cache'\n \nexport async function createPost(id: string) {\n  try {\n    // Call database\n  } catch (error) {\n    // Handle errors\n  }\n \n  revalidatePath('/posts') // Update cached posts\n  redirect(`/post/${id}`) // Navigate to the new post page\n}",
      "language": "python"
    },
    {
      "code": "'use server'\n \nimport { permanentRedirect } from 'next/navigation'\nimport { revalidateTag } from 'next/cache'\n \nexport async function updateUsername(username: string, formData: FormData) {\n  try {\n    // Call database\n  } catch (error) {\n    // Handle errors\n  }\n \n  revalidateTag('username') // Update all references to the username\n  permanentRedirect(`/profile/${username}`) // Navigate to the new user profile\n}",
      "language": "python"
    },
    {
      "code": "'use client'\n \nimport { useRouter } from 'next/navigation'\n \nexport default function Page() {\n  const router = useRouter()\n \n  return (\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\n      Dashboard\n    </button>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  async redirects() {\n    return [\n      // Basic redirect\n      {\n        source: '/about',\n        destination: '/',\n        permanent: true,\n      },\n      // Wildcard path matching\n      {\n        source: '/blog/:slug',\n        destination: '/news/:slug',\n        permanent: true,\n      },\n    ]\n  },\n}\n \nexport default nextConfig",
      "language": "python"
    },
    {
      "code": "import { NextResponse, NextRequest } from 'next/server'\nimport { authenticate } from 'auth-provider'\n \nexport function proxy(request: NextRequest) {\n  const isAuthenticated = authenticate(request)\n \n  // If the user is authenticated, continue as normal\n  if (isAuthenticated) {\n    return NextResponse.next()\n  }\n \n  // Redirect to login page if not authenticated\n  return NextResponse.redirect(new URL('/login', request.url))\n}\n \nexport const config = {\n  matcher: '/dashboard/:path*',\n}",
      "language": "python"
    },
    {
      "code": "{\n  \"/old\": {\n    \"destination\": \"/new\",\n    \"permanent\": true\n  },\n  \"/blog/post-old\": {\n    \"destination\": \"/blog/post-new\",\n    \"permanent\": true\n  }\n}",
      "language": "unknown"
    },
    {
      "code": "import { NextResponse, NextRequest } from 'next/server'\nimport { get } from '@vercel/edge-config'\n \ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n \nexport async function proxy(request: NextRequest) {\n  const pathname = request.nextUrl.pathname\n  const redirectData = await get(pathname)\n \n  if (redirectData && typeof redirectData === 'string') {\n    const redirectEntry: RedirectEntry = JSON.parse(redirectData)\n    const statusCode = redirectEntry.permanent ? 308 : 307\n    return NextResponse.redirect(redirectEntry.destination, statusCode)\n  }\n \n  // No redirect found, continue without redirecting\n  return NextResponse.next()\n}",
      "language": "python"
    },
    {
      "code": "import { NextResponse, NextRequest } from 'next/server'\nimport { ScalableBloomFilter } from 'bloom-filters'\nimport GeneratedBloomFilter from './redirects/bloom-filter.json'\n \ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n \n// Initialize bloom filter from a generated JSON file\nconst bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any)\n \nexport async function proxy(request: NextRequest) {\n  // Get the path for the incoming request\n  const pathname = request.nextUrl.pathname\n \n  // Check if the path is in the bloom filter\n  if (bloomFilter.has(pathname)) {\n    // Forward the pathname to the Route Handler\n    const api = new URL(\n      `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`,\n      request.nextUrl.origin\n    )\n \n    try {\n      // Fetch redirect data from the Route Handler\n      const redirectData = await fetch(api)\n \n      if (redirectData.ok) {\n        const redirectEntry: RedirectEntry | undefined =\n          await redirectData.json()\n \n        if (redirectEntry) {\n          // Determine the status code\n          const statusCode = redirectEntry.permanent ? 308 : 307\n \n          // Redirect to the destination\n          return NextResponse.redirect(redirectEntry.destination, statusCode)\n        }\n      }\n    } catch (error) {\n      console.error(error)\n    }\n  }\n \n  // No redirect found, continue the request without redirecting\n  return NextResponse.next()\n}",
      "language": "python"
    },
    {
      "code": "import { NextRequest, NextResponse } from 'next/server'\nimport redirects from '@/app/redirects/redirects.json'\n \ntype RedirectEntry = {\n  destination: string\n  permanent: boolean\n}\n \nexport function GET(request: NextRequest) {\n  const pathname = request.nextUrl.searchParams.get('pathname')\n  if (!pathname) {\n    return new Response('Bad Request', { status: 400 })\n  }\n \n  // Get the redirect entry from the redirects.json file\n  const redirect = (redirects as Record<string, RedirectEntry>)[pathname]\n \n  // Account for bloom filter false positives\n  if (!redirect) {\n    return new Response('No redirect', { status: 400 })\n  }\n \n  // Return the redirect entry\n  return NextResponse.json(redirect)\n}",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "App RouterGuidesRedirectingCopy pageHow to handle redirects in Next.jsThere are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects. APIPurposeWhereStatus CoderedirectRedirect user after a mutation or eventServer Components, Server Actions, Route Handlers307 (Temporary) or 303 (Server Action)permanentRedirectRedirect user after a mutation or eventServer Components, Server Actions, Route Handlers308 (Permanent)useRouterPerform a client-side navigationEvent Handlers in Client ComponentsN/Aredirects in next.config.jsRedirect an incoming request based on a pathnext.config.js file307 (Temporary) or 308 (Permanent)NextResponse.redirectRedirect an incoming request based on a conditionProxyAny redirect function The redirect function allows you to redirect the user to another URL. You can call redirect in Server Components, Route Handlers, and Server Actions.redirect is often used after a mutation or event. For example, creating a post:app/actions.tsTypeScriptJavaScriptTypeScript'use server' import { redirect } from 'next/navigation' import { revalidatePath } from 'next/cache' export async function createPost(id: string) { try { // Call database } catch (error) { // Handle errors } revalidatePath('/posts') // Update cached posts redirect(`/post/${id}`) // Navigate to the new post page } Good to know: redirect returns a 307 (Temporary Redirect) status code by default. When used in a Server Action, it returns a 303 (See Other), which is commonly used for redirecting to a success page as a result of a POST request. redirect throws an error so it should be called outside the try block when using try/catch statements. redirect can be called in Client Components during the rendering process but not in event handlers. You can use the useRouter hook instead. redirect also accepts absolute URLs and can be used to redirect to external links. If you'd like to redirect before the render process, use next.config.js or Proxy. See the redirect API reference for more information.permanentRedirect function The permanentRedirect function allows you to permanently redirect the user to another URL. You can call permanentRedirect in Server Components, Route Handlers, and Server Actions.permanentRedirect is often used after a mutation or event that changes an entity's canonical URL, such as updating a user's profile URL after they change their username:app/actions.tsTypeScriptJavaScriptTypeScript'use server' import { permanentRedirect } from 'next/navigation' import { revalidateTag } from 'next/cache' export async function updateUsername(username: string, formData: FormData) { try { // Call database } catch (error) { // Handle errors } revalidateTag('username') // Update all references to the username permanentRedirect(`/profile/${username}`) // Navigate to the new user profile } Good to know: permanentRedirect returns a 308 (permanent redirect) status code by default. permanentRedirect also accepts absolute URLs and can be used to redirect to external links. If you'd like to redirect before the render process, use next.config.js or Proxy. See the permanentRedirect API reference for more information. useRouter() hook If you need to redirect inside an event handler in a Client Component, you can use the push method from the useRouter hook. For example:app/page.tsxTypeScriptJavaScriptTypeScript'use client' import { useRouter } from 'next/navigation' export default function Page() { const router = useRouter() return ( <button type=\"button\" onClick={() => router.push('/dashboard')}> Dashboard </button> ) } Good to know: If you don't need to programmatically navigate a user, you should use a <Link> component. See the useRouter API reference for more information. redirects in next.config.js The redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time. redirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request. To use redirects, add the option to your next.config.js file: next.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next' const nextConfig: NextConfig = { async redirects() { return [ // Basic redirect { source: '/about', destination: '/', permanent: true, }, // Wildcard path matching { source: '/blog/:slug', destination: '/news/:slug', permanent: true, }, ] }, } export default nextConfig See the redirects API reference for more information. Good to know: redirects can return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with the permanent option. redirects may have a limit on platforms. For example, on Vercel, there's a limit of 1,024 redirects. To manage a large number of redirects (1000+), consider creating a custom solution using Proxy. See managing redirects at scale for more. redirects runs before Proxy. NextResponse.redirect in Proxy Proxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects. For example, to redirect the user to a /login page if they are not authenticated: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { authenticate } from 'auth-provider' export function proxy(request: NextRequest) { const isAuthenticated = authenticate(request) // If the user is authenticated, continue as normal if (isAuthenticated) { return NextResponse.next() } // Redirect to login page if not authenticated return NextResponse.redirect(new URL('/login', request.url)) } export const config = { matcher: '/dashboard/:path*', } Good to know: Proxy runs after redirects in next.config.js and before rendering. See the Proxy documentation for more information. Managing redirects at scale (advanced) To manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application. To do this, you'll need to consider: Creating and storing a redirect map. Optimizing data lookup performance. Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below. 1. Creating and storing a redirect map A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file. Consider the following data structure: { \"/old\": { \"destination\": \"/new\", \"permanent\": true }, \"/blog/post-old\": { \"destination\": \"/blog/post-new\", \"permanent\": true } } In Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { get } from '@vercel/edge-config' type RedirectEntry = { destination: string permanent: boolean } export async function proxy(request: NextRequest) { const pathname = request.nextUrl.pathname const redirectData = await get(pathname) if (redirectData && typeof redirectData === 'string') { const redirectEntry: RedirectEntry = JSON.parse(redirectData) const statusCode = redirectEntry.permanent ? 308 : 307 return NextResponse.redirect(redirectEntry.destination, statusCode) } // No redirect found, continue without redirecting return NextResponse.next() } 2. Optimizing data lookup performance Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance: Use a database that is optimized for fast reads Use a data lookup strategy such as a Bloom filter to efficiently check if a redirect exists before reading the larger redirects file or database. Considering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter. If it does, forward the request to a Route Handler which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request. proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { ScalableBloomFilter } from 'bloom-filters' import GeneratedBloomFilter from './redirects/bloom-filter.json' type RedirectEntry = { destination: string permanent: boolean } // Initialize bloom filter from a generated JSON file const bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any) export async function proxy(request: NextRequest) { // Get the path for the incoming request const pathname = request.nextUrl.pathname // Check if the path is in the bloom filter if (bloomFilter.has(pathname)) { // Forward the pathname to the Route Handler const api = new URL( `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`, request.nextUrl.origin ) try { // Fetch redirect data from the Route Handler const redirectData = await fetch(api) if (redirectData.ok) { const redirectEntry: RedirectEntry | undefined = await redirectData.json() if (redirectEntry) { // Determine the status code const statusCode = redirectEntry.permanent ? 308 : 307 // Redirect to the destination return NextResponse.redirect(redirectEntry.destination, statusCode) } } } catch (error) { console.error(error) } } // No redirect found, continue the request without redirecting return NextResponse.next() } Then, in the Route Handler:app/api/redirects/route.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server' import redirects from '@/app/redirects/redirects.json' type RedirectEntry = { destination: string permanent: boolean } export function GET(request: NextRequest) { const pathname = request.nextUrl.searchParams.get('pathname') if (!pathname) { return new Response('Bad Request', { status: 400 }) } // Get the redirect entry from the redirects.json file const redirect = (redirects as Record<string, RedirectEntry>)[pathname] // Account for bloom filter false positives if (!redirect) { return new Response('No redirect', { status: 400 }) } // Return the redirect entry return NextResponse.json(redirect) } Good to know: To generate a bloom filter, you can use a library like bloom-filters. You should validate requests made to your Route Handler to prevent malicious requests. Next StepsredirectAPI Reference for the redirect function.permanentRedirectAPI Reference for the permanentRedirect function.proxy.jsAPI reference for the proxy.js file.redirectsAdd redirects to your Next.js app.",
      "code": "redirect"
    },
    {
      "description": "How to handle redirects in Next.jsThere are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects. APIPurposeWhereStatus CoderedirectRedirect user after a mutation or eventServer Components, Server Actions, Route Handlers307 (Temporary) or 303 (Server Action)permanentRedirectRedirect user after a mutation or eventServer Components, Server Actions, Route Handlers308 (Permanent)useRouterPerform a client-side navigationEvent Handlers in Client ComponentsN/Aredirects in next.config.jsRedirect an incoming request based on a pathnext.config.js file307 (Temporary) or 308 (Permanent)NextResponse.redirectRedirect an incoming request based on a conditionProxyAny redirect function The redirect function allows you to redirect the user to another URL. You can call redirect in Server Components, Route Handlers, and Server Actions.redirect is often used after a mutation or event. For example, creating a post:app/actions.tsTypeScriptJavaScriptTypeScript'use server' import { redirect } from 'next/navigation' import { revalidatePath } from 'next/cache' export async function createPost(id: string) { try { // Call database } catch (error) { // Handle errors } revalidatePath('/posts') // Update cached posts redirect(`/post/${id}`) // Navigate to the new post page } Good to know: redirect returns a 307 (Temporary Redirect) status code by default. When used in a Server Action, it returns a 303 (See Other), which is commonly used for redirecting to a success page as a result of a POST request. redirect throws an error so it should be called outside the try block when using try/catch statements. redirect can be called in Client Components during the rendering process but not in event handlers. You can use the useRouter hook instead. redirect also accepts absolute URLs and can be used to redirect to external links. If you'd like to redirect before the render process, use next.config.js or Proxy. See the redirect API reference for more information.permanentRedirect function The permanentRedirect function allows you to permanently redirect the user to another URL. You can call permanentRedirect in Server Components, Route Handlers, and Server Actions.permanentRedirect is often used after a mutation or event that changes an entity's canonical URL, such as updating a user's profile URL after they change their username:app/actions.tsTypeScriptJavaScriptTypeScript'use server' import { permanentRedirect } from 'next/navigation' import { revalidateTag } from 'next/cache' export async function updateUsername(username: string, formData: FormData) { try { // Call database } catch (error) { // Handle errors } revalidateTag('username') // Update all references to the username permanentRedirect(`/profile/${username}`) // Navigate to the new user profile } Good to know: permanentRedirect returns a 308 (permanent redirect) status code by default. permanentRedirect also accepts absolute URLs and can be used to redirect to external links. If you'd like to redirect before the render process, use next.config.js or Proxy. See the permanentRedirect API reference for more information. useRouter() hook If you need to redirect inside an event handler in a Client Component, you can use the push method from the useRouter hook. For example:app/page.tsxTypeScriptJavaScriptTypeScript'use client' import { useRouter } from 'next/navigation' export default function Page() { const router = useRouter() return ( <button type=\"button\" onClick={() => router.push('/dashboard')}> Dashboard </button> ) } Good to know: If you don't need to programmatically navigate a user, you should use a <Link> component. See the useRouter API reference for more information. redirects in next.config.js The redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time. redirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request. To use redirects, add the option to your next.config.js file: next.config.tsTypeScriptJavaScriptTypeScriptimport type { NextConfig } from 'next' const nextConfig: NextConfig = { async redirects() { return [ // Basic redirect { source: '/about', destination: '/', permanent: true, }, // Wildcard path matching { source: '/blog/:slug', destination: '/news/:slug', permanent: true, }, ] }, } export default nextConfig See the redirects API reference for more information. Good to know: redirects can return a 307 (Temporary Redirect) or 308 (Permanent Redirect) status code with the permanent option. redirects may have a limit on platforms. For example, on Vercel, there's a limit of 1,024 redirects. To manage a large number of redirects (1000+), consider creating a custom solution using Proxy. See managing redirects at scale for more. redirects runs before Proxy. NextResponse.redirect in Proxy Proxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects. For example, to redirect the user to a /login page if they are not authenticated: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { authenticate } from 'auth-provider' export function proxy(request: NextRequest) { const isAuthenticated = authenticate(request) // If the user is authenticated, continue as normal if (isAuthenticated) { return NextResponse.next() } // Redirect to login page if not authenticated return NextResponse.redirect(new URL('/login', request.url)) } export const config = { matcher: '/dashboard/:path*', } Good to know: Proxy runs after redirects in next.config.js and before rendering. See the Proxy documentation for more information. Managing redirects at scale (advanced) To manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application. To do this, you'll need to consider: Creating and storing a redirect map. Optimizing data lookup performance. Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below. 1. Creating and storing a redirect map A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file. Consider the following data structure: { \"/old\": { \"destination\": \"/new\", \"permanent\": true }, \"/blog/post-old\": { \"destination\": \"/blog/post-new\", \"permanent\": true } } In Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { get } from '@vercel/edge-config' type RedirectEntry = { destination: string permanent: boolean } export async function proxy(request: NextRequest) { const pathname = request.nextUrl.pathname const redirectData = await get(pathname) if (redirectData && typeof redirectData === 'string') { const redirectEntry: RedirectEntry = JSON.parse(redirectData) const statusCode = redirectEntry.permanent ? 308 : 307 return NextResponse.redirect(redirectEntry.destination, statusCode) } // No redirect found, continue without redirecting return NextResponse.next() } 2. Optimizing data lookup performance Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance: Use a database that is optimized for fast reads Use a data lookup strategy such as a Bloom filter to efficiently check if a redirect exists before reading the larger redirects file or database. Considering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter. If it does, forward the request to a Route Handler which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request. proxy.tsTypeScriptJavaScriptTypeScriptimport { NextResponse, NextRequest } from 'next/server' import { ScalableBloomFilter } from 'bloom-filters' import GeneratedBloomFilter from './redirects/bloom-filter.json' type RedirectEntry = { destination: string permanent: boolean } // Initialize bloom filter from a generated JSON file const bloomFilter = ScalableBloomFilter.fromJSON(GeneratedBloomFilter as any) export async function proxy(request: NextRequest) { // Get the path for the incoming request const pathname = request.nextUrl.pathname // Check if the path is in the bloom filter if (bloomFilter.has(pathname)) { // Forward the pathname to the Route Handler const api = new URL( `/api/redirects?pathname=${encodeURIComponent(request.nextUrl.pathname)}`, request.nextUrl.origin ) try { // Fetch redirect data from the Route Handler const redirectData = await fetch(api) if (redirectData.ok) { const redirectEntry: RedirectEntry | undefined = await redirectData.json() if (redirectEntry) { // Determine the status code const statusCode = redirectEntry.permanent ? 308 : 307 // Redirect to the destination return NextResponse.redirect(redirectEntry.destination, statusCode) } } } catch (error) { console.error(error) } } // No redirect found, continue the request without redirecting return NextResponse.next() } Then, in the Route Handler:app/api/redirects/route.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server' import redirects from '@/app/redirects/redirects.json' type RedirectEntry = { destination: string permanent: boolean } export function GET(request: NextRequest) { const pathname = request.nextUrl.searchParams.get('pathname') if (!pathname) { return new Response('Bad Request', { status: 400 }) } // Get the redirect entry from the redirects.json file const redirect = (redirects as Record<string, RedirectEntry>)[pathname] // Account for bloom filter false positives if (!redirect) { return new Response('No redirect', { status: 400 }) } // Return the redirect entry return NextResponse.json(redirect) } Good to know: To generate a bloom filter, you can use a library like bloom-filters. You should validate requests made to your Route Handler to prevent malicious requests.",
      "code": "redirect"
    },
    {
      "description": "If you need to redirect inside an event handler in a Client Component, you can use the push method from the useRouter hook. For example:",
      "code": "push"
    },
    {
      "description": "Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below.",
      "code": "{\n  \"/old\": {\n    \"destination\": \"/new\",\n    \"permanent\": true\n  },\n  \"/blog/post-old\": {\n    \"destination\": \"/blog/post-new\",\n    \"permanent\": true\n  }\n}"
    }
  ],
  "links": [
    "https://nextjs.org/docs/app",
    "https://nextjs.org/docs/app/guides",
    "https://nextjs.org/docs/app/guides/redirecting",
    "https://nextjs.org/docs/app/getting-started/server-and-client-components",
    "https://nextjs.org/docs/app/api-reference/file-conventions/route",
    "https://nextjs.org/docs/app/getting-started/updating-data",
    "https://nextjs.org/docs/app/api-reference/functions/redirect",
    "https://nextjs.org/docs/app/api-reference/functions/permanentRedirect",
    "https://nextjs.org/docs/app/api-reference/components/link",
    "https://nextjs.org/docs/app/api-reference/functions/use-router",
    "https://nextjs.org/docs/app/api-reference/config/next-config-js/redirects",
    "https://nextjs.org/docs/app/api-reference/file-conventions/proxy",
    "https://nextjs.org/docs/app/guides/progressive-web-apps",
    "https://nextjs.org/docs/app/guides/sass"
  ]
}