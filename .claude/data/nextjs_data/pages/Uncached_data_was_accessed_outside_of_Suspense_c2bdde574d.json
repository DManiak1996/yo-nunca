{
  "url": "https://nextjs.org/docs/messages/blocking-route",
  "title": "Uncached data was accessed outside of `<Suspense>`",
  "content": "When the cacheComponents feature is enabled, Next.js expects a parent Suspense boundary around any component that awaits data that should be accessed on every user request. The purpose of this requirement is so that Next.js can provide a useful fallback while this data is accessed and rendered.\n\nWhile some data is inherently only available when a user request is being handled, such as request headers, Next.js assumes that by default any asynchronous data is expected to be accessed each time a user request is being handled unless you specifically cache it using \"use cache\".\n\nThe proper fix for this specific error depends on what data you are accessing and how you want your Next.js app to behave.\n\nWhen you access data using fetch, a database client, or any other module which does asynchronous IO, Next.js interprets your intent as expecting the data to load on every user request.\n\nIf you are expecting this data to be used while fully or partially prerendering a page you must cache is using \"use cache\".\n\nIf this data should be accessed on every user request you must provide a fallback UI using Suspense from React. Where you put this Suspense boundary in your application should be informed by the kind of fallback UI you want to render. It can be immediately above the component accessing this data or even in your Root Layout.\n\nIf you are accessing request headers using headers(), cookies(), or draftMode(). Consider whether you can move the use of these APIs deeper into your existing component tree.\n\nAlternatively you can add a Suspense boundary above the component that is accessing Request headers.\n\nLayout params, and Page params and searchParams props are promises. If you await them in the Layout or Page component you might be accessing these props higher than is actually required. Try passing these props to deeper components as a promise and awaiting them closer to where the actual param or searchParam is required\n\nAlternatively you can add a Suspense boundary above the component that is accessing params or searchParams so Next.js understands what UI should be used when while waiting for this request data to be accessed.\n\n\"use cache\" allows you to describe a cacheLife() that might be too short to be practical to prerender. The utility of doing this is that it can still describe a non-zero caching time for the client router cache to reuse the cache entry in the browser and it can also be useful for protecting upstream APIs while experiencing high request traffic.\n\nIf you expected the \"use cache\" entry to be prerenderable try describing a slightly longer cacheLife().\n\nAlternatively you can add a Suspense boundary above the component that is accessing this short-lived cached data so Next.js understands what UI should be used while accessing this data on a user request.",
  "headings": [
    {
      "level": "h1",
      "text": "Uncached data was accessed outside of `<Suspense>`",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Why This Error Occurred",
      "id": "why-this-error-occurred"
    },
    {
      "level": "h2",
      "text": "Possible Ways to Fix It",
      "id": "possible-ways-to-fix-it"
    },
    {
      "level": "h3",
      "text": "Accessing Data",
      "id": "accessing-data"
    },
    {
      "level": "h3",
      "text": "Headers",
      "id": "headers"
    },
    {
      "level": "h3",
      "text": "Params and SearchParams",
      "id": "params-and-searchparams"
    },
    {
      "level": "h3",
      "text": "Short-lived Caches",
      "id": "short-lived-caches"
    },
    {
      "level": "h2",
      "text": "Useful Links",
      "id": "useful-links"
    }
  ],
  "code_samples": [
    {
      "code": "async function getRecentArticles() {\n  return db.query(...)\n}\n \nexport default async function Page() {\n  const articles = await getRecentArticles(token);\n  return <ArticleList articles={articles}>\n}",
      "language": "javascript"
    },
    {
      "code": "import { cacheTag, cacheLife } from 'next/cache'\n \nasync function getRecentArticles() {\n  \"use cache\"\n  // This cache can be revalidated by webhook or server action\n  // when you call revalidateTag(\"articles\")\n  cacheTag(\"articles\")\n  // This cache will revalidate after an hour even if no explicit\n  // revalidate instruction was received\n  cacheLife('hours')\n  return db.query(...)\n}\n \nexport default async function Page() {\n  const articles = await getRecentArticles(token);\n  return <ArticleList articles={articles}>\n}",
      "language": "python"
    },
    {
      "code": "async function getLatestTransactions() {\n  return db.query(...)\n}\n \nexport default async function Page() {\n  const transactions = await getLatestTransactions(token);\n  return <TransactionList transactions={transactions}>\n}",
      "language": "javascript"
    },
    {
      "code": "import { Suspense } from 'react'\n \nasync function TransactionList() {\n  const transactions = await db.query(...)\n  return ...\n}\n \nfunction TransactionSkeleton() {\n  return <ul>...</ul>\n}\n \nexport default async function Page() {\n  return (\n    <Suspense fallback={<TransactionSkeleton />}>\n      <TransactionList/>\n    </Suspense>\n  )\n}",
      "language": "python"
    },
    {
      "code": "export async function Inbox({ token }) {\n  const email = await getEmail(token)\n  return (\n    <ul>\n      {email.map((e) => (\n        <EmailRow key={e.id} />\n      ))}\n    </ul>\n  )\n}",
      "language": "javascript"
    },
    {
      "code": "import { cookies } from 'next/headers'\n \nimport { Inbox } from './inbox'\n \nexport default async function Page() {\n  const token = (await cookies()).get('token')\n  return (\n    <Suspense fallback=\"loading your inbox...\">\n      <Inbox token={token}>\n    </Suspense>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import { cookies } from 'next/headers'\n \nexport async function Inbox() {\n  const token = (await cookies()).get('token')\n  const email = await getEmail(token)\n  return (\n    <ul>\n      {email.map((e) => (\n        <EmailRow key={e.id} />\n      ))}\n    </ul>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import { Inbox } from './inbox'\n \nexport default async function Page() {\n  return (\n    <Suspense fallback=\"loading your inbox...\">\n      <Inbox>\n    </Suspense>\n  )\n}",
      "language": "python"
    },
    {
      "code": "export async function Map({ lat, lng }) {\n  const mapData = await fetch(`https://...?lat=${lat}&lng=${lng}`)\n  return drawMap(mapData)\n}",
      "language": "javascript"
    },
    {
      "code": "import { cookies } from 'next/headers'\n \nimport { Map } from './map'\n \nexport default async function Page({ searchParams }) {\n  const { lat, lng } = await searchParams;\n  return (\n    <Suspense fallback=\"loading your inbox...\">\n      <Map lat={lat} lng={lng}>\n    </Suspense>\n  )\n}",
      "language": "python"
    },
    {
      "code": "export async function Map({ coords }) {\n  const { lat, lng } = await coords\n  const mapData = await fetch(`https://...?lat=${lat}&lng=${lng}`)\n  return drawMap(mapData)\n}",
      "language": "javascript"
    },
    {
      "code": "import { cookies } from 'next/headers'\n \nimport { Map } from './map'\n \nexport default async function Page({ searchParams }) {\n  const coords = searchParams.then(sp => ({ lat: sp.lat, lng: sp.lng }))\n  return (\n    <Suspense fallback=\"loading your inbox...\">\n      <Map coord={coords}>\n    </Suspense>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import { cacheLife } from 'next/cache'\n \nasync function getDashboard() {\n  \"use cache\"\n  // This cache will revalidate after 1 second. It is so short\n  // Next.js won't prerender it on the server but the client router\n  // can reuse the result for up to 30 seconds unless the user manually refreshes\n  cacheLife('seconds')\n  return db.query(...)\n}\n \nexport default async function Page() {\n  const data = await getDashboard(token);\n  return <Dashboard data={data}>\n}",
      "language": "python"
    },
    {
      "code": "import { cacheLife } from 'next/cache'\n \nasync function getDashboard() {\n  \"use cache\"\n  // This cache will revalidate after 1 minute. It's long enough that\n  // Next.js will still produce a fully or partially prerendered page\n  cacheLife('minutes')\n  return db.query(...)\n}\n \nexport default async function Page() {\n  const data = await getDashboard(token);\n  return <Dashboard data={data}>\n}",
      "language": "python"
    }
  ],
  "patterns": [],
  "links": [
    "https://nextjs.org/docs",
    "https://nextjs.org/docs/messages/blocking-route",
    "https://nextjs.org/docs/app/api-reference/functions/cacheLife",
    "https://nextjs.org/docs/app/api-reference/functions/headers",
    "https://nextjs.org/docs/app/api-reference/functions/cookies",
    "https://nextjs.org/docs/app/api-reference/functions/draft-mode",
    "https://nextjs.org/docs/app/api-reference/functions/connection",
    "https://nextjs.org/docs/app/api-reference/functions/cacheTag"
  ]
}