{
  "url": "https://nextjs.org/docs/pages/guides/authentication",
  "title": "How to implement authentication in Next.js",
  "content": "Understanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth.\n\nBefore starting, it helps to break down the process into three concepts:\n\nThis diagram shows the authentication flow using React and Next.js features:\n\nThe examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the Auth Libraries section.\n\nHere are the steps to implement a sign-up and/or login form:\n\nConsider a login form where users can input their credentials:\n\nThe form above has two input fields for capturing the user's email and password. On submission, it triggers a function that sends a POST request to an API route (/api/auth/login).\n\nYou can then call your Authentication Provider's API in the API route to handle authentication:\n\nSession management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens.\n\nThere are two types of sessions:\n\nGood to know: While you can use either method, or both, we recommend using a session management library such as iron-session or Jose.\n\nYou can use API Routes to set the session as a cookie on the server:\n\nTo create and manage database sessions, you'll need to follow these steps:\n\nCreating a Session on the Server:\n\nOnce a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application.\n\nThere are two main types of authorization checks:\n\nFor both cases, we recommend:\n\nThere are some cases where you may want to use Proxy and redirect users based on permissions:\n\nHowever, since Proxy runs on every route, including prefetched routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues.\n\nWhile Proxy can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information.\n\nAPI Routes in Next.js are essential for handling server-side logic and data management. It's crucial to secure these routes to ensure that only authorized users can access specific functionalities. This typically involves verifying the user's authentication status and their role-based permissions.\n\nHere's an example of securing an API Route:\n\nThis example demonstrates an API Route with a two-tier security check for authentication and authorization. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. This approach ensures secure access, limited to authenticated and authorized users, maintaining robust security for request processing.\n\nNow that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:\n\nTo continue learning about authentication and security, check out the following resources:",
  "headings": [
    {
      "level": "h1",
      "text": "How to implement authentication in Next.js",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Authentication",
      "id": "authentication"
    },
    {
      "level": "h2",
      "text": "Session Management",
      "id": "session-management"
    },
    {
      "level": "h3",
      "text": "Stateless Sessions",
      "id": "stateless-sessions"
    },
    {
      "level": "h4",
      "text": "Setting and deleting cookies",
      "id": "setting-and-deleting-cookies"
    },
    {
      "level": "h3",
      "text": "Database Sessions",
      "id": "database-sessions"
    },
    {
      "level": "h2",
      "text": "Authorization",
      "id": "authorization"
    },
    {
      "level": "h3",
      "text": "Optimistic checks with Proxy (Optional)",
      "id": "optimistic-checks-with-proxy-optional"
    },
    {
      "level": "h3",
      "text": "Creating a Data Access Layer (DAL)",
      "id": "creating-a-data-access-layer-dal-1"
    },
    {
      "level": "h4",
      "text": "Protecting API Routes",
      "id": "protecting-api-routes"
    },
    {
      "level": "h2",
      "text": "Resources",
      "id": "resources"
    },
    {
      "level": "h3",
      "text": "Auth Libraries",
      "id": "auth-libraries"
    },
    {
      "level": "h3",
      "text": "Session Management Libraries",
      "id": "session-management-libraries"
    },
    {
      "level": "h2",
      "text": "Further Reading",
      "id": "further-reading"
    }
  ],
  "code_samples": [
    {
      "code": "import { FormEvent } from 'react'\nimport { useRouter } from 'next/router'\n \nexport default function LoginPage() {\n  const router = useRouter()\n \n  async function handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault()\n \n    const formData = new FormData(event.currentTarget)\n    const email = formData.get('email')\n    const password = formData.get('password')\n \n    const response = await fetch('/api/auth/login', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ email, password }),\n    })\n \n    if (response.ok) {\n      router.push('/profile')\n    } else {\n      // Handle errors\n    }\n  }\n \n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"email\" name=\"email\" placeholder=\"Email\" required />\n      <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n      <button type=\"submit\">Login</button>\n    </form>\n  )\n}",
      "language": "python"
    },
    {
      "code": "import type { NextApiRequest, NextApiResponse } from 'next'\nimport { signIn } from '@/auth'\n \nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  try {\n    const { email, password } = req.body\n    await signIn('credentials', { email, password })\n \n    res.status(200).json({ success: true })\n  } catch (error) {\n    if (error.type === 'CredentialsSignin') {\n      res.status(401).json({ error: 'Invalid credentials.' })\n    } else {\n      res.status(500).json({ error: 'Something went wrong.' })\n    }\n  }\n}",
      "language": "python"
    },
    {
      "code": "import { serialize } from 'cookie'\nimport type { NextApiRequest, NextApiResponse } from 'next'\nimport { encrypt } from '@/app/lib/session'\n \nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  const sessionData = req.body\n  const encryptedSessionData = encrypt(sessionData)\n \n  const cookie = serialize('session', encryptedSessionData, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    maxAge: 60 * 60 * 24 * 7, // One week\n    path: '/',\n  })\n  res.setHeader('Set-Cookie', cookie)\n  res.status(200).json({ message: 'Successfully set cookie!' })\n}",
      "language": "python"
    },
    {
      "code": "import db from '../../lib/db'\nimport type { NextApiRequest, NextApiResponse } from 'next'\n \nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  try {\n    const user = req.body\n    const sessionId = generateSessionId()\n    await db.insertSession({\n      sessionId,\n      userId: user.id,\n      createdAt: new Date(),\n    })\n \n    res.status(200).json({ sessionId })\n  } catch (error) {\n    res.status(500).json({ error: 'Internal Server Error' })\n  }\n}",
      "language": "python"
    },
    {
      "code": "import { NextRequest, NextResponse } from 'next/server'\nimport { decrypt } from '@/app/lib/session'\nimport { cookies } from 'next/headers'\n \n// 1. Specify protected and public routes\nconst protectedRoutes = ['/dashboard']\nconst publicRoutes = ['/login', '/signup', '/']\n \nexport default async function proxy(req: NextRequest) {\n  // 2. Check if the current route is protected or public\n  const path = req.nextUrl.pathname\n  const isProtectedRoute = protectedRoutes.includes(path)\n  const isPublicRoute = publicRoutes.includes(path)\n \n  // 3. Decrypt the session from the cookie\n  const cookie = (await cookies()).get('session')?.value\n  const session = await decrypt(cookie)\n \n  // 4. Redirect to /login if the user is not authenticated\n  if (isProtectedRoute && !session?.userId) {\n    return NextResponse.redirect(new URL('/login', req.nextUrl))\n  }\n \n  // 5. Redirect to /dashboard if the user is authenticated\n  if (\n    isPublicRoute &&\n    session?.userId &&\n    !req.nextUrl.pathname.startsWith('/dashboard')\n  ) {\n    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))\n  }\n \n  return NextResponse.next()\n}\n \n// Routes Proxy should not run on\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'],\n}",
      "language": "python"
    },
    {
      "code": "import { NextApiRequest, NextApiResponse } from 'next'\n \nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  const session = await getSession(req)\n \n  // Check if the user is authenticated\n  if (!session) {\n    res.status(401).json({\n      error: 'User is not authenticated',\n    })\n    return\n  }\n \n  // Check if the user has the 'admin' role\n  if (session.user.role !== 'admin') {\n    res.status(401).json({\n      error: 'Unauthorized access: User does not have admin privileges.',\n    })\n    return\n  }\n \n  // Proceed with the route for authorized users\n  // ... implementation of the API Route\n}",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Pages RouterGuidesAuthenticationCopy pageHow to implement authentication in Next.jsUnderstanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth. Before starting, it helps to break down the process into three concepts: Authentication: Verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as a username and password. Session Management: Tracks the user's auth state across requests. Authorization: Decides what routes and data the user can access. This diagram shows the authentication flow using React and Next.js features: The examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the Auth Libraries section. Authentication Here are the steps to implement a sign-up and/or login form: The user submits their credentials through a form. The form sends a request that is handled by an API route. Upon successful verification, the process is completed, indicating the user's successful authentication. If verification is unsuccessful, an error message is shown. Consider a login form where users can input their credentials:pages/login.tsxTypeScriptJavaScriptTypeScriptimport { FormEvent } from 'react' import { useRouter } from 'next/router' export default function LoginPage() { const router = useRouter() async function handleSubmit(event: FormEvent<HTMLFormElement>) { event.preventDefault() const formData = new FormData(event.currentTarget) const email = formData.get('email') const password = formData.get('password') const response = await fetch('/api/auth/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, password }), }) if (response.ok) { router.push('/profile') } else { // Handle errors } } return ( <form onSubmit={handleSubmit}> <input type=\"email\" name=\"email\" placeholder=\"Email\" required /> <input type=\"password\" name=\"password\" placeholder=\"Password\" required /> <button type=\"submit\">Login</button> </form> ) }The form above has two input fields for capturing the user's email and password. On submission, it triggers a function that sends a POST request to an API route (/api/auth/login).You can then call your Authentication Provider's API in the API route to handle authentication:pages/api/auth/login.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' import { signIn } from '@/auth' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { try { const { email, password } = req.body await signIn('credentials', { email, password }) res.status(200).json({ success: true }) } catch (error) { if (error.type === 'CredentialsSignin') { res.status(401).json({ error: 'Invalid credentials.' }) } else { res.status(500).json({ error: 'Something went wrong.' }) } } } Session Management Session management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens. There are two types of sessions: Stateless: Session data (or a token) is stored in the browser's cookies. The cookie is sent with each request, allowing the session to be verified on the server. This method is simpler, but can be less secure if not implemented correctly. Database: Session data is stored in a database, with the user's browser only receiving the encrypted session ID. This method is more secure, but can be complex and use more server resources. Good to know: While you can use either method, or both, we recommend using a session management library such as iron-session or Jose. Stateless Sessions Setting and deleting cookies You can use API Routes to set the session as a cookie on the server:pages/api/login.tsTypeScriptJavaScriptTypeScriptimport { serialize } from 'cookie' import type { NextApiRequest, NextApiResponse } from 'next' import { encrypt } from '@/app/lib/session' export default function handler(req: NextApiRequest, res: NextApiResponse) { const sessionData = req.body const encryptedSessionData = encrypt(sessionData) const cookie = serialize('session', encryptedSessionData, { httpOnly: true, secure: process.env.NODE_ENV === 'production', maxAge: 60 * 60 * 24 * 7, // One week path: '/', }) res.setHeader('Set-Cookie', cookie) res.status(200).json({ message: 'Successfully set cookie!' }) } Database Sessions To create and manage database sessions, you'll need to follow these steps: Create a table in your database to store session and data (or check if your Auth Library handles this). Implement functionality to insert, update, and delete sessions Encrypt the session ID before storing it in the user's browser, and ensure the database and cookie stay in sync (this is optional, but recommended for optimistic auth checks in Proxy). Creating a Session on the Server:pages/api/create-session.tsTypeScriptJavaScriptTypeScriptimport db from '../../lib/db' import type { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { try { const user = req.body const sessionId = generateSessionId() await db.insertSession({ sessionId, userId: user.id, createdAt: new Date(), }) res.status(200).json({ sessionId }) } catch (error) { res.status(500).json({ error: 'Internal Server Error' }) } } Authorization Once a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application. There are two main types of authorization checks: Optimistic: Checks if the user is authorized to access a route or perform an action using the session data stored in the cookie. These checks are useful for quick operations, such as showing/hiding UI elements or redirecting users based on permissions or roles. Secure: Checks if the user is authorized to access a route or perform an action using the session data stored in the database. These checks are more secure and are used for operations that require access to sensitive data or actions. For both cases, we recommend: Creating a Data Access Layer to centralize your authorization logic Using Data Transfer Objects (DTO) to only return the necessary data Optionally use Proxy to perform optimistic checks. Optimistic checks with Proxy (Optional) There are some cases where you may want to use Proxy and redirect users based on permissions: To perform optimistic checks. Since Proxy runs on every route, it's a good way to centralize redirect logic and pre-filter unauthorized users. To protect static routes that share data between users (e.g. content behind a paywall). However, since Proxy runs on every route, including prefetched routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues. For example: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server' import { decrypt } from '@/app/lib/session' import { cookies } from 'next/headers' // 1. Specify protected and public routes const protectedRoutes = ['/dashboard'] const publicRoutes = ['/login', '/signup', '/'] export default async function proxy(req: NextRequest) { // 2. Check if the current route is protected or public const path = req.nextUrl.pathname const isProtectedRoute = protectedRoutes.includes(path) const isPublicRoute = publicRoutes.includes(path) // 3. Decrypt the session from the cookie const cookie = (await cookies()).get('session')?.value const session = await decrypt(cookie) // 4. Redirect to /login if the user is not authenticated if (isProtectedRoute && !session?.userId) { return NextResponse.redirect(new URL('/login', req.nextUrl)) } // 5. Redirect to /dashboard if the user is authenticated if ( isPublicRoute && session?.userId && !req.nextUrl.pathname.startsWith('/dashboard') ) { return NextResponse.redirect(new URL('/dashboard', req.nextUrl)) } return NextResponse.next() } // Routes Proxy should not run on export const config = { matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'], } While Proxy can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information. Tips: In Proxy, you can also read cookies using req.cookies.get('session').value. Proxy uses the Node.js runtime, check if your Auth library and session management library are compatible. You may need to use Middleware if your Auth library only supports Edge Runtime You can use the matcher property in the Proxy to specify which routes Proxy should run on. Although, for auth, it's recommended Proxy runs on all routes. Creating a Data Access Layer (DAL) Protecting API Routes API Routes in Next.js are essential for handling server-side logic and data management. It's crucial to secure these routes to ensure that only authorized users can access specific functionalities. This typically involves verifying the user's authentication status and their role-based permissions.Here's an example of securing an API Route:pages/api/route.tsTypeScriptJavaScriptTypeScriptimport { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { const session = await getSession(req) // Check if the user is authenticated if (!session) { res.status(401).json({ error: 'User is not authenticated', }) return } // Check if the user has the 'admin' role if (session.user.role !== 'admin') { res.status(401).json({ error: 'Unauthorized access: User does not have admin privileges.', }) return } // Proceed with the route for authorized users // ... implementation of the API Route }This example demonstrates an API Route with a two-tier security check for authentication and authorization. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. This approach ensures secure access, limited to authenticated and authorized users, maintaining robust security for request processing. Resources Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management: Auth Libraries Auth0 Better Auth Clerk Descope Kinde Logto NextAuth.js Ory Stack Auth Supabase Stytch WorkOS Session Management Libraries Iron Session Jose Further Reading To continue learning about authentication and security, check out the following resources: How to think about security in Next.js Understanding XSS Attacks Understanding CSRF Attacks The Copenhagen Book",
      "code": "import { FormEvent } from 'react'\nimport { useRouter } from 'next/router'\n \nexport default function LoginPage() {\n  const router = useRouter()\n \n  async function handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault()\n \n    const formData = new FormData(event.currentTarget)\n    const email = formData.get('email')\n    const password = formData.get('password')\n \n    const response = await fetch('/api/auth/login', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ email, password }),\n    })\n \n    if (response.ok) {\n      router.push('/profile')\n    } else {\n      // Handle errors\n    }\n  }\n \n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"email\" name=\"email\" placeholder=\"Email\" required />\n      <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n      <button type=\"submit\">Login</button>\n    </form>\n  )\n}"
    },
    {
      "description": "How to implement authentication in Next.jsUnderstanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth. Before starting, it helps to break down the process into three concepts: Authentication: Verifies if the user is who they say they are. It requires the user to prove their identity with something they have, such as a username and password. Session Management: Tracks the user's auth state across requests. Authorization: Decides what routes and data the user can access. This diagram shows the authentication flow using React and Next.js features: The examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the Auth Libraries section. Authentication Here are the steps to implement a sign-up and/or login form: The user submits their credentials through a form. The form sends a request that is handled by an API route. Upon successful verification, the process is completed, indicating the user's successful authentication. If verification is unsuccessful, an error message is shown. Consider a login form where users can input their credentials:pages/login.tsxTypeScriptJavaScriptTypeScriptimport { FormEvent } from 'react' import { useRouter } from 'next/router' export default function LoginPage() { const router = useRouter() async function handleSubmit(event: FormEvent<HTMLFormElement>) { event.preventDefault() const formData = new FormData(event.currentTarget) const email = formData.get('email') const password = formData.get('password') const response = await fetch('/api/auth/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, password }), }) if (response.ok) { router.push('/profile') } else { // Handle errors } } return ( <form onSubmit={handleSubmit}> <input type=\"email\" name=\"email\" placeholder=\"Email\" required /> <input type=\"password\" name=\"password\" placeholder=\"Password\" required /> <button type=\"submit\">Login</button> </form> ) }The form above has two input fields for capturing the user's email and password. On submission, it triggers a function that sends a POST request to an API route (/api/auth/login).You can then call your Authentication Provider's API in the API route to handle authentication:pages/api/auth/login.tsTypeScriptJavaScriptTypeScriptimport type { NextApiRequest, NextApiResponse } from 'next' import { signIn } from '@/auth' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { try { const { email, password } = req.body await signIn('credentials', { email, password }) res.status(200).json({ success: true }) } catch (error) { if (error.type === 'CredentialsSignin') { res.status(401).json({ error: 'Invalid credentials.' }) } else { res.status(500).json({ error: 'Something went wrong.' }) } } } Session Management Session management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens. There are two types of sessions: Stateless: Session data (or a token) is stored in the browser's cookies. The cookie is sent with each request, allowing the session to be verified on the server. This method is simpler, but can be less secure if not implemented correctly. Database: Session data is stored in a database, with the user's browser only receiving the encrypted session ID. This method is more secure, but can be complex and use more server resources. Good to know: While you can use either method, or both, we recommend using a session management library such as iron-session or Jose. Stateless Sessions Setting and deleting cookies You can use API Routes to set the session as a cookie on the server:pages/api/login.tsTypeScriptJavaScriptTypeScriptimport { serialize } from 'cookie' import type { NextApiRequest, NextApiResponse } from 'next' import { encrypt } from '@/app/lib/session' export default function handler(req: NextApiRequest, res: NextApiResponse) { const sessionData = req.body const encryptedSessionData = encrypt(sessionData) const cookie = serialize('session', encryptedSessionData, { httpOnly: true, secure: process.env.NODE_ENV === 'production', maxAge: 60 * 60 * 24 * 7, // One week path: '/', }) res.setHeader('Set-Cookie', cookie) res.status(200).json({ message: 'Successfully set cookie!' }) } Database Sessions To create and manage database sessions, you'll need to follow these steps: Create a table in your database to store session and data (or check if your Auth Library handles this). Implement functionality to insert, update, and delete sessions Encrypt the session ID before storing it in the user's browser, and ensure the database and cookie stay in sync (this is optional, but recommended for optimistic auth checks in Proxy). Creating a Session on the Server:pages/api/create-session.tsTypeScriptJavaScriptTypeScriptimport db from '../../lib/db' import type { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { try { const user = req.body const sessionId = generateSessionId() await db.insertSession({ sessionId, userId: user.id, createdAt: new Date(), }) res.status(200).json({ sessionId }) } catch (error) { res.status(500).json({ error: 'Internal Server Error' }) } } Authorization Once a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application. There are two main types of authorization checks: Optimistic: Checks if the user is authorized to access a route or perform an action using the session data stored in the cookie. These checks are useful for quick operations, such as showing/hiding UI elements or redirecting users based on permissions or roles. Secure: Checks if the user is authorized to access a route or perform an action using the session data stored in the database. These checks are more secure and are used for operations that require access to sensitive data or actions. For both cases, we recommend: Creating a Data Access Layer to centralize your authorization logic Using Data Transfer Objects (DTO) to only return the necessary data Optionally use Proxy to perform optimistic checks. Optimistic checks with Proxy (Optional) There are some cases where you may want to use Proxy and redirect users based on permissions: To perform optimistic checks. Since Proxy runs on every route, it's a good way to centralize redirect logic and pre-filter unauthorized users. To protect static routes that share data between users (e.g. content behind a paywall). However, since Proxy runs on every route, including prefetched routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues. For example: proxy.tsTypeScriptJavaScriptTypeScriptimport { NextRequest, NextResponse } from 'next/server' import { decrypt } from '@/app/lib/session' import { cookies } from 'next/headers' // 1. Specify protected and public routes const protectedRoutes = ['/dashboard'] const publicRoutes = ['/login', '/signup', '/'] export default async function proxy(req: NextRequest) { // 2. Check if the current route is protected or public const path = req.nextUrl.pathname const isProtectedRoute = protectedRoutes.includes(path) const isPublicRoute = publicRoutes.includes(path) // 3. Decrypt the session from the cookie const cookie = (await cookies()).get('session')?.value const session = await decrypt(cookie) // 4. Redirect to /login if the user is not authenticated if (isProtectedRoute && !session?.userId) { return NextResponse.redirect(new URL('/login', req.nextUrl)) } // 5. Redirect to /dashboard if the user is authenticated if ( isPublicRoute && session?.userId && !req.nextUrl.pathname.startsWith('/dashboard') ) { return NextResponse.redirect(new URL('/dashboard', req.nextUrl)) } return NextResponse.next() } // Routes Proxy should not run on export const config = { matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'], } While Proxy can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information. Tips: In Proxy, you can also read cookies using req.cookies.get('session').value. Proxy uses the Node.js runtime, check if your Auth library and session management library are compatible. You may need to use Middleware if your Auth library only supports Edge Runtime You can use the matcher property in the Proxy to specify which routes Proxy should run on. Although, for auth, it's recommended Proxy runs on all routes. Creating a Data Access Layer (DAL) Protecting API Routes API Routes in Next.js are essential for handling server-side logic and data management. It's crucial to secure these routes to ensure that only authorized users can access specific functionalities. This typically involves verifying the user's authentication status and their role-based permissions.Here's an example of securing an API Route:pages/api/route.tsTypeScriptJavaScriptTypeScriptimport { NextApiRequest, NextApiResponse } from 'next' export default async function handler( req: NextApiRequest, res: NextApiResponse ) { const session = await getSession(req) // Check if the user is authenticated if (!session) { res.status(401).json({ error: 'User is not authenticated', }) return } // Check if the user has the 'admin' role if (session.user.role !== 'admin') { res.status(401).json({ error: 'Unauthorized access: User does not have admin privileges.', }) return } // Proceed with the route for authorized users // ... implementation of the API Route }This example demonstrates an API Route with a two-tier security check for authentication and authorization. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. This approach ensures secure access, limited to authenticated and authorized users, maintaining robust security for request processing. Resources Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management: Auth Libraries Auth0 Better Auth Clerk Descope Kinde Logto NextAuth.js Ory Stack Auth Supabase Stytch WorkOS Session Management Libraries Iron Session Jose Further Reading To continue learning about authentication and security, check out the following resources: How to think about security in Next.js Understanding XSS Attacks Understanding CSRF Attacks The Copenhagen Book",
      "code": "import { FormEvent } from 'react'\nimport { useRouter } from 'next/router'\n \nexport default function LoginPage() {\n  const router = useRouter()\n \n  async function handleSubmit(event: FormEvent<HTMLFormElement>) {\n    event.preventDefault()\n \n    const formData = new FormData(event.currentTarget)\n    const email = formData.get('email')\n    const password = formData.get('password')\n \n    const response = await fetch('/api/auth/login', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ email, password }),\n    })\n \n    if (response.ok) {\n      router.push('/profile')\n    } else {\n      // Handle errors\n    }\n  }\n \n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"email\" name=\"email\" placeholder=\"Email\" required />\n      <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n      <button type=\"submit\">Login</button>\n    </form>\n  )\n}"
    },
    {
      "description": "For example:",
      "code": "import { NextRequest, NextResponse } from 'next/server'\nimport { decrypt } from '@/app/lib/session'\nimport { cookies } from 'next/headers'\n \n// 1. Specify protected and public routes\nconst protectedRoutes = ['/dashboard']\nconst publicRoutes = ['/login', '/signup', '/']\n \nexport default async function proxy(req: NextRequest) {\n  // 2. Check if the current route is protected or public\n  const path = req.nextUrl.pathname\n  const isProtectedRoute = protectedRoutes.includes(path)\n  const isPublicRoute = publicRoutes.includes(path)\n \n  // 3. Decrypt the session from the cookie\n  const cookie = (await cookies()).get('session')?.value\n  const session = await decrypt(cookie)\n \n  // 4. Redirect to /login if the user is not authenticated\n  if (isProtectedRoute && !session?.userId) {\n    return NextResponse.redirect(new URL('/login', req.nextUrl))\n  }\n \n  // 5. Redirect to /dashboard if the user is authenticated\n  if (\n    isPublicRoute &&\n    session?.userId &&\n    !req.nextUrl.pathname.startsWith('/dashboard')\n  ) {\n    return NextResponse.redirect(new URL('/dashboard', req.nextUrl))\n  }\n \n  return NextResponse.next()\n}\n \n// Routes Proxy should not run on\nexport const config = {\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)'],\n}"
    }
  ],
  "links": [
    "https://nextjs.org/docs/pages",
    "https://nextjs.org/docs/pages/guides",
    "https://nextjs.org/docs/pages/guides/authentication",
    "https://nextjs.org/docs/pages/building-your-application/routing/api-routes",
    "https://nextjs.org/docs/app/api-reference/file-conventions/proxy",
    "https://nextjs.org/docs/app/getting-started/linking-and-navigating",
    "https://nextjs.org/docs/app/api-reference/edge",
    "https://nextjs.org/docs/pages/guides/analytics",
    "https://nextjs.org/docs/pages/guides/babel"
  ]
}