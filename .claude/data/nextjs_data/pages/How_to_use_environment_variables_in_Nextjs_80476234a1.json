{
  "url": "https://nextjs.org/docs/pages/guides/environment-variables",
  "title": "How to use environment variables in Next.js",
  "content": "Next.js comes with built-in support for environment variables, which allows you to do the following:\n\nWarning: The default create-next-app template ensures all .env files are added to your .gitignore. You almost never want to commit these files to your repository.\n\nNext.js has built-in support for loading environment variables from .env* files into process.env.\n\nThis loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods and API routes.\n\nFor example, using getStaticProps:\n\nIf you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the @next/env package.\n\nThis package is used internally by Next.js to load environment variables from .env* files.\n\nTo use it, install the package and use the loadEnvConfig function to load the environment variables:\n\nThen, you can import the configuration where needed. For example:\n\nNext.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This allows you to reference other secrets. For example:\n\nIn the above example, process.env.TWITTER_URL would be set to https://x.com/nextjs.\n\nGood to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \\$.\n\nNon-NEXT_PUBLIC_ environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment).\n\nIn order to make the value of an environment variable accessible in the browser, Next.js can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXT_PUBLIC_. For example:\n\nThis will tell Next.js to replace all references to process.env.NEXT_PUBLIC_ANALYTICS_ID in the Node.js environment with the value from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.\n\nNote: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all NEXT_PUBLIC_ variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).\n\nNote that dynamic lookups will not be inlined, such as:\n\nNext.js can support both build time and runtime environment variables.\n\nBy default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.\n\nTo read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router.\n\nThis allows you to use a singular Docker image that can be promoted through multiple environments with different values.\n\nApart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Next.js will not load environment variables from .env.development or .env.production in the testing environment.\n\nThis one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don't need to do this manually as testing tools will address it for you.\n\nThere is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set).\n\nGood to know: similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env*.local are intended to be ignored through .gitignore.\n\nWhile running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the loadEnvConfig function from the @next/env package.\n\nEnvironment variables are looked up in the following places, in order, stopping once the variable is found.\n\nFor example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used.\n\nGood to know: The allowed values for NODE_ENV are production, development and test.",
  "headings": [
    {
      "level": "h1",
      "text": "How to use environment variables in Next.js",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Loading Environment Variables",
      "id": "loading-environment-variables"
    },
    {
      "level": "h3",
      "text": "Loading Environment Variables with @next/env",
      "id": "loading-environment-variables-with-nextenv"
    },
    {
      "level": "h3",
      "text": "Referencing Other Variables",
      "id": "referencing-other-variables"
    },
    {
      "level": "h2",
      "text": "Bundling Environment Variables for the Browser",
      "id": "bundling-environment-variables-for-the-browser"
    },
    {
      "level": "h3",
      "text": "Runtime Environment Variables",
      "id": "runtime-environment-variables"
    },
    {
      "level": "h2",
      "text": "Test Environment Variables",
      "id": "test-environment-variables"
    },
    {
      "level": "h2",
      "text": "Environment Variable Load Order",
      "id": "environment-variable-load-order"
    },
    {
      "level": "h2",
      "text": "Good to know",
      "id": "good-to-know"
    },
    {
      "level": "h2",
      "text": "Version History",
      "id": "version-history"
    }
  ],
  "code_samples": [
    {
      "code": "DB_HOST=localhost\nDB_USER=myuser\nDB_PASS=mypassword",
      "language": "unknown"
    },
    {
      "code": "export async function getStaticProps() {\n  const db = await myDB.connect({\n    host: process.env.DB_HOST,\n    username: process.env.DB_USER,\n    password: process.env.DB_PASS,\n  })\n  // ...\n}",
      "language": "javascript"
    },
    {
      "code": "npm install @next/env",
      "language": "unknown"
    },
    {
      "code": "import { loadEnvConfig } from '@next/env'\n \nconst projectDir = process.cwd()\nloadEnvConfig(projectDir)",
      "language": "python"
    },
    {
      "code": "import './envConfig.ts'\n \nexport default defineConfig({\n  dbCredentials: {\n    connectionString: process.env.DATABASE_URL!,\n  },\n})",
      "language": "unknown"
    },
    {
      "code": "TWITTER_USER=nextjs\nTWITTER_URL=https://x.com/$TWITTER_USER",
      "language": "unknown"
    },
    {
      "code": "NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk",
      "language": "unknown"
    },
    {
      "code": "import setupAnalyticsService from '../lib/my-analytics-service'\n \n// 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'.\n// It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.\nsetupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID)\n \nfunction HomePage() {\n  return <h1>Hello World</h1>\n}\n \nexport default HomePage",
      "language": "python"
    },
    {
      "code": "// This will NOT be inlined, because it uses a variable\nconst varName = 'NEXT_PUBLIC_ANALYTICS_ID'\nsetupAnalyticsService(process.env[varName])\n \n// This will NOT be inlined, because it uses a variable\nconst env = process.env\nsetupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID)",
      "language": "javascript"
    },
    {
      "code": "// The below can be used in a Jest global setup file or similar for your testing set-up\nimport { loadEnvConfig } from '@next/env'\n \nexport default async () => {\n  const projectDir = process.cwd()\n  loadEnvConfig(projectDir)\n}",
      "language": "python"
    }
  ],
  "patterns": [
    {
      "description": "Pages RouterGuidesEnvironment VariablesCopy pageHow to use environment variables in Next.js Next.js comes with built-in support for environment variables, which allows you to do the following: Use .env to load environment variables Bundle environment variables for the browser by prefixing with NEXT_PUBLIC_ Warning: The default create-next-app template ensures all .env files are added to your .gitignore. You almost never want to commit these files to your repository. Loading Environment Variables Next.js has built-in support for loading environment variables from .env* files into process.env. .envDB_HOST=localhost DB_USER=myuser DB_PASS=mypassword This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods and API routes.For example, using getStaticProps:pages/index.jsexport async function getStaticProps() { const db = await myDB.connect({ host: process.env.DB_HOST, username: process.env.DB_USER, password: process.env.DB_PASS, }) // ... } Loading Environment Variables with @next/env If you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the @next/env package. This package is used internally by Next.js to load environment variables from .env* files. To use it, install the package and use the loadEnvConfig function to load the environment variables: npm install @next/env envConfig.tsTypeScriptJavaScriptTypeScriptimport { loadEnvConfig } from '@next/env' const projectDir = process.cwd() loadEnvConfig(projectDir) Then, you can import the configuration where needed. For example: orm.config.tsTypeScriptJavaScriptTypeScriptimport './envConfig.ts' export default defineConfig({ dbCredentials: { connectionString: process.env.DATABASE_URL!, }, }) Referencing Other Variables Next.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This allows you to reference other secrets. For example: .envTWITTER_USER=nextjs TWITTER_URL=https://x.com/$TWITTER_USER In the above example, process.env.TWITTER_URL would be set to https://x.com/nextjs. Good to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \\$. Bundling Environment Variables for the Browser Non-NEXT_PUBLIC_ environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment). In order to make the value of an environment variable accessible in the browser, Next.js can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXT_PUBLIC_. For example: TerminalNEXT_PUBLIC_ANALYTICS_ID=abcdefghijk This will tell Next.js to replace all references to process.env.NEXT_PUBLIC_ANALYTICS_ID in the Node.js environment with the value from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser. Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all NEXT_PUBLIC_ variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization). pages/index.jsimport setupAnalyticsService from '../lib/my-analytics-service' // 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'. // It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`. setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID) function HomePage() { return <h1>Hello World</h1> } export default HomePage Note that dynamic lookups will not be inlined, such as: // This will NOT be inlined, because it uses a variable const varName = 'NEXT_PUBLIC_ANALYTICS_ID' setupAnalyticsService(process.env[varName]) // This will NOT be inlined, because it uses a variable const env = process.env setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID) Runtime Environment Variables Next.js can support both build time and runtime environment variables. By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build. To read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router. This allows you to use a singular Docker image that can be promoted through multiple environments with different values. Good to know: You can run code on server startup using the register function. Test Environment Variables Apart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Next.js will not load environment variables from .env.development or .env.production in the testing environment. This one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don't need to do this manually as testing tools will address it for you. There is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set). Good to know: similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env*.local are intended to be ignored through .gitignore. While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the loadEnvConfig function from the @next/env package. // The below can be used in a Jest global setup file or similar for your testing set-up import { loadEnvConfig } from '@next/env' export default async () => { const projectDir = process.cwd() loadEnvConfig(projectDir) } Environment Variable Load Order Environment variables are looked up in the following places, in order, stopping once the variable is found. process.env .env.$(NODE_ENV).local .env.local (Not checked when NODE_ENV is test.) .env.$(NODE_ENV) .env For example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used. Good to know: The allowed values for NODE_ENV are production, development and test. Good to know If you are using a /src directory, .env.* files should remain in the root of your project. If the environment variable NODE_ENV is unassigned, Next.js automatically assigns development when running the next dev command, or production for all other commands. Version History VersionChangesv9.4.0Support .env and NEXT_PUBLIC_ introduced.",
      "code": ".env"
    },
    {
      "description": "How to use environment variables in Next.js Next.js comes with built-in support for environment variables, which allows you to do the following: Use .env to load environment variables Bundle environment variables for the browser by prefixing with NEXT_PUBLIC_ Warning: The default create-next-app template ensures all .env files are added to your .gitignore. You almost never want to commit these files to your repository. Loading Environment Variables Next.js has built-in support for loading environment variables from .env* files into process.env. .envDB_HOST=localhost DB_USER=myuser DB_PASS=mypassword This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods and API routes.For example, using getStaticProps:pages/index.jsexport async function getStaticProps() { const db = await myDB.connect({ host: process.env.DB_HOST, username: process.env.DB_USER, password: process.env.DB_PASS, }) // ... } Loading Environment Variables with @next/env If you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the @next/env package. This package is used internally by Next.js to load environment variables from .env* files. To use it, install the package and use the loadEnvConfig function to load the environment variables: npm install @next/env envConfig.tsTypeScriptJavaScriptTypeScriptimport { loadEnvConfig } from '@next/env' const projectDir = process.cwd() loadEnvConfig(projectDir) Then, you can import the configuration where needed. For example: orm.config.tsTypeScriptJavaScriptTypeScriptimport './envConfig.ts' export default defineConfig({ dbCredentials: { connectionString: process.env.DATABASE_URL!, }, }) Referencing Other Variables Next.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This allows you to reference other secrets. For example: .envTWITTER_USER=nextjs TWITTER_URL=https://x.com/$TWITTER_USER In the above example, process.env.TWITTER_URL would be set to https://x.com/nextjs. Good to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \\$. Bundling Environment Variables for the Browser Non-NEXT_PUBLIC_ environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment). In order to make the value of an environment variable accessible in the browser, Next.js can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXT_PUBLIC_. For example: TerminalNEXT_PUBLIC_ANALYTICS_ID=abcdefghijk This will tell Next.js to replace all references to process.env.NEXT_PUBLIC_ANALYTICS_ID in the Node.js environment with the value from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser. Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all NEXT_PUBLIC_ variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization). pages/index.jsimport setupAnalyticsService from '../lib/my-analytics-service' // 'NEXT_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'NEXT_PUBLIC_'. // It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`. setupAnalyticsService(process.env.NEXT_PUBLIC_ANALYTICS_ID) function HomePage() { return <h1>Hello World</h1> } export default HomePage Note that dynamic lookups will not be inlined, such as: // This will NOT be inlined, because it uses a variable const varName = 'NEXT_PUBLIC_ANALYTICS_ID' setupAnalyticsService(process.env[varName]) // This will NOT be inlined, because it uses a variable const env = process.env setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID) Runtime Environment Variables Next.js can support both build time and runtime environment variables. By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build. To read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router. This allows you to use a singular Docker image that can be promoted through multiple environments with different values. Good to know: You can run code on server startup using the register function. Test Environment Variables Apart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Next.js will not load environment variables from .env.development or .env.production in the testing environment. This one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don't need to do this manually as testing tools will address it for you. There is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set). Good to know: similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env*.local are intended to be ignored through .gitignore. While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the loadEnvConfig function from the @next/env package. // The below can be used in a Jest global setup file or similar for your testing set-up import { loadEnvConfig } from '@next/env' export default async () => { const projectDir = process.cwd() loadEnvConfig(projectDir) } Environment Variable Load Order Environment variables are looked up in the following places, in order, stopping once the variable is found. process.env .env.$(NODE_ENV).local .env.local (Not checked when NODE_ENV is test.) .env.$(NODE_ENV) .env For example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used. Good to know: The allowed values for NODE_ENV are production, development and test. Good to know If you are using a /src directory, .env.* files should remain in the root of your project. If the environment variable NODE_ENV is unassigned, Next.js automatically assigns development when running the next dev command, or production for all other commands. Version History VersionChangesv9.4.0Support .env and NEXT_PUBLIC_ introduced.",
      "code": ".env"
    },
    {
      "description": "Then, you can import the configuration where needed. For example:",
      "code": "import './envConfig.ts'\n \nexport default defineConfig({\n  dbCredentials: {\n    connectionString: process.env.DATABASE_URL!,\n  },\n})"
    },
    {
      "description": "Next.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This allows you to reference other secrets. For example:",
      "code": "$"
    },
    {
      "description": "In order to make the value of an environment variable accessible in the browser, Next.js can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXT_PUBLIC_. For example:",
      "code": "process.env.[variable]"
    }
  ],
  "links": [
    "https://nextjs.org/docs/pages",
    "https://nextjs.org/docs/pages/guides",
    "https://nextjs.org/docs/pages/guides/environment-variables",
    "https://nextjs.org/docs/pages/building-your-application/data-fetching",
    "https://nextjs.org/docs/pages/building-your-application/routing/api-routes",
    "https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props",
    "https://nextjs.org/docs/app/guides/migrating/app-router-migration",
    "https://nextjs.org/docs/app/guides/instrumentation",
    "https://nextjs.org/docs/app/api-reference/file-conventions/src-folder",
    "https://nextjs.org/docs/pages/guides/draft-mode",
    "https://nextjs.org/docs/pages/guides/forms"
  ]
}