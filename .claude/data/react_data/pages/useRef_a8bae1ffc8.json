{
  "url": "https://react.dev/reference/react/useRef",
  "title": "useRef",
  "content": "useRef is a React Hook that lets you reference a value thatâ€™s not needed for rendering.\n\nCall useRef at the top level of your component to declare a ref.\n\nSee more examples below.\n\nuseRef returns an object with a single property:\n\nOn the next renders, useRef will return the same object.\n\nCall useRef at the top level of your component to declare one or more refs.\n\nuseRef returns a ref object with a single current property initially set to the initial value you provided.\n\nOn the next renders, useRef will return the same object. You can change its current property to store information and read it later. This might remind you of state, but there is an important difference.\n\nChanging a ref does not trigger a re-render. This means refs are perfect for storing information that doesnâ€™t affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its current property:\n\nLater, you can read that interval ID from the ref so that you can call clear that interval:\n\nBy using a ref, you ensure that:\n\nChanging a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between useRef and useState.\n\nThis component uses a ref to keep track of how many times the button was clicked. Note that itâ€™s okay to use a ref instead of state here because the click count is only read and written in an event handler.\n\nIf you show {ref.current} in the JSX, the number wonâ€™t update on click. This is because setting ref.current does not trigger a re-render. Information thatâ€™s used for rendering should be state instead.\n\nDo not write or read ref.current during rendering.\n\nReact expects that the body of your component behaves like a pure function:\n\nReading or writing a ref during rendering breaks these expectations.\n\nYou can read or write refs from event handlers or effects instead.\n\nIf you have to read or write something during rendering, use state instead.\n\nWhen you break these rules, your component might still work, but most of the newer features weâ€™re adding to React will rely on these expectations. Read more about keeping your components pure.\n\nItâ€™s particularly common to use a ref to manipulate the DOM. React has built-in support for this.\n\nFirst, declare a ref object with an initial value of null:\n\nThen pass your ref object as the ref attribute to the JSX of the DOM node you want to manipulate:\n\nAfter React creates the DOM node and puts it on the screen, React will set the current property of your ref object to that DOM node. Now you can access the <input>â€™s DOM node and call methods like focus():\n\nReact will set the current property back to null when the node is removed from the screen.\n\nRead more about manipulating the DOM with refs.\n\nIn this example, clicking the button will focus the input:\n\nReact saves the initial ref value once and ignores it on the next renders.\n\nAlthough the result of new VideoPlayer() is only used for the initial render, youâ€™re still calling this function on every render. This can be wasteful if itâ€™s creating expensive objects.\n\nTo solve it, you may initialize the ref like this instead:\n\nNormally, writing or reading ref.current during render is not allowed. However, itâ€™s fine in this case because the result is always the same, and the condition only executes during initialization so itâ€™s fully predictable.\n\nIf you use a type checker and donâ€™t want to always check for null, you can try a pattern like this instead:\n\nHere, the playerRef itself is nullable. However, you should be able to convince your type checker that there is no case in which getPlayer() returns null. Then use getPlayer() in your event handlers.\n\nIf you try to pass a ref to your own component like this:\n\nYou might get an error in the console:\n\nBy default, your own components donâ€™t expose refs to the DOM nodes inside them.\n\nTo fix this, find the component that you want to get a ref to:\n\nAnd then add ref to the list of props your component accepts and pass ref as a prop to the relevant child built-in component like this:\n\nThen the parent component can get a ref to it.\n\nRead more about accessing another componentâ€™s DOM nodes.",
  "headings": [
    {
      "level": "h1",
      "text": "useRef",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Reference",
      "id": "reference"
    },
    {
      "level": "h3",
      "text": "useRef(initialValue)",
      "id": "useref"
    },
    {
      "level": "h4",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h4",
      "text": "Returns",
      "id": "returns"
    },
    {
      "level": "h4",
      "text": "Caveats",
      "id": "caveats"
    },
    {
      "level": "h2",
      "text": "Usage",
      "id": "usage"
    },
    {
      "level": "h3",
      "text": "Referencing a value with a ref",
      "id": "referencing-a-value-with-a-ref"
    },
    {
      "level": "h4",
      "text": "Examples of referencing a value with useRef",
      "id": "examples-value"
    },
    {
      "level": "h4",
      "text": "Example 1 of 2: Click counter",
      "id": "click-counter"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Manipulating the DOM with a ref",
      "id": "manipulating-the-dom-with-a-ref"
    },
    {
      "level": "h4",
      "text": "Examples of manipulating the DOM with useRef",
      "id": "examples-dom"
    },
    {
      "level": "h4",
      "text": "Example 1 of 4: Focusing a text input",
      "id": "focusing-a-text-input"
    },
    {
      "level": "h3",
      "text": "Avoiding recreating the ref contents",
      "id": "avoiding-recreating-the-ref-contents"
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "How to avoid null checks when initializing useRef later",
      "id": "how-to-avoid-null-checks-when-initializing-use-ref-later"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h3",
      "text": "I canâ€™t get a ref to a custom component",
      "id": "i-cant-get-a-ref-to-a-custom-component"
    }
  ],
  "code_samples": [
    {
      "code": "const ref = useRef(initialValue)",
      "language": "javascript"
    },
    {
      "code": "import { useRef } from 'react';function MyComponent() {  const intervalRef = useRef(0);  const inputRef = useRef(null);  // ...",
      "language": "python"
    },
    {
      "code": "import { useRef } from 'react';function Stopwatch() {  const intervalRef = useRef(0);  // ...",
      "language": "python"
    },
    {
      "code": "function handleStartClick() {  const intervalId = setInterval(() => {    // ...  }, 1000);  intervalRef.current = intervalId;}",
      "language": "javascript"
    },
    {
      "code": "function handleStopClick() {  const intervalId = intervalRef.current;  clearInterval(intervalId);}",
      "language": "javascript"
    },
    {
      "code": "function MyComponent() {  // ...  // ðŸš© Don't write a ref during rendering  myRef.current = 123;  // ...  // ðŸš© Don't read a ref during rendering  return <h1>{myOtherRef.current}</h1>;}",
      "language": "unknown"
    },
    {
      "code": "function MyComponent() {  // ...  useEffect(() => {    // âœ… You can read or write refs in effects    myRef.current = 123;  });  // ...  function handleClick() {    // âœ… You can read or write refs in event handlers    doSomething(myOtherRef.current);  }  // ...}",
      "language": "javascript"
    },
    {
      "code": "import { useRef } from 'react';function MyComponent() {  const inputRef = useRef(null);  // ...",
      "language": "python"
    },
    {
      "code": "// ...  return <input ref={inputRef} />;",
      "language": "unknown"
    },
    {
      "code": "function handleClick() {    inputRef.current.focus();  }",
      "language": "unknown"
    },
    {
      "code": "function Video() {  const playerRef = useRef(new VideoPlayer());  // ...",
      "language": "javascript"
    },
    {
      "code": "function Video() {  const playerRef = useRef(null);  if (playerRef.current === null) {    playerRef.current = new VideoPlayer();  }  // ...",
      "language": "javascript"
    },
    {
      "code": "function Video() {  const playerRef = useRef(null);  function getPlayer() {    if (playerRef.current !== null) {      return playerRef.current;    }    const player = new VideoPlayer();    playerRef.current = player;    return player;  }  // ...",
      "language": "javascript"
    },
    {
      "code": "const inputRef = useRef(null);return <MyInput ref={inputRef} />;",
      "language": "javascript"
    },
    {
      "code": "export default function MyInput({ value, onChange }) {  return (    <input      value={value}      onChange={onChange}    />  );}",
      "language": "unknown"
    },
    {
      "code": "function MyInput({ value, onChange, ref }) {  return (    <input      value={value}      onChange={onChange}      ref={ref}    />  );};export default MyInput;",
      "language": "unknown"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/reference/react",
    "https://react.dev/reference/react/hooks",
    "https://react.dev/reference/react/useRef",
    "https://react.dev/learn/referencing-values-with-refs",
    "https://react.dev/reference/react/useState",
    "https://react.dev/learn/keeping-components-pure",
    "https://react.dev/learn/passing-props-to-a-component",
    "https://react.dev/learn/state-a-components-memory",
    "https://react.dev/learn/passing-data-deeply-with-context",
    "https://react.dev/learn/manipulating-the-dom-with-refs",
    "https://react.dev/reference/react-dom/components/common",
    "https://react.dev/reference/react/useReducer"
  ]
}