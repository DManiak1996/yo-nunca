{
  "url": "https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library",
  "title": "incompatible-library",
  "content": "Validates against usage of libraries which are incompatible with memoization (manual or automatic).\n\nThese libraries were designed before React’s memoization rules were fully documented. They made the correct choices at the time to optimize for ergonomic ways to keep components just the right amount of reactive as app state changes. While these legacy patterns worked, we have since discovered that it’s incompatible with React’s programming model. We will continue working with library authors to migrate these libraries to use patterns that follow the Rules of React.\n\nSome libraries use patterns that aren’t supported by React. When the linter detects usages of these APIs from a known list, it flags them under this rule. This means that React Compiler can automatically skip over components that use these incompatible APIs, in order to avoid breaking your app.\n\nReact Compiler automatically memoizes values following the Rules of React. If something breaks with manual useMemo, it will also break the compiler’s automatic optimization. This rule helps identify these problematic patterns.\n\nOne question to think about when designing a library API or hook is whether calling the API can be safely memoized with useMemo. If it can’t, then both manual and React Compiler memoizations will break your user’s code.\n\nFor example, one such incompatible pattern is “interior mutability”. Interior mutability is when an object or function keeps its own hidden state that changes over time, even though the reference to it stays the same. Think of it like a box that looks the same on the outside but secretly rearranges its contents. React can’t tell anything changed because it only checks if you gave it a different box, not what’s inside. This breaks memoization, since React relies on the outer object (or function) changing if part of its value has changed.\n\nAs a rule of thumb, when designing React APIs, think about whether useMemo would break it:\n\nInstead, design APIs that return immutable state and use explicit update functions:\n\nExamples of incorrect code for this rule:\n\nMobX patterns like observer also break memoization assumptions, but the linter does not yet detect them. If you rely on MobX and find that your app doesn’t work with React Compiler, you may need to use the \"use no memo\" directive.\n\nExamples of correct code for this rule:\n\nSome other libraries do not yet have alternative APIs that are compatible with React’s memoization model. If the linter doesn’t automatically skip over your components or hooks that call these APIs, please file an issue so we can add it to the linter.",
  "headings": [
    {
      "level": "h1",
      "text": "incompatible-library",
      "id": ""
    },
    {
      "level": "h3",
      "text": "Note",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Rule Details",
      "id": "rule-details"
    },
    {
      "level": "h5",
      "text": "Deep Dive",
      "id": ""
    },
    {
      "level": "h4",
      "text": "Designing APIs that follow the Rules of React",
      "id": "designing-apis-that-follow-the-rules-of-react"
    },
    {
      "level": "h3",
      "text": "Invalid",
      "id": "invalid"
    },
    {
      "level": "h3",
      "text": "Pitfall",
      "id": ""
    },
    {
      "level": "h4",
      "text": "MobX",
      "id": "mobx"
    },
    {
      "level": "h3",
      "text": "Valid",
      "id": "valid"
    }
  ],
  "code_samples": [
    {
      "code": "// Example of how memoization breaks with these librariesfunction Form() {  const { watch } = useForm();  // ❌ This value will never update, even when 'name' field changes  const name = useMemo(() => watch('name'), [watch]);  return <div>Name: {name}</div>; // UI appears \"frozen\"}",
      "language": "javascript"
    },
    {
      "code": "function Component() {  const { someFunction } = useLibrary();  // it should always be safe to memoize functions like this  const result = useMemo(() => someFunction(), [someFunction]);}",
      "language": "javascript"
    },
    {
      "code": "// ✅ Good: Return immutable state that changes reference when updatedfunction Component() {  const { field, updateField } = useLibrary();  // this is always safe to memo  const greeting = useMemo(() => `Hello, ${field.name}!`, [field.name]);  return (    <div>      <input        value={field.name}        onChange={(e) => updateField('name', e.target.value)}      />      <p>{greeting}</p>    </div>  );}",
      "language": "javascript"
    },
    {
      "code": "// ❌ react-hook-form `watch`function Component() {  const {watch} = useForm();  const value = watch('field'); // Interior mutability  return <div>{value}</div>;}// ❌ TanStack Table `useReactTable`function Component({data}) {  const table = useReactTable({    data,    columns,    getCoreRowModel: getCoreRowModel(),  });  // table instance uses interior mutability  return <Table table={table} />;}",
      "language": "javascript"
    },
    {
      "code": "// ❌ MobX `observer`const Component = observer(() => {  const [timer] = useState(() => new Timer());  return <span>Seconds passed: {timer.secondsPassed}</span>;});",
      "language": "javascript"
    },
    {
      "code": "// ✅ For react-hook-form, use `useWatch`:function Component() {  const {register, control} = useForm();  const watchedValue = useWatch({    control,    name: 'field'  });  return (    <>      <input {...register('field')} />      <div>Current value: {watchedValue}</div>    </>  );}",
      "language": "javascript"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/reference/react",
    "https://react.dev/reference/eslint-plugin-react-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization"
  ]
}