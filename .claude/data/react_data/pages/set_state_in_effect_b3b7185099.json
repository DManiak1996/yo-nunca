{
  "url": "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect",
  "title": "set-state-in-effect",
  "content": "Validates against calling setState synchronously in an effect, which can lead to re-renders that degrade performance.\n\nSetting state immediately inside an effect forces React to restart the entire render cycle. When you update state in an effect, React must re-render your component, apply changes to the DOM, and then run effects again. This creates an extra render pass that could have been avoided by transforming data directly during render or deriving state from props. Transform data at the top level of your component instead. This code will naturally re-run when props or state change without triggering additional render cycles.\n\nSynchronous setState calls in effects trigger immediate re-renders before the browser can paint, causing performance issues and visual jank. React has to render twice: once to apply the state update, then again after effects run. This double rendering is wasteful when the same result could be achieved with a single render.\n\nIn many cases, you may also not need an effect at all. Please see You Might Not Need an Effect for more information.\n\nThis rule catches several patterns where synchronous setState is used unnecessarily:\n\nExamples of incorrect code for this rule:\n\nExamples of correct code for this rule:\n\nWhen something can be calculated from the existing props or state, don’t put it in state. Instead, calculate it during rendering. This makes your code faster, simpler, and less error-prone. Learn more in You Might Not Need an Effect.",
  "headings": [
    {
      "level": "h1",
      "text": "set-state-in-effect",
      "id": ""
    },
    {
      "level": "h2",
      "text": "Rule Details",
      "id": "rule-details"
    },
    {
      "level": "h2",
      "text": "Common Violations",
      "id": "common-violations"
    },
    {
      "level": "h3",
      "text": "Invalid",
      "id": "invalid"
    },
    {
      "level": "h3",
      "text": "Valid",
      "id": "valid"
    }
  ],
  "code_samples": [
    {
      "code": "// ❌ Synchronous setState in effectfunction Component({data}) {  const [items, setItems] = useState([]);  useEffect(() => {    setItems(data); // Extra render, use initial state instead  }, [data]);}// ❌ Setting loading state synchronouslyfunction Component() {  const [loading, setLoading] = useState(false);  useEffect(() => {    setLoading(true); // Synchronous, causes extra render    fetchData().then(() => setLoading(false));  }, []);}// ❌ Transforming data in effectfunction Component({rawData}) {  const [processed, setProcessed] = useState([]);  useEffect(() => {    setProcessed(rawData.map(transform)); // Should derive in render  }, [rawData]);}// ❌ Deriving state from propsfunction Component({selectedId, items}) {  const [selected, setSelected] = useState(null);  useEffect(() => {    setSelected(items.find(i => i.id === selectedId));  }, [selectedId, items]);}",
      "language": "javascript"
    },
    {
      "code": "// ✅ setState in an effect is fine if the value comes from a reffunction Tooltip() {  const ref = useRef(null);  const [tooltipHeight, setTooltipHeight] = useState(0);  useLayoutEffect(() => {    const { height } = ref.current.getBoundingClientRect();    setTooltipHeight(height);  }, []);}// ✅ Calculate during renderfunction Component({selectedId, items}) {  const selected = items.find(i => i.id === selectedId);  return <div>{selected?.name}</div>;}",
      "language": "javascript"
    }
  ],
  "patterns": [],
  "links": [
    "https://react.dev/reference/react",
    "https://react.dev/reference/eslint-plugin-react-hooks",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect",
    "https://react.dev/learn/you-might-not-need-an-effect",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/refs",
    "https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render"
  ]
}