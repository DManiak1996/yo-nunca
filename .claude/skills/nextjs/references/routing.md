# Nextjs - Routing

**Pages:** 370

---

## Turbopack

**URL:** https://nextjs.org/docs/15/app/api-reference/turbopack

**Contents:**
- Turbopack
- Why Turbopack?
- Getting started
- Supported features
  - Language features
  - Framework and React features
  - CSS and styling
  - Assets
  - Module resolution
  - Performance and Fast Refresh

Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. You can use Turbopack with both the Pages and App Router for a much faster local development experience.

We built Turbopack to push the performance of Next.js, including:

To enable Turbopack in your Next.js project, add the --turbopack flag to the dev and build scripts in your package.json file:

Currently, Turbopack for dev is stable, while build is in beta. We are actively working on production support as Turbopack moves closer to stability.

Turbopack in Next.js has zero-configuration for the common use cases. Below is a summary of what is supported out of the box, plus some references to how you can configure Turbopack further when needed.

There are a number of non-trivial behavior differences between webpack and Turbopack that are important to be aware of when migrating an application. Generally, these are less of a concern for new applications.

Turbopack will follow JS import order to order CSS modules which are not otherwise ordered. For example:

In this example, Turbopack will ensure that utils.module.css will appear before button.module.css in the produced CSS chunk, following the import order

Webpack generally does this as well, but there are cases where it will ignore JS inferred ordering, for example if it infers the JS file is side-effect-free.

This can lead to subtle rendering changes when adopting Turbopack, if applications have come to rely on an arbitrary ordering. Generally, the solution is easy, e.g. have button.module.css @import utils.module.css to force the ordering, or identify the conflicting rules and change them to not target the same properties.

Turbopack does not yet have an equivalent to the Inner Graph Optimization in webpack. This optimization is useful to tree shake large modules. For example:

If an application only uses CONSTANT_VALUE Turbopack will detect this and delete the usesHeavy export but not the corresponding import. However, with the optimization.innerGraph = true option enabled, webpack can delete the import too.

We are planning to offer an equivalent to the innerGraph optimization in Turbopack but it is still under development. If you are affected by this gap, consider manually splitting these modules.

Webpack supports disk build caching to speed up builds. We are planning to support an analogous feature in Turbopack but it is not ready yet. On the next@canary release you can experiment with our solution by enabling the experimental.turbopackPersistentCaching flag.

Good to know: For this reason, when comparing webpack and Turbopack performance, make sure to delete the .next folder between builds to see a fair comparison.

Turbopack does not support webpack plugins. This affects third-party tools that rely on webpack's plugin system for integration. We do support webpack loaders. If you depend on webpack plugins, you'll need to find Turbopack-compatible alternatives or continue using webpack until equivalent functionality is available.

Some features are not yet implemented or not planned:

For a full, detailed breakdown of each feature flag and its status, see the Turbopack API Reference.

Turbopack can be configured via next.config.js (or next.config.ts) under the turbopack key. Configuration options include:

For more in-depth configuration examples, see the Turbopack config documentation.

If you encounter performance or memory issues and want to help the Next.js team diagnose them, you can generate a trace file by appending NEXT_TURBOPACK_TRACING=1 to your dev command:

This will produce a .next/trace-turbopack file. Include that file when creating a GitHub issue on the Next.js repo to help us investigate.

Turbopack is a Rust-based, incremental bundler designed to make local development and builds fastâ€”especially for large applications. It is integrated into Next.js, offering zero-config CSS, React, and TypeScript support.

Stay tuned for more updates as we continue to improve Turbopack and add production build support. In the meantime, give it a try with next dev --turbopack and let us know your feedback.

**Examples:**

Example 1 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start"
  }
}
```

Example 2 (python):
```python
import utilStyles from './utils.module.css'
import buttonStyles from './button.module.css'
export default function BlogPost() {
  return (
    <div className={utilStyles.container}>
      <button className={buttonStyles.primary}>Click me</button>
    </div>
  )
}
```

Example 3 (python):
```python
import heavy from 'some-heavy-dependency.js'
 
export function usesHeavy() {
  return heavy.run()
}
 
export const CONSTANT_VALUE = 3
```

Example 4 (unknown):
```unknown
module.exports = {
  turbopack: {
    // Example: adding an alias and custom file extension
    resolveAlias: {
      underscore: 'lodash',
    },
    resolveExtensions: ['.mdx', '.tsx', '.ts', '.jsx', '.js', '.json'],
  },
}
```

---

## template.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/template

**Contents:**
- template.js
- Convention
- Props
  - children (required)
- Behavior
  - Templates during navigation and remounting
- Version History

A template file is similar to a layout in that it wraps a layout or page. Unlike layouts that persist across routes and maintain state, templates are given a unique key, meaning children Client Components reset their state on navigation.

They are useful when you need to:

A template can be defined by exporting a default React component from a template.js file. The component should accept a children prop.

In terms of nesting, template.js is rendered between a layout and its children. Here's a simplified output:

Template accepts a children prop.

This section illustrates how templates behave during navigation. It shows, step by step, which templates remount on each route change and why.

Using this project tree:

Starting at /, the React tree looks roughly like this.

Note: The key values shown in the examples are illustrative, the values in your application may differ.

Navigating to /about (first segment changes), the root template key changes, it remounts:

Navigating to /blog (first segment changes), the root template key changes, it remounts and the blog-level template mounts:

Navigating within the same first segment to /blog/first-post (child segment changes), the root template key doesn't change, but the blog-level template key changes, it remounts:

Navigating to /blog/second-post (same first segment, different child segment), the root template key doesn't change, but the blog-level template key changes, it remounts again:

**Examples:**

Example 1 (unknown):
```unknown
export default function Template({ children }: { children: React.ReactNode }) {
  return <div>{children}</div>
}
```

Example 2 (unknown):
```unknown
<Layout>
  {/* Note that the template is given a unique key. */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

Example 3 (unknown):
```unknown
<Layout>
  {/* Note that the template is automatically given a unique key. */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

Example 4 (unknown):
```unknown
app
â”œâ”€â”€ about
â”‚Â Â  â”œâ”€â”€ page.tsx
â”œâ”€â”€ blog
â”‚Â Â  â”œâ”€â”€ [slug]
â”‚Â Â  â”‚Â Â  â””â”€â”€ page.tsx
â”‚Â Â  â”œâ”€â”€ page.tsx
â”‚Â Â  â””â”€â”€ template.tsx
â”œâ”€â”€ layout.tsx
â”œâ”€â”€ page.tsx
â””â”€â”€ template.tsx
```

---

## Cache Components

**URL:** https://nextjs.org/docs/app/building-your-application/rendering

**Contents:**
- Cache Components
- Cache Components
- How it works
  - 1. Suspense for runtime data
  - 2. Suspense for dynamic data
  - 3. Cached data with use cache
- Using Suspense boundaries
  - Missing Suspense boundaries
  - How streaming works
- Using use cache

Cache Components is a new approach to rendering and caching in Next.js that provides fine-grained control over what gets cached and when, while ensuring a great user experience through Partial Prerendering (PPR).

When developing dynamic applications, you have to balance two primary approaches:

With Cache Components enabled, Next.js treats all routes as dynamic by default. Every request renders with the latest available data. However, most pages are made up of both static and dynamic parts, and not all dynamic data needs to be resolved from source on every request.

Cache Components allows you to mark data, and even parts of your UI as cacheable, which includes them in the pre-render pass alongside static parts of the page.

Before Cache Components, Next.js tried to statically optimize entire pages automatically, which could lead to unexpected behavior when adding dynamic code.

Cache Components implements Partial Prerendering (PPR), and use cache to give you the best of both worlds:

When a user visits a route:

ðŸŽ¥ Watch: Why PPR and how it works â†’ YouTube (10 minutes).

Good to know: Cache Components is an opt-in feature. Enable it by setting the cacheComponents flag to true in your Next config file. See Enabling Cache Components for more details.

Cache Components gives you three key tools to control rendering:

Some data is only available at runtime when an actual user makes a request. APIs like cookies, headers, and searchParams access request-specific information. Wrap components using these APIs in Suspense boundaries so the rest of the page can be pre-rendered as a static shell.

Runtime APIs include:

Dynamic data like fetch calls or database queries (db.query(...)) can change between requests but isn't user-specific. The connection API is meta-dynamicâ€”it represents waiting for a user navigation even though there's no actual data to return. Wrap components that use these in Suspense boundaries to enable streaming.

Dynamic data patterns include:

Add use cache to any Server Component to make it cached and include it in the pre-rendered shell. You cannot use runtime APIs from inside a cached component. You can also mark utility functions as use cache and call them from Server Components.

React Suspense boundaries let you define what fallback UI to use when it wraps dynamic or runtime data.

Content outside the boundary, including the fallback UI, is pre-rendered as a static shell, while content inside the boundary streams in when ready.

Here's how to use Suspense with Cache Components:

At build time, Next.js pre-renders the static content and the fallback UI, while the dynamic content is postponed until a user requests the route.

Good to know: Wrapping a component in Suspense doesn't make it dynamic; your API usage does. Suspense acts as a boundary that encapsulates dynamic content and enables streaming.

Cache Components enforces that dynamic code must be wrapped in a Suspense boundary. If you forget, you'll see the Uncached data was accessed outside of <Suspense> error:

Uncached data was accessed outside of <Suspense>

This delays the entire page from rendering, resulting in a slow user experience. Next.js uses this error to ensure your app loads instantly on every navigation.

To fix this, you can either:

Wrap the component in a <Suspense> boundary. This allows Next.js to stream its contents to the user as soon as it's ready, without blocking the rest of the app.

Move the asynchronous await into a Cache Component("use cache"). This allows Next.js to statically prerender the component as part of the HTML document, so it's instantly visible to the user.

Note that request-specific information, such as params, cookies, and headers, is not available during static prerendering, so it must be wrapped in <Suspense>.

This error helps prevent a situation where, instead of getting a static shell instantly, users would hit a blocking runtime render with nothing to show. To fix it, add a Suspense boundary or use use cache to cache the work instead.

Streaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.

With partial pre-rendering, the initial UI can be sent immediately to the browser while the dynamic parts render. This decreases time to UI and may decrease total request time depending on how much of your UI is pre-rendered.

To reduce network overhead, the full response, including static HTML and streamed dynamic parts, is sent in a single HTTP request. This avoids extra round-trips and improves both initial load and overall performance.

While Suspense boundaries manage dynamic content, the use cache directive is available for caching data or computations that don't change often.

Add use cache to cache a page, component, or async function, and define a lifetime with cacheLife:

When using use cache, keep these constraints in mind:

Like Server Actions, arguments to cached functions must be serializable. This means you can pass primitives, plain objects, and arrays, but not class instances, functions, or other complex types.

You can accept unserializable values as arguments as long as you don't introspect them. However, you can return them. This allows patterns like cached components that accept Server or Client Components as children:

Tag cached data with cacheTag and revalidate it after mutations using updateTag in Server Actions for immediate updates, or revalidateTag delay in updates are acceptable.

Use updateTag when you need to expire and immediately refresh cached data within the same request:

Use revalidateTag when you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency.

For more detailed explanation and usage examples, see the use cache API reference.

You can enable Cache Components (which includes PPR) by adding the cacheComponents option to your Next config file:

When the cacheComponents flag is enabled, Next.js uses React's <Activity> component to preserve component state during client-side navigation.

Rather than unmounting the previous route when you navigate away, Next.js sets the Activity mode to "hidden". This means:

This behavior improves the navigation experience by maintaining UI state (form inputs, or expanded sections) when users navigate back and forth between routes.

Good to know: Next.js uses heuristics to keep a few recently visited routes "hidden", while older routes are removed from the DOM to prevent excessive growth.

When Cache Components is enabled, several route segment config options are no longer needed or supported. Here's what changes and how to migrate:

Not needed. All pages are dynamic by default with Cache Components enabled, so this configuration is unnecessary.

Replace with use cache. You must add use cache to each Layout and Page for the associated route instead.

Note: force-static previously allowed the use of runtime APIs like cookies(), but this is no longer supported. If you add use cache and see an error related to runtime data, you must remove the use of runtime APIs.

Replace with cacheLife. Use the cacheLife function to define cache duration instead of the route segment config.

Not needed. With use cache, all data fetching within a cached scope is automatically cached, making fetchCache unnecessary.

Not supported. Cache Components requires Node.js runtime and will throw errors with Edge Runtime.

Understanding how Cache Components changes your mental model:

When accessing runtime APIs like cookies(), Next.js will only pre-render the fallback UI above this component.

In this example, we have no fallback defined, so Next.js shows an error instructing us to provide one. The <User /> component needs to be wrapped in Suspense because it uses the cookies API:

Now we have a Suspense boundary around our User component we can pre-render the Page with a Skeleton UI and stream in the <User /> UI when a specific user makes a request

Components that access runtime values like cookies or searchParams cannot be prerendered. To prerender more of a page's content, you can pass these props down and access their values lower in the tree. For example, if you are reading searchParams from a <Page /> component, you can forward this value to another component as a prop:

Inside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be pre-rendered.

GET Route Handlers follow the same model as normal UI routes in your application. They are dynamic by default, can be pre-rendered when deterministic, and you can use cache to include more dynamic data in the cached response.

Dynamic example, returns a different number for every request:

A handler that returns only static data will be pre-rendered at build time:

If you had a route that returned fresh dynamic data on every request, say products from a database:

To cache this and avoid hitting the database on every request, extract the dynamic work into a use cache function and set cacheLife('hours') so the database is queried at most once per hour:

No. Cache Components implements PPR as a feature. The old experimental PPR flag has been removed but PPR is here to stay.

PPR provides the static shell and streaming infrastructure; use cache lets you include optimized dynamic output in that shell when beneficial.

What you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use use cache with cacheLife to describe that behavior.

For content management systems with update mechanisms, consider using tags with longer cache durations and rely on revalidateTag to mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively.

Use cacheTag to tag your cached data, then trigger updateTag or revalidateTag.

**Examples:**

Example 1 (javascript):
```javascript
export async function getProducts() {
  'use cache'
  const data = await db.query('SELECT * FROM products')
  return data
}
```

Example 2 (python):
```python
import { Suspense } from 'react'
 
export default function Page() {
  return (
    <>
      <h1>This will be pre-rendered</h1>
      <Suspense fallback={<Skeleton />}>
        <DynamicContent />
      </Suspense>
    </>
  )
}
 
async function DynamicContent() {
  const res = await fetch('http://api.cms.com/posts')
  const { posts } = await res.json()
  return <div>{/* ... */}</div>
}
```

Example 3 (python):
```python
import { cacheLife } from 'next/cache'
 
export default async function Page() {
  'use cache'
  cacheLife('hours')
  // fetch or compute
  return <div>...</div>
}
```

Example 4 (python):
```python
import type { ReactNode } from 'react'
import { setTimeout } from 'node:timers/promises'
 
async function getSiteTitle() {
  // Simulate a slow database or API call
  await setTimeout(1000) // from 'node:timers/promises'
  return 'My Website'
}
 
export async function CachedWrapper({ children }: { children: ReactNode }) {
  'use cache'
  const title = await getSiteTitle()
 
  // Don't introspect children, just pass it through
  return (
    <div className="wrapper">
      <h1>{title}</h1>
      {children}
    </div>
  )
}
```

---

## useReportWebVitals

**URL:** https://nextjs.org/docs/app/api-reference/functions/use-report-web-vitals

**Contents:**
- useReportWebVitals
- useReportWebVitals
- Web Vitals
- Sending results to external systems

The useReportWebVitals hook allows you to report Core Web Vitals, and can be used in combination with your analytics service.

New functions passed to useReportWebVitals are called with the available metrics up to that point. To prevent reporting duplicated data, ensure that the callback function reference does not change (as shown in the code examples below).

Since the useReportWebVitals hook requires the 'use client' directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component.

The metric object passed as the hook's argument consists of a number of properties:

Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:

You can handle all the results of these metrics using the name property.

You can send results to any endpoint to measure and track real user performance on your site. For example:

Good to know: If you use Google Analytics, using the id value can allow you to construct metric distributions manually (to calculate percentiles, etc.)

Read more about sending results to Google Analytics.

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useReportWebVitals } from 'next/web-vitals'
 
const logWebVitals = (metric) => {
  console.log(metric)
}
 
export function WebVitals() {
  useReportWebVitals(logWebVitals)
 
  return null
}
```

Example 2 (python):
```python
import { WebVitals } from './_components/web-vitals'
 
export default function Layout({ children }) {
  return (
    <html>
      <body>
        <WebVitals />
        {children}
      </body>
    </html>
  )
}
```

Example 3 (python):
```python
'use client'
 
import { useReportWebVitals } from 'next/web-vitals'
 
type ReportWebVitalsCallback = Parameters<typeof useReportWebVitals>[0]
 
const handleWebVitals: ReportWebVitalsCallback = (metric) => {
  switch (metric.name) {
    case 'FCP': {
      // handle FCP results
    }
    case 'LCP': {
      // handle LCP results
    }
    // ...
  }
}
 
export function WebVitals() {
  useReportWebVitals(handleWebVitals)
}
```

Example 4 (javascript):
```javascript
function postWebVitals(metrics) {
  const body = JSON.stringify(metric)
  const url = 'https://example.com/analytics'
 
  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body)
  } else {
    fetch(url, { body, method: 'POST', keepalive: true })
  }
}
 
useReportWebVitals(postWebVitals)
```

---

## serverComponentsHmrCache

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/serverComponentsHmrCache

**Contents:**
- serverComponentsHmrCache

The experimental serverComponentsHmrCache option allows you to cache fetch responses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls.

By default, the HMR cache applies to all fetch requests, including those with the cache: 'no-store' option. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads.

You can disable the HMR cache by setting serverComponentsHmrCache to false in your next.config.js file:

Good to know: For better observability, we recommend using the logging.fetches option which logs fetch cache hits and misses in the console during development.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    serverComponentsHmrCache: false, // defaults to true
  },
}
 
export default nextConfig
```

---

## How to install Tailwind CSS v3 in your Next.js application

**URL:** https://nextjs.org/docs/app/guides/tailwind-v3-css

**Contents:**
- How to install Tailwind CSS v3 in your Next.js application
- Installing Tailwind v3
- Configuring Tailwind v3
- Using classes
- Usage with Turbopack

This guide will walk you through how to install Tailwind CSS v3 in your Next.js application.

Good to know: For the latest Tailwind 4 setup, see the Tailwind CSS setup instructions.

Install Tailwind CSS and its peer dependencies, then run the init command to generate both tailwind.config.js and postcss.config.js files:

Configure your template paths in your tailwind.config.js file:

Add the Tailwind directives to your global CSS file:

Import the CSS file in your root layout:

After installing Tailwind CSS and adding the global styles, you can use Tailwind's utility classes in your application.

As of Next.js 13.1, Tailwind CSS and PostCSS are supported with Turbopack.

**Examples:**

Example 1 (unknown):
```unknown
pnpm add -D tailwindcss@^3 postcss autoprefixer
npx tailwindcss init -p
```

Example 2 (unknown):
```unknown
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

Example 3 (unknown):
```unknown
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Example 4 (unknown):
```unknown
import './globals.css'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

---

## How to upgrade to version 13

**URL:** https://nextjs.org/docs/pages/guides/upgrading/version-13

**Contents:**
- How to upgrade to version 13
- Upgrading from 12 to 13
  - v13 Summary
- Migrating shared features
  - <Image/> Component
  - <Link> Component
  - <Script> Component
  - Font Optimization

To update to Next.js version 13, run the following command using your preferred package manager:

Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions.

Next.js 13 introduces a new app directory with new features and conventions. However, upgrading to Next.js 13 does not require using the new app Router.

You can continue using pages with new features that work in both directories, such as the updated Image component, Link component, Script component, and Font optimization.

Next.js 12 introduced many improvements to the Image Component with a temporary import: next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading.

Starting in Next.js 13, this new behavior is now the default for next/image.

There are two codemods to help you migrate to the new Image Component:

Alternatively, you can manually update by following the migration guide and also see the legacy comparison.

The <Link> Component no longer requires manually adding an <a> tag as a child. This behavior was added as an experimental option in version 12.2 and is now the default. In Next.js 13, <Link> always renders <a> and allows you to forward props to the underlying tag.

To upgrade your links to Next.js 13, you can use the new-link codemod.

The behavior of next/script has been updated to support both pages and app. If incrementally adopting app, read the upgrade guide.

Previously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new next/font module which gives you the ability to customize your font loading experience while still ensuring great performance and privacy.

See Optimizing Fonts to learn how to use next/font.

**Examples:**

Example 1 (unknown):
```unknown
npm i next@13 react@latest react-dom@latest eslint-config-next@13
```

Example 2 (unknown):
```unknown
yarn add next@13 react@latest react-dom@latest eslint-config-next@13
```

Example 3 (unknown):
```unknown
pnpm i next@13 react@latest react-dom@latest eslint-config-next@13
```

Example 4 (unknown):
```unknown
bun add next@13 react@latest react-dom@latest eslint-config-next@13
```

---

## Testing

**URL:** https://nextjs.org/docs/15/app/guides/testing

**Contents:**
- Testing
- Types of tests
- Async Server Components
- Guides
  - Cypress
  - Jest
  - Playwright
  - Vitest

In React and Next.js, there are a few different types of tests you can write, each with its own purpose and use cases. This page provides an overview of types and commonly used tools you can use to test your application.

Since async Server Components are new to the React ecosystem, some tools do not fully support them. In the meantime, we recommend using End-to-End Testing over Unit Testing for async components.

See the guides below to learn how to set up Next.js with these commonly used testing tools:

---

## generateImageMetadata

**URL:** https://nextjs.org/docs/app/api-reference/functions/generate-image-metadata

**Contents:**
- generateImageMetadata
- Parameters
    - params (optional)
- Returns
- Image generation function props
    - id
    - params (optional)
  - Examples
    - Using external data
- Version History

You can use generateImageMetadata to generate different versions of one image or return multiple images for one route segment. This is useful for when you want to avoid hard-coding metadata values, such as for icons.

generateImageMetadata function accepts the following parameters:

An object containing the dynamic route parameters object from the root segment down to the segment generateImageMetadata is called from.

The generateImageMetadata function should return an array of objects containing the image's metadata such as alt and size. In addition, each item must include an id value which will be passed as a promise to the props of the image generating function.

When using generateImageMetadata, the default export image generation function receives the following props:

A promise that resolves to the id value from one of the items returned by generateImageMetadata. The id will be a string or number depending on what was returned from generateImageMetadata.

A promise that resolves to an object containing the dynamic route parameters from the root segment down to the segment the image is colocated in.

This example uses the params object and external data to generate multiple Open Graph images for a route segment.

**Examples:**

Example 1 (unknown):
```unknown
export function generateImageMetadata({
  params,
}: {
  params: { slug: string }
}) {
  // ...
}
```

Example 2 (python):
```python
import { ImageResponse } from 'next/og'
 
export function generateImageMetadata() {
  return [
    {
      contentType: 'image/png',
      size: { width: 48, height: 48 },
      id: 'small',
    },
    {
      contentType: 'image/png',
      size: { width: 72, height: 72 },
      id: 'medium',
    },
  ]
}
 
export default async function Icon({ id }: { id: Promise<string | number> }) {
  const iconId = await id
  return new ImageResponse(
    (
      <div
        style={{
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: 88,
          background: '#000',
          color: '#fafafa',
        }}
      >
        Icon {iconId}
      </div>
    )
  )
}
```

Example 3 (javascript):
```javascript
export default async function Icon({ id }: { id: Promise<string | number> }) {
  const iconId = await id
  // Use iconId to generate the image
}
```

Example 4 (javascript):
```javascript
export default async function Icon({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  // Use slug to generate the image
}
```

---

## staticGeneration*

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/staticGeneration

**Contents:**
- staticGeneration*
- Config Options

The staticGeneration* options allow you to configure the Static Generation process for advanced use cases.

The following options are available:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    staticGenerationRetryCount: 1,
    staticGenerationMaxConcurrency: 8,
    staticGenerationMinPagesPerWorker: 25,
  },
}
 
export default nextConfig
```

---

## cacheLife

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/cacheLife

**Contents:**
- cacheLife
- Usage
- Reference

The cacheLife option allows you to define custom cache profiles when using the cacheLife function inside components or functions, and within the scope of the use cache directive.

To define a profile, enable the cacheComponents flag and add the cache profile in the cacheLife object in the next.config.js file. For example, a blog profile:

You can now use this custom blog configuration in your component or function as follows:

The configuration object has key values with the following format:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  cacheComponents: true,
  cacheLife: {
    blog: {
      stale: 3600, // 1 hour
      revalidate: 900, // 15 minutes
      expire: 86400, // 1 day
    },
  },
}
 
export default nextConfig
```

Example 2 (python):
```python
import { cacheLife } from 'next/cache'
 
export async function getCachedData() {
  'use cache'
  cacheLife('blog')
  const data = await fetch('/api/data')
  return data
}
```

---

## File-system conventions

**URL:** https://nextjs.org/docs/pages/api-reference/file-conventions

**Contents:**
- File-system conventions
  - instrumentation.js
  - Proxy
  - public
  - src Directory

---

## useSelectedLayoutSegment

**URL:** https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment

**Contents:**
- useSelectedLayoutSegment
- Parameters
- Returns
- Examples
  - Creating an active link component
- Version History

useSelectedLayoutSegment is a Client Component hook that lets you read the active route segment one level below the Layout it is called from.

It is useful for navigation UI, such as tabs inside a parent layout that change style depending on the active child segment.

useSelectedLayoutSegment optionally accepts a parallelRoutesKey, which allows you to read the active route segment within that slot.

useSelectedLayoutSegment returns a string of the active segment or null if one doesn't exist.

For example, given the Layouts and URLs below, the returned segment would be:

You can use useSelectedLayoutSegment to create an active link component that changes style depending on the active segment. For example, a featured posts list in the sidebar of a blog:

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useSelectedLayoutSegment } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const segment = useSelectedLayoutSegment()
 
  return <p>Active segment: {segment}</p>
}
```

Example 2 (javascript):
```javascript
const segment = useSelectedLayoutSegment(parallelRoutesKey?: string)
```

Example 3 (python):
```python
'use client'
 
import Link from 'next/link'
import { useSelectedLayoutSegment } from 'next/navigation'
 
// This *client* component will be imported into a blog layout
export default function BlogNavLink({
  slug,
  children,
}: {
  slug: string
  children: React.ReactNode
}) {
  // Navigating to `/blog/hello-world` will return 'hello-world'
  // for the selected layout segment
  const segment = useSelectedLayoutSegment()
  const isActive = slug === segment
 
  return (
    <Link
      href={`/blog/${slug}`}
      // Change style depending on whether the link is active
      style={{ fontWeight: isActive ? 'bold' : 'normal' }}
    >
      {children}
    </Link>
  )
}
```

Example 4 (python):
```python
// Import the Client Component into a parent Layout (Server Component)
import { BlogNavLink } from './blog-nav-link'
import getFeaturedPosts from './get-featured-posts'
 
export default async function Layout({
  children,
}: {
  children: React.ReactNode
}) {
  const featuredPosts = await getFeaturedPosts()
  return (
    <div>
      {featuredPosts.map((post) => (
        <div key={post.id}>
          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>
        </div>
      ))}
      <div>{children}</div>
    </div>
  )
}
```

---

## How to instrument your Next.js app with OpenTelemetry

**URL:** https://nextjs.org/docs/pages/guides/open-telemetry

**Contents:**
- How to instrument your Next.js app with OpenTelemetry
- Getting Started
  - Using @vercel/otel
  - Manual OpenTelemetry configuration
- Testing your instrumentation
- Deployment
  - Using OpenTelemetry Collector
    - Deploying on Vercel
    - Self-hosting
  - Custom Exporters

Observability is crucial for understanding and optimizing the behavior and performance of your Next.js app.

As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience.

We recommend using OpenTelemetry for instrumenting your apps. It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code. Read Official OpenTelemetry docs for more information about OpenTelemetry and how it works.

This documentation uses terms like Span, Trace or Exporter throughout this doc, all of which can be found in the OpenTelemetry Observability Primer.

Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself.

When you enable OpenTelemetry we will automatically wrap all your code like getStaticProps in spans with helpful attributes.

OpenTelemetry is extensible but setting it up properly can be quite verbose. That's why we prepared a package @vercel/otel that helps you get started quickly.

To get started, install the following packages:

Next, create a custom instrumentation.ts (or .js) file in the root directory of the project (or inside src folder if using one):

See the @vercel/otel documentation for additional configuration options.

The @vercel/otel package provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually.

Firstly you need to install OpenTelemetry packages:

Now you can initialize NodeSDK in your instrumentation.ts. Unlike @vercel/otel, NodeSDK is not compatible with edge runtime, so you need to make sure that you are importing them only when process.env.NEXT_RUNTIME === 'nodejs'. We recommend creating a new file instrumentation.node.ts which you conditionally import only when using node:

Doing this is equivalent to using @vercel/otel, but it's possible to modify and extend some features that are not exposed by the @vercel/otel. If edge runtime support is necessary, you will have to use @vercel/otel.

You need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally. We recommend using our OpenTelemetry dev environment.

If everything works well you should be able to see the root server span labeled as GET /requested/pathname. All other spans from that particular trace will be nested under it.

Next.js traces more spans than are emitted by default. To see more spans, you must set NEXT_OTEL_VERBOSE=1.

When you are deploying with OpenTelemetry Collector, you can use @vercel/otel. It will work both on Vercel and when self-hosted.

We made sure that OpenTelemetry works out of the box on Vercel.

Follow Vercel documentation to connect your project to an observability provider.

Deploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process the telemetry data from your Next.js app.

To do this, follow the OpenTelemetry Collector Getting Started guide, which will walk you through setting up the collector and configuring it to receive data from your Next.js app.

Once you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective deployment guides.

OpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with @vercel/otel or manual OpenTelemetry configuration.

You can add a custom span with OpenTelemetry APIs.

The following example demonstrates a function that fetches GitHub stars and adds a custom fetchGithubStars span to track the fetch request's result:

The register function will execute before your code runs in a new environment. You can start creating new spans, and they should be correctly added to the exported trace.

Next.js automatically instruments several spans for you to provide useful insights into your application's performance.

Attributes on spans follow OpenTelemetry semantic conventions. We also add some custom attributes under the next namespace:

This span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and status code of the request.

This span represents the process of rendering a route in the app router.

This span represents the fetch request executed in your code.

This span can be turned off by setting NEXT_OTEL_FETCH_DISABLED=1 in your environment. This is useful when you want to use a custom fetch instrumentation library.

This span represents the execution of an API Route Handler in the app router.

This span represents the execution of getServerSideProps for a specific route.

This span represents the execution of getStaticProps for a specific route.

This span represents the process of rendering the document for a specific route.

This span represents the process of generating metadata for a specific page (a single route can have multiple of these spans).

This span represents the process of resolving page components for a specific page.

This span represents loading of code modules for a layout or a page.

This zero-length span represents the time when the first byte has been sent in the response.

**Examples:**

Example 1 (unknown):
```unknown
npm install @vercel/otel @opentelemetry/sdk-logs @opentelemetry/api-logs @opentelemetry/instrumentation
```

Example 2 (python):
```python
import { registerOTel } from '@vercel/otel'
 
export function register() {
  registerOTel({ serviceName: 'next-app' })
}
```

Example 3 (unknown):
```unknown
npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http
```

Example 4 (unknown):
```unknown
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./instrumentation.node.ts')
  }
}
```

---

## How to set up instrumentation

**URL:** https://nextjs.org/docs/app/guides/instrumentation

**Contents:**
- How to set up instrumentation
- Convention
- Examples
  - Importing files with side effects
  - Importing runtime-specific code
- Learn more about Instrumentation
  - instrumentation.js

Instrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production.

To set up instrumentation, create instrumentation.ts|js file in the root directory of your project (or inside the src folder if using one).

Then, export a register function in the file. This function will be called once when a new Next.js server instance is initiated.

For example, to use Next.js with OpenTelemetry and @vercel/otel:

See the Next.js with OpenTelemetry example for a complete implementation.

Sometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared.

We recommend importing files using JavaScript import syntax within your register function. The following example demonstrates a basic usage of import in a register function:

We recommend importing the file from within the register function, rather than at the top of the file. By doing this, you can colocate all of your side effects in one place in your code, and avoid any unintended consequences from importing globally at the top of the file.

Next.js calls register in all environments, so it's important to conditionally import any code that doesn't support specific runtimes (e.g. Edge or Node.js). You can use the NEXT_RUNTIME environment variable to get the current environment:

**Examples:**

Example 1 (python):
```python
import { registerOTel } from '@vercel/otel'
 
export function register() {
  registerOTel('next-app')
}
```

Example 2 (unknown):
```unknown
export async function register() {
  await import('package-with-side-effect')
}
```

Example 3 (unknown):
```unknown
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./instrumentation-node')
  }
 
  if (process.env.NEXT_RUNTIME === 'edge') {
    await import('./instrumentation-edge')
  }
}
```

---

## logging

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/logging

**Contents:**
- logging
- Options
  - Fetching
  - Incoming Requests
  - Disabling Logging

You can configure the logging level and whether the full URL is logged to the console when running Next.js in development mode.

Currently, logging only applies to data fetching using the fetch API. It does not yet apply to other logs inside of Next.js.

Any fetch requests that are restored from the Server Components HMR cache are not logged by default. However, this can be enabled by setting logging.fetches.hmrRefreshes to true.

By default all the incoming requests will be logged in the console during development. You can use the incomingRequests option to decide which requests to ignore. Since this is only logged in development, this option doesn't affect production builds.

Or you can disable incoming request logging by setting incomingRequests to false.

In addition, you can disable the development logging by setting logging to false.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  logging: {
    fetches: {
      fullUrl: true,
    },
  },
}
```

Example 2 (unknown):
```unknown
module.exports = {
  logging: {
    fetches: {
      hmrRefreshes: true,
    },
  },
}
```

Example 3 (unknown):
```unknown
module.exports = {
  logging: {
    incomingRequests: {
      ignore: [/\api\/v1\/health/],
    },
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  logging: {
    incomingRequests: false,
  },
}
```

---

## How to optimize third-party libraries

**URL:** https://nextjs.org/docs/pages/guides/third-party-libraries

**Contents:**
- How to optimize third-party libraries
- Getting Started
- Google Third-Parties
  - Google Tag Manager
    - Sending Events
    - Server-side Tagging
    - Options
  - Google Analytics
    - Sending Events
    - Tracking Pageviews

@next/third-parties is a library that provides a collection of components and utilities that improve the performance and developer experience of loading popular third-party libraries in your Next.js application.

All third-party integrations provided by @next/third-parties have been optimized for performance and ease of use.

To get started, install the @next/third-parties library:

@next/third-parties is currently an experimental library under active development. We recommend installing it with the latest or canary flags while we work on adding more third-party integrations.

All supported third-party libraries from Google can be imported from @next/third-parties/google.

The GoogleTagManager component can be used to instantiate a Google Tag Manager container to your page. By default, it fetches the original inline script after hydration occurs on the page.

To load Google Tag Manager for all routes, include the component directly in your custom _app and pass in your GTM container ID:

To load Google Tag Manager for a single route, include the component in your page file:

The sendGTMEvent function can be used to track user interactions on your page by sending events using the dataLayer object. For this function to work, the <GoogleTagManager /> component must be included in either a parent layout, page, or component, or directly in the same file.

Refer to the Tag Manager developer documentation to learn about the different variables and events that can be passed into the function.

If you're using a server-side tag manager and serving gtm.js scripts from your tagging server you can use gtmScriptUrl option to specify the URL of the script.

Options to pass to the Google Tag Manager. For a full list of options, read the Google Tag Manager docs.

*gtmId can be omitted when gtmScriptUrl is provided to support Google tag gateway for advertisers.

The GoogleAnalytics component can be used to include Google Analytics 4 to your page via the Google tag (gtag.js). By default, it fetches the original scripts after hydration occurs on the page.

Recommendation: If Google Tag Manager is already included in your application, you can configure Google Analytics directly using it, rather than including Google Analytics as a separate component. Refer to the documentation to learn more about the differences between Tag Manager and gtag.js.

To load Google Analytics for all routes, include the component directly in your custom _app and pass in your measurement ID:

To load Google Analytics for a single route, include the component in your page file:

The sendGAEvent function can be used to measure user interactions on your page by sending events using the dataLayer object. For this function to work, the <GoogleAnalytics /> component must be included in either a parent layout, page, or component, or directly in the same file.

Refer to the Google Analytics developer documentation to learn more about event parameters.

Google Analytics automatically tracks pageviews when the browser history state changes. This means that client-side navigations between Next.js routes will send pageview data without any configuration.

To ensure that client-side navigations are being measured correctly, verify that the â€œEnhanced Measurementâ€ property is enabled in your Admin panel and the â€œPage changes based on browser history eventsâ€ checkbox is selected.

Note: If you decide to manually send pageview events, make sure to disable the default pageview measurement to avoid having duplicate data. Refer to the Google Analytics developer documentation to learn more.

Options to pass to the <GoogleAnalytics> component.

The GoogleMapsEmbed component can be used to add a Google Maps Embed to your page. By default, it uses the loading attribute to lazy-load the embed below the fold.

Options to pass to the Google Maps Embed. For a full list of options, read the Google Map Embed docs.

The YouTubeEmbed component can be used to load and display a YouTube embed. This component loads faster by using lite-youtube-embed under the hood.

**Examples:**

Example 1 (unknown):
```unknown
npm install @next/third-parties@latest next@latest
```

Example 2 (python):
```python
import { GoogleTagManager } from '@next/third-parties/google'
 
export default function MyApp({ Component, pageProps }) {
  return (
    <>
      <Component {...pageProps} />
      <GoogleTagManager gtmId="GTM-XYZ" />
    </>
  )
}
```

Example 3 (python):
```python
import { GoogleTagManager } from '@next/third-parties/google'
 
export default function Page() {
  return <GoogleTagManager gtmId="GTM-XYZ" />
}
```

Example 4 (python):
```python
import { sendGTMEvent } from '@next/third-parties/google'
 
export function EventButton() {
  return (
    <div>
      <button
        onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}
      >
        Send Event
      </button>
    </div>
  )
}
```

---

## generateStaticParams

**URL:** https://nextjs.org/docs/app/api-reference/functions/generate-static-params

**Contents:**
- generateStaticParams
- Parameters
- Returns
- Single Dynamic Segment
- Multiple Dynamic Segments
- Catch-all Dynamic Segment
- Examples
  - Static Rendering
    - All paths at build time
    - Subset of paths at build time

The generateStaticParams function can be used in combination with dynamic route segments to statically generate routes at build time instead of on-demand at request time.

options.params (optional)

If multiple dynamic segments in a route use generateStaticParams, the child generateStaticParams function is executed once for each set of params the parent generates.

The params object contains the populated params from the parent generateStaticParams, which can be used to generate the params in a child segment.

generateStaticParams should return an array of objects where each object represents the populated dynamic segments of a single route.

To statically render all paths at build time, supply the full list of paths to generateStaticParams:

To statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:

Then, by using the dynamicParams segment config option, you can control what happens when a dynamic segment is visited that was not generated with generateStaticParams.

To statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static':

Good to know: You must always return an array from generateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered.

To prevent unspecified paths from being statically rendered at runtime, add the export const dynamicParams = false option in a route segment. When this config option is used, only paths provided by generateStaticParams will be served, and unspecified routes will 404 or match (in the case of catch-all routes).

You can generate params for dynamic segments above the current layout or page, but not below. For example, given the app/products/[category]/[product] route:

There are two approaches to generating params for a route with multiple dynamic segments:

Generate multiple dynamic segments from the child route segment.

Generate the parent segments first and use the result to generate the child segments.

A child route segment's generateStaticParams function is executed once for each segment a parent generateStaticParams generates.

The child generateStaticParams function can use the params returned from the parent generateStaticParams function to dynamically generate its own segments.

Notice that the params argument can be accessed synchronously and includes only parent segment params.

For type completion, you can make use of the TypeScript Awaited helper in combination with either Page Props helper or Layout Props helper:

Good to know: fetch requests are automatically memoized for the same data across all generate-prefixed functions, Layouts, Pages, and Server Components. React cache can be used if fetch is unavailable.

**Examples:**

Example 1 (javascript):
```javascript
// Return a list of `params` to populate the [slug] dynamic segment
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())
 
  return posts.map((post) => ({
    slug: post.slug,
  }))
}
 
// Multiple versions of this page will be statically generated
// using the `params` returned by `generateStaticParams`
export default async function Page({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  // ...
}
```

Example 2 (javascript):
```javascript
export function generateStaticParams() {
  return [{ id: '1' }, { id: '2' }, { id: '3' }]
}
 
// Three versions of this page will be statically generated
// using the `params` returned by `generateStaticParams`
// - /product/1
// - /product/2
// - /product/3
export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  // ...
}
```

Example 3 (javascript):
```javascript
export function generateStaticParams() {
  return [
    { category: 'a', product: '1' },
    { category: 'b', product: '2' },
    { category: 'c', product: '3' },
  ]
}
 
// Three versions of this page will be statically generated
// using the `params` returned by `generateStaticParams`
// - /products/a/1
// - /products/b/2
// - /products/c/3
export default async function Page({
  params,
}: {
  params: Promise<{ category: string; product: string }>
}) {
  const { category, product } = await params
  // ...
}
```

Example 4 (javascript):
```javascript
export function generateStaticParams() {
  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]
}
 
// Three versions of this page will be statically generated
// using the `params` returned by `generateStaticParams`
// - /product/a/1
// - /product/b/2
// - /product/c/3
export default async function Page({
  params,
}: {
  params: Promise<{ slug: string[] }>
}) {
  const { slug } = await params
  // ...
}
```

---

## How to upgrade to version 16

**URL:** https://nextjs.org/docs/app/guides/upgrading/version-16

**Contents:**
- How to upgrade to version 16
- Upgrading from 15 to 16
  - Using AI Agents with Next.js DevTools MCP
    - Setup
    - Example Prompts
  - Using the Codemod
- Node.js runtime and browser support
- Turbopack by default
  - Opting out of Turbopack
  - Turbopack configuration location

If you're using an AI coding assistant that supports the Model Context Protocol (MCP), you can use the Next.js DevTools MCP to automate the upgrade process and migration tasks.

Add the following configuration to your MCP client, example:

For more information, visit the next-devtools-mcp package on npm to configure with your MCP client.

Note: Using next-devtools-mcp@latest ensures that your MCP client will always use the latest version of the Next.js DevTools MCP server.

Once configured, you can use natural language prompts to upgrade your Next.js app:

To upgrade to Next.js 16:

Connect to your coding agent and then prompt:

To migrate to Cache Components (after upgrading to v16):

Connect to your coding agent and then prompt:

Learn more in the documentation here.

To update to Next.js version 16, you can use the upgrade codemod:

The codemod is able to:

If you prefer to do it manually, install the latest Next.js and React versions:

If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions.

Starting with Next.js 16, Turbopack is stable and used by default with next dev and next build

Previously you had to enable Turbopack using --turbopack, or --turbo.

This is no longer necessary. You can update your package.json scripts:

If your project has a custom webpack configuration and you run next build (which now uses Turbopack by default), the build will fail to prevent misconfiguration issues.

You have a few different ways to address this:

Good to know: If you see failing builds because a webpack configuration was found, but you don't define one yourself, it is likely that a plugin is adding a webpack option

If you need to continue using Webpack, you can opt out with the --webpack flag. For example, to use Turbopack in development but Webpack for production builds:

We recommend using Turbopack for development and production. Submit a comment to this thread, if you are unable to switch to Turbopack.

The experimental.turbopack configuration is out of experimental.

You can use it as a top-level turbopack option:

Make sure to review the Turbopack configuration options. Next.js 16 introduces various improvements and new options, for example:

In some projects, client-side code may import files containing Node.js native modules. This will cause Module not found: Can't resolve 'fs' type of errors.

When this happens, you should refactor your code so that your client-side bundles do not reference these Node.js native modules.

However, in some cases, this might not be possible. In Webpack the resolve.fallback option was typically used to silence the error. Turbopack offers a similar option, using turbopack.resolveAlias. In this case, tell Turbopack to load an empty module when fs is requested for the browser.

It is preferable to refactor your modules so that client code doesn't ever import from modules using Node.js native modules.

Turbopack fully supports importing Sass files from node_modules. Note that while Webpack allowed the legacy tilde (~) prefix, Turbopack does not support this syntax.

If changing the imports is not possible, you can use turbopack.resolveAlias. For example:

Turbopack now supports filesystem caching in development, storing compiler artifacts on disk between runs for significantly faster compile times across restarts.

Enable filesystem caching in your configuration:

Version 15 introduced Async Request APIs as a breaking change, with temporary synchronous compatibility.

Starting with Next.js 16, synchronous access is fully removed. These APIs can only be accessed asynchronously.

Use the codemod to migrate to async Dynamic APIs.

To help migrate to async params and searchParams, you can run npx next typegen to automatically generate these globally available types helpers:

Good to know: typegen was introduced in Next.js 15.5

This simplifies type-safe migration to the new async API pattern, and enables you to update your components with full type safety, for example:

This approach gives you fully type-safe access to props.params, including the slug, and to searchParams, directly within your page.

The props passed to the image generating functions in opengraph-image, twitter-image, icon, and apple-icon, are now Promises.

In previous versions, both the Image (image generation function), and the generateImageMetadata received a params object. The id returned by generateImageMetadata was passed as a string to the image generation function.

Starting with Next.js 16, to align with the Async Request APIs change, the image generating function now receives params and id as promises. The generateImageMetadata function continues to receive synchronous params.

Previously, the id values returned from generateSitemaps were passed directly to the sitemap generating function.

Starting with Next.js 16, the sitemap generating function now receives id as a promise.

The App Router in Next.js 16 uses the latest React Canary release, which includes the newly released React 19.2 features and other features being incrementally stabilized. Highlights include:

Learn more in the React 19.2 announcement.

Built-in support for the React Compiler is now stable in Next.js 16 following the React Compiler's 1.0 release. The React Compiler automatically memoizes components, reducing unnecessary re-renders with zero manual code changes.

The reactCompiler configuration option has been promoted from experimental to stable. It is not enabled by default as we continue gathering build performance data across different application types.

Install the latest version of the React Compiler plugin:

Good to know: Expect compile times in development and during builds to be higher when enabling this option as the React Compiler relies on Babel.

revalidateTag has a new function signature. You can pass a cacheLife profile as the second argument.

Use revalidateTag for content where a slight delay in updates is acceptable, such as blog posts, product catalogs, or documentation. Users receive stale content while fresh data loads in the background.

updateTag is a new Server Actions-only API that provides read-your-writes semantics, where a user makes a change and the UI immediately shows the change, rather than stale data.

It does this by expiring and immediately refreshing data within the same request.

This ensures interactive features reflect changes immediately. Perfect for forms, user settings, and any workflow where users expect to see their updates instantly.

Learn more about when to use updateTag or revalidateTag here.

refresh allows you to refresh the client router from within a Server Action.

Use it when you need to refresh the client router after performing an action.

cacheLife and cacheTag are now stable. The unstable_ prefix is no longer needed.

Wherever you had aliased imports like:

You can update your imports to:

Next.js 16 includes a complete overhaul of the routing and navigation system, making page transitions leaner and faster. This optimizes how Next.js prefetches and caches navigation data:

These changes require no code modifications and are designed to improve performance across all apps.

However, you may see more individual prefetch requests with much lower total transfer sizes. We believe this is the right trade-off for nearly all applications.

If the increased request count causes issues, please let us know by creating an issue or discussion item.

Next.js 16 removes the experimental Partial Pre-Rendering (PPR) flag and configuration options, including the route level segment experimental_ppr.

Starting with Next.js 16, you can opt into PPR using the cacheComponents configuration.

PPR in Next.js 16 works differently than in Next.js 15 canaries. If you are using PPR today, stay in the current Next.js 15 canary you are using. We will follow up with a guide to migrate to Cache Components.

The middleware filename is deprecated, and has been renamed to proxy to clarify network boundary and routing focus.

The edge runtime is NOT supported in proxy. The proxy runtime is nodejs, and it cannot be configured. If you want to continue using the edge runtime, keep using middleware. We will follow up on a minor release with further edge runtime instructions.

The named export middleware is also deprecated. Rename your function to proxy.

We recommend changing the function name to proxy, even if you are using a default export.

Configuration flags that contained the middleware name are also renamed. For example, skipMiddlewareUrlNormalize is now skipProxyUrlNormalize

The version 16 codemod is able to update these flags too.

Local image sources with query strings now require images.localPatterns.search configuration to prevent enumeration attacks.

If you need to use query strings with local images, add the pattern to your configuration:

The default value for images.minimumCacheTTL has changed from 60 seconds to 4 hours (14400 seconds). This reduces revalidation cost for images without cache-control headers.

For some Next.js users, image revalidation was happening frequently, often because the upstream source images missed a cache-control header. This caused revalidation to happen every 60 seconds, which increased CPU usage and cost.

Since most images do not change often, this short interval is not ideal. Setting the default to 4 hours offers a more durable cache by default, while still allowing images to update a few times per day if needed.

If you need the previous behavior, change minimumCacheTTL to a lower value, for example back to 60 seconds:

The value 16 has been removed from the default images.imageSizes array.

We have looked at request analytics and found out that very few projects ever serve 16 pixels width images. Removing this setting reduces the size of the srcset attribute shipped to the browser by next/image.

If you need to support 16px images:

Rather than lack of developer usage, we believe 16 pixels width images have become less common, because devicePixelRatio: 2 actually fetches a 32px image to prevent blurriness in retina displays.

The default value for images.qualities has changed from allowing all qualities to only [75].

If you need to support multiple quality levels:

If you specify a quality prop not included in the image.qualities array, the quality will be coerced to the closest value in images.qualities. For example, given the configuration above, a quality prop of 80, is coerced to 75.

A new security restriction blocks local IP optimization by default. Set images.dangerouslyAllowLocalIP to true only for private networks.

The default for images.maximumRedirects has changed from unlimited to 3 redirects maximum.

The next/legacy/image component is deprecated. Use next/image instead:

The images.domains config is deprecated.

Use images.remotePatterns instead for improved security:

next dev and next build now use separate output directories, enabling concurrent execution. The next dev command outputs to .next/dev. This is the new default behavior, controlled by isolatedDevBuild.

Additionally, a lockfile mechanism prevents multiple next dev or next build instances on the same project.

Since the development server outputs to .next/dev, the Turbopack tracing command should be:

All parallel route slots now require explicit default.js files. Builds will fail without them.

To maintain previous behavior, create a default.js file that calls notFound() or returns null.

@next/eslint-plugin-next now defaults to ESLint Flat Config format, aligning with ESLint v10 which will drop legacy config support.

Make sure to review our API reference for the @next/eslint-plugin-next plugin.

If you're using the legacy .eslintrc format, consider migrating to the flat config format. See the ESLint migration guide for details.

In previous versions of Next.js, if you had set scroll-behavior: smooth globally on your <html> element via CSS, Next.js would override this during SPA route transitions, as follows:

This ensured that page navigation always felt snappy and instant, even when you had smooth scrolling enabled for in-page navigation. However, this manipulation could be expensive, especially at the start of every navigation.

In Next.js 16, this behavior has changed. By default, Next.js will no longer override your scroll-behavior setting during navigation.

If you want Next.js to perform this override (the previous default behavior), add the data-scroll-behavior="smooth" attribute to your <html> element:

Significant performance optimizations for next dev and next start commands, along with improved terminal output with clearer formatting, better error messages, and improved performance metrics.

Next.js 16 removes the size and First Load JS metrics from the next build output. We found these to be inaccurate in server-driven architectures using React Server Components. Both our Turbopack and Webpack implementations had issues, and disagreed on how to account for Client Components payload.

The most effective way to measure actual route performance is through tools such as Chrome Lighthouse or Vercel Analytics, which focus on Core Web Vitals and downloaded resource sizes.

In previous versions the Next config file was loaded twice during development:

This was inefficient because the next dev command doesn't need the config file to start the Next.js server.

A consequence of this change is that, when running next dev checking if process.argv includes 'dev', in your Next.js config file, will return false.

Good to know: The typegen, and build commands, are still visible in process.argv.

This is specially important for plugins that trigger side-effects on next dev. If that's the case, it might be enough to check if NODE_ENV is set to development.

Alternatively, use the phase in which the configuration is loaded.

Following the Build Adapters RFC, the first alpha version of the Build Adapters API is now available.

Build Adapters allow you to create custom adapters that hook into the build process, enabling deployment platforms and custom build integrations to modify Next.js configuration or process build output.

Share your feedback in the RFC discussion.

sass-loader has been bumped to v16, which supports modern Sass syntax and new features.

These features were previously deprecated and are now removed:

AMP adoption has declined significantly, and maintaining this feature adds complexity to the framework. All AMP APIs and configurations have been removed:

Evaluate if AMP is still necessary for your use case. Most performance benefits can now be achieved through Next.js's built-in optimizations and modern web standards.

The next lint command has been removed. Use Biome or ESLint directly. next build no longer runs linting.

A codemod is available to automate migration:

The eslint option in the Next.js config file is also removed.

serverRuntimeConfig and publicRuntimeConfig have been removed. Use environment variables instead.

For server-only values, access environment variables directly in Server Components:

Good to know: Use the taint API to prevent accidentally passing sensitive server values to Client Components.

For client-accessible values, use the NEXT_PUBLIC_ prefix:

To ensure environment variables are read at runtime (not bundled at build time), use the connection() function before reading from process.env:

Learn more about environment variables.

The following options have been removed from devIndicators:

The indicator itself remains available.

The experimental.dynamicIO flag has been renamed to cacheComponents:

Update your Next config file, by removing the dynamicIO flag.

Add the cacheComponents flag set to true.

The unstable_rootParams function has been removed. We are working on an alternative API that we will ship in an upcoming minor release.

**Examples:**

Example 1 (unknown):
```unknown
{
  "mcpServers": {
    "next-devtools": {
      "command": "npx",
      "args": ["-y", "next-devtools-mcp@latest"]
    }
  }
}
```

Example 2 (unknown):
```unknown
Next Devtools, help me upgrade my Next.js app to version 16
```

Example 3 (unknown):
```unknown
Next Devtools, migrate my Next.js app to cache components
```

Example 4 (unknown):
```unknown
npx @next/codemod@canary upgrade latest
```

---

## How to use debugging tools with Next.js

**URL:** https://nextjs.org/docs/15/app/guides/debugging

**Contents:**
- How to use debugging tools with Next.js
- Debugging with VS Code
- Using the Debugger in Jetbrains WebStorm
- Debugging with Browser DevTools
  - Client-side code
  - React Developer Tools
  - Server-side code
  - Inspect Server Errors with Browser DevTools
  - Debugging on Windows
- More information

This documentation explains how you can debug your Next.js frontend and backend code with full source maps support using the VS Code debugger, Chrome DevTools, or Firefox DevTools.

Any debugger that can attach to Node.js can also be used to debug a Next.js application. You can find more details in the Node.js Debugging Guide.

Create a file named .vscode/launch.json at the root of your project with the following content:

Note: To use Firefox debugging in VS Code, you'll need to install the Firefox Debugger extension.

npm run dev can be replaced with yarn dev if you're using Yarn or pnpm dev if you're using pnpm.

In the "Next.js: debug full stack" configuration, serverReadyAction.action specifies which browser to open when the server is ready. debugWithEdge means to launch the Edge browser. If you are using Chrome, change this value to debugWithChrome.

If you're changing the port number your application starts on, replace the 3000 in http://localhost:3000 with the port you're using instead.

If you're running Next.js from a directory other than root (for example, if you're using Turborepo) then you need to add cwd to the server-side and full stack debugging tasks. For example, "cwd": "${workspaceFolder}/apps/web".

Now go to the Debug panel (Ctrl+Shift+D on Windows/Linux, â‡§+âŒ˜+D on macOS), select a launch configuration, then press F5 or select Debug: Start Debugging from the Command Palette to start your debugging session.

Click the drop down menu listing the runtime configuration, and click Edit Configurations.... Create a JavaScript Debug debug configuration with http://localhost:3000 as the URL. Customize to your liking (e.g. Browser for debugging, store as project file), and click OK. Run this debug configuration, and the selected browser should automatically open. At this point, you should have 2 applications in debug mode: the NextJS node application, and the client/browser application.

Start your development server as usual by running next dev, npm run dev, or yarn dev. Once the server starts, open http://localhost:3000 (or your alternate URL) in your preferred browser.

In either browser, any time your client-side code reaches a debugger statement, code execution will pause and that file will appear in the debug area. You can also search for files to set breakpoints manually:

Note that when searching, your source files will have paths starting with webpack://_N_E/./.

For React-specific debugging, install the React Developer Tools browser extension. This essential tool helps you:

To debug server-side Next.js code with browser DevTools, you need to pass the --inspect flag to the underlying Node.js process:

Good to know: Use NODE_OPTIONS='--inspect=0.0.0.0' to allow remote debugging access outside localhost, such as when running the app in a Docker container.

If you're using npm run dev or yarn dev then you should update the dev script on your package.json:

Launching the Next.js dev server with the --inspect flag will look something like this:

Debugging server-side code works similarly to client-side debugging. When searching for files (Ctrl+P/âŒ˜+P), your source files will have paths starting with webpack://{application-name}/./ (where {application-name} will be replaced with the name of your application according to your package.json file).

When you encounter an error, inspecting the source code can help trace the root cause of errors.

Next.js will display a Node.js icon underneath the Next.js version indicator on the error overlay. By clicking that icon, the DevTools URL is copied to your clipboard. You can open a new browser tab with that URL to inspect the Next.js server process.

Windows users may run into an issue when using NODE_OPTIONS='--inspect' as that syntax is not supported on Windows platforms. To get around this, install the cross-env package as a development dependency (-D with npm and yarn) and replace the dev script with the following.

cross-env will set the NODE_OPTIONS environment variable regardless of which platform you are on (including Mac, Linux, and Windows) and allow you to debug consistently across devices and operating systems.

Good to know: Ensure Windows Defender is disabled on your machine. This external service will check every file read, which has been reported to greatly increase Fast Refresh time with next dev. This is a known issue, not related to Next.js, but it does affect Next.js development.

To learn more about how to use a JavaScript debugger, take a look at the following documentation:

**Examples:**

Example 1 (unknown):
```unknown
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Next.js: debug server-side",
      "type": "node-terminal",
      "request": "launch",
      "command": "npm run dev"
    },
    {
      "name": "Next.js: debug client-side",
      "type": "chrome",
      "request": "launch",
      "url": "http://localhost:3000"
    },
    {
      "name": "Next.js: debug client-side (Firefox)",
      "type": "firefox",
      "request": "launch",
      "url": "http://localhost:3000",
      "reAttach": true,
      "pathMappings": [
        {
          "url": "webpack://_N_E",
          "path": "${workspaceFolder}"
        }
      ]
    },
    {
      "name": "Next.js: debug full stack",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/node_modules/next/dist/bin/next",
      "runtimeArgs": ["--inspect"],
      "skipFiles": ["<node_internals>/**"],
      "serverReadyAction": {
        "action": "debugWithEdge",
        "killOnServerStop": true,
        "pattern": "- Local:.+(https?://.+)",
        "uriFormat": "%s",
        "webRoot": "${workspaceFolder}"
      }
    }
  ]
}
```

Example 2 (unknown):
```unknown
NODE_OPTIONS='--inspect' next dev
```

Example 3 (unknown):
```unknown
{
  "scripts": {
    "dev": "NODE_OPTIONS='--inspect' next dev"
  }
}
```

Example 4 (unknown):
```unknown
Debugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95
For help, see: https://nodejs.org/en/docs/inspector
ready - started server on 0.0.0.0:3000, url: http://localhost:3000
```

---

## onDemandEntries

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/onDemandEntries

**Contents:**
- onDemandEntries

Next.js exposes some options that give you some control over how the server will dispose or keep in memory built pages in development.

To change the defaults, open next.config.js and add the onDemandEntries config:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  onDemandEntries: {
    // period (in ms) where the server will keep pages in the buffer
    maxInactiveAge: 25 * 1000,
    // number of pages that should be kept simultaneously without being disposed
    pagesBufferLength: 2,
  },
}
```

---

## How to build micro-frontends using multi-zones and Next.js

**URL:** https://nextjs.org/docs/app/guides/multi-zones

**Contents:**
- How to build micro-frontends using multi-zones and Next.js
- How to define a zone
- How to route requests to the right zone
  - Routing requests using proxy
- Linking between zones
- Sharing code
- Server Actions

Multi-Zones are an approach to micro-frontends that separate a large application on a domain into smaller Next.js applications that each serve a set of paths. This is useful when there are collections of pages unrelated to the other pages in the application. By moving those pages to a separate zone (i.e., a separate application), you can reduce the size of each application which improves build times and removes code that is only necessary for one of the zones. Since applications are decoupled, Multi-Zones also allows other applications on the domain to use their own choice of framework.

For example, let's say you have the following set of pages that you would like to split up:

With Multi-Zones support, you can create three applications that all are served on the same domain and look the same to the user, but you can develop and deploy each of the applications independently.

Navigating between pages in the same zone will perform soft navigations, a navigation that does not require reloading the page. For example, in this diagram, navigating from / to /products will be a soft navigation.

Navigating from a page in one zone to a page in another zone, such as from / to /dashboard, will perform a hard navigation, unloading the resources of the current page and loading the resources of the new page. Pages that are frequently visited together should live in the same zone to avoid hard navigations.

A zone is a normal Next.js application where you also configure an assetPrefix to avoid conflicts with pages and static files in other zones.

Next.js assets, such as JavaScript and CSS, will be prefixed with assetPrefix to make sure that they don't conflict with assets from other zones. These assets will be served under /assetPrefix/_next/... for each of the zones.

The default application handling all paths not routed to another more specific zone does not need an assetPrefix.

In versions older than Next.js 15, you may also need an additional rewrite to handle the static assets. This is no longer necessary in Next.js 15.

With the Multi Zones set-up, you need to route the paths to the correct zone since they are served by different applications. You can use any HTTP proxy to do this, but one of the Next.js applications can also be used to route requests for the entire domain.

To route to the correct zone using a Next.js application, you can use rewrites. For each path served by a different zone, you would add a rewrite rule to send that path to the domain of the other zone, and you also need to rewrite the requests for the static assets. For example:

destination should be a URL that is served by the zone, including scheme and domain. This should point to the zone's production domain, but it can also be used to route requests to localhost in local development.

Good to know: URL paths should be unique to a zone. For example, two zones trying to serve /blog would create a routing conflict.

Routing requests through rewrites is recommended to minimize latency overhead for the requests, but proxy can also be used when there is a need for a dynamic decision when routing. For example, if you are using a feature flag to decide where a path should be routed such as during a migration, you can use proxy.

Links to paths in a different zone should use an a tag instead of the Next.js <Link> component. This is because Next.js will try to prefetch and soft navigate to any relative path in <Link> component, which will not work across zones.

The Next.js applications that make up the different zones can live in any repository. However, it is often convenient to put these zones in a monorepo to more easily share code. For zones that live in different repositories, code can also be shared using public or private NPM packages.

Since the pages in different zones may be released at different times, feature flags can be useful for enabling or disabling features in unison across the different zones.

When using Server Actions with Multi-Zones, you must explicitly allow the user-facing origin since your user facing domain may serve multiple applications. In your next.config.js file, add the following lines:

See serverActions.allowedOrigins for more information.

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  assetPrefix: '/blog-static',
}
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  assetPrefix: '/blog-static',
  async rewrites() {
    return {
      beforeFiles: [
        {
          source: '/blog-static/_next/:path+',
          destination: '/_next/:path+',
        },
      ],
    }
  },
}
```

Example 3 (unknown):
```unknown
async rewrites() {
    return [
        {
            source: '/blog',
            destination: `${process.env.BLOG_DOMAIN}/blog`,
        },
        {
            source: '/blog/:path+',
            destination: `${process.env.BLOG_DOMAIN}/blog/:path+`,
        },
        {
            source: '/blog-static/:path+',
            destination: `${process.env.BLOG_DOMAIN}/blog-static/:path+`,
        }
    ];
}
```

Example 4 (javascript):
```javascript
export async function proxy(request) {
  const { pathname, search } = req.nextUrl;
  if (pathname === '/your-path' && myFeatureFlag.isEnabled()) {
    return NextResponse.rewrite(`${rewriteDomain}${pathname}${search});
  }
}
```

---

## generateMetadata

**URL:** https://nextjs.org/docs/app/api-reference/functions/generate-metadata

**Contents:**
- generateMetadata
- The metadata object
- generateMetadata function
- Reference
  - Parameters
  - Returns
  - Metadata Fields
    - title
      - String
      - default

You can use the metadata object or the generateMetadata function to define metadata.

To define static metadata, export a Metadata object from a layout.js or page.js file.

See the Metadata Fields for a complete list of supported options.

Dynamic metadata depends on dynamic information, such as the current route parameters, external data, or metadata in parent segments, can be set by exporting a generateMetadata function that returns a Metadata object.

Resolving generateMetadata is part of rendering the page. If the page can be pre-rendered and generateMetadata doesn't introduce dynamic behavior, the resulting metadata is included in the pageâ€™s initial HTML.

Otherwise the metadata resolved from generateMetadata can be streamed after sending the initial UI.

For type completion of params and searchParams, you can type the first argument with PageProps<'/route'> or LayoutProps<'/route'> for pages and layouts respectively.

generateMetadata function accepts the following parameters:

props - An object containing the parameters of the current route:

params - An object containing the dynamic route parameters object from the root segment down to the segment generateMetadata is called from. Examples:

searchParams - An object containing the current URL's search params. Examples:

parent - A promise of the resolved metadata from parent route segments.

generateMetadata should return a Metadata object containing one or more metadata fields.

The following fields are supported:

The title attribute is used to set the title of the document. It can be defined as a simple string or an optional template object.

title.default can be used to provide a fallback title to child route segments that don't define a title.

title.template can be used to add a prefix or a suffix to titles defined in child route segments.

title.absolute can be used to provide a title that ignores title.template set in parent segments.

metadataBase is a convenience option to set a base URL prefix for metadata fields that require a fully qualified URL.

URL composition favors developer intent over default directory traversal semantics.

For example, given the following metadataBase:

Any metadata fields that inherit the above metadataBase and set their own value will be resolved as follows:

Good to know: We recommend using the file-based Metadata API for icons where possible. Rather than having to sync the config export with actual files, the file-based API will automatically generate the correct metadata for you.

Good to know: The msapplication-* meta tags are no longer supported in Chromium builds of Microsoft Edge, and thus no longer needed.

Deprecated: The themeColor option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead.

Deprecated: The colorScheme option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead.

A web application manifest, as defined in the Web Application Manifest specification.

The Twitter specification is (surprisingly) used for more than just X (formerly known as Twitter).

Learn more about the Twitter Card markup reference.

Deprecated: The viewport option in metadata is deprecated as of Next.js 14. Please use the viewport configuration instead.

Describes a collection of records, documents, or other materials of historical interest (source).

You can connect a Facebook app or Facebook account to your webpage for certain Facebook Social Plugins Facebook Documentation

Good to know: You can specify either appId or admins, but not both.

If you want to generate multiple fb:admins meta tags you can use array value.

You can enable or disable Pinterest Rich Pins on your webpage.

All metadata options should be covered using the built-in support. However, there may be custom metadata tags specific to your site, or brand new metadata tags just released. You can use the other option to render any custom metadata tag.

If you want to generate multiple same key meta tags you can use array value.

You can add type safety to your metadata by using the Metadata type. If you are using the built-in TypeScript plugin in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want.

For JavaScript projects, you can use JSDoc to add type safety.

The following metadata types do not currently have built-in support. However, they can still be rendered in the layout or page itself.

The <link> element has a number of rel keywords that can be used to hint to the browser that an external resource is likely to be needed. The browser uses this information to apply preloading optimizations depending on the keyword.

While the Metadata API doesn't directly support these hints, you can use new ReactDOM methods to safely insert them into the <head> of the document.

Start loading a resource early in the page rendering (browser) lifecycle. MDN Docs.

Preemptively initiate a connection to an origin. MDN Docs.

Attempt to resolve a domain name before resources get requested. MDN Docs.

There are two default meta tags that are always added even if a route doesn't define metadata:

Good to know: You can overwrite the default viewport meta tag.

Streaming metadata allows Next.js to render and send the initial UI to the browser, without waiting for generateMetadata to complete.

When generateMetadata resolves, the resulting metadata tags are appended to the <body> tag. We have verified that metadata is interpreted correctly by bots that execute JavaScript and inspect the full DOM (e.g. Googlebot).

For HTML-limited bots that canâ€™t execute JavaScript (e.g. facebookexternalhit), metadata continues to block page rendering. The resulting metadata will be available in the <head> tag.

Next.js automatically detects HTML-limited bots by looking at the User Agent header. You can use the htmlLimitedBots option in your Next.js config file to override the default User Agent list.

To fully disable streaming metadata:

Streaming metadata improves perceived performance by reducing TTFB and can help lowering LCP time.

Overriding htmlLimitedBots could lead to longer response times. Streaming metadata is an advanced feature, and the default should be sufficient for most cases.

Metadata is evaluated in order, starting from the root segment down to the segment closest to the final page.js segment. For example:

Following the evaluation order, Metadata objects exported from multiple segments in the same route are shallowly merged together to form the final metadata output of a route. Duplicate keys are replaced based on their ordering.

This means metadata with nested fields such as openGraph and robots that are defined in an earlier segment are overwritten by the last segment to define them.

In the example above:

If you'd like to share some nested fields between segments while overwriting others, you can pull them out into a separate variable:

In the example above, the OG image is shared between app/layout.js and app/about/page.js while the titles are different.

**Examples:**

Example 1 (python):
```python
import type { Metadata } from 'next'
 
export const metadata: Metadata = {
  title: '...',
  description: '...',
}
 
export default function Page() {}
```

Example 2 (python):
```python
import type { Metadata, ResolvingMetadata } from 'next'
 
type Props = {
  params: Promise<{ id: string }>
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}
 
export async function generateMetadata(
  { params, searchParams }: Props,
  parent: ResolvingMetadata
): Promise<Metadata> {
  // read route params
  const { id } = await params
 
  // fetch data
  const product = await fetch(`https://.../${id}`).then((res) => res.json())
 
  // optionally access and extend (rather than replace) parent metadata
  const previousImages = (await parent).openGraph?.images || []
 
  return {
    title: product.title,
    openGraph: {
      images: ['/some-specific-page-image.jpg', ...previousImages],
    },
  }
}
 
export default function Page({ params, searchParams }: Props) {}
```

Example 3 (javascript):
```javascript
export const metadata = {
  title: 'Next.js',
}
```

Example 4 (unknown):
```unknown
<title>Next.js</title>
```

---

## forbidden

**URL:** https://nextjs.org/docs/app/api-reference/functions/forbidden

**Contents:**
- forbidden
- Good to know
- Examples
  - Role-based route protection
  - Mutations with Server Actions
- Version History
- Next Steps
  - forbidden.js

The forbidden function throws an error that renders a Next.js 403 error page. It's useful for handling authorization errors in your application. You can customize the UI using the forbidden.js file.

To start using forbidden, enable the experimental authInterrupts configuration option in your next.config.js file:

forbidden can be invoked in Server Components, Server Actions, and Route Handlers.

You can use forbidden to restrict access to certain routes based on user roles. This ensures that users who are authenticated but lack the required permissions cannot access the route.

When implementing mutations in Server Actions, you can use forbidden to only allow users with a specific role to update sensitive data.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    authInterrupts: true,
  },
}
 
export default nextConfig
```

Example 2 (python):
```python
import { verifySession } from '@/app/lib/dal'
import { forbidden } from 'next/navigation'
 
export default async function AdminPage() {
  const session = await verifySession()
 
  // Check if the user has the 'admin' role
  if (session.role !== 'admin') {
    forbidden()
  }
 
  // Render the admin page for authorized users
  return <></>
}
```

Example 3 (python):
```python
import { verifySession } from '@/app/lib/dal'
import { forbidden } from 'next/navigation'
 
export default async function AdminPage() {
  const session = await verifySession()
 
  // Check if the user has the 'admin' role
  if (session.role !== 'admin') {
    forbidden()
  }
 
  // Render the admin page for authorized users
  return (
    <main>
      <h1>Admin Dashboard</h1>
      <p>Welcome, {session.user.name}!</p>
    </main>
  )
}
```

Example 4 (python):
```python
'use server'
 
import { verifySession } from '@/app/lib/dal'
import { forbidden } from 'next/navigation'
import db from '@/app/lib/db'
 
export async function updateRole(formData: FormData) {
  const session = await verifySession()
 
  // Ensure only admins can update roles
  if (session.role !== 'admin') {
    forbidden()
  }
 
  // Perform the role update for authorized users
  // ...
}
```

---

## How to optimize memory usage

**URL:** https://nextjs.org/docs/app/guides/memory-usage

**Contents:**
- How to optimize memory usage
- Reduce number of dependencies
- Try experimental.webpackMemoryOptimizations
- Run next build with --experimental-debug-memory-usage
- Record a heap profile
- Analyze a snapshot of the heap
- Webpack build worker
- Disable Webpack cache
- Disable static analysis
- Disable source maps

As applications grow and become more feature rich, they can demand more resources when developing locally or creating production builds.

Let's explore some strategies and techniques to optimize memory and address common memory issues in Next.js.

Applications with a large amount of dependencies will use more memory.

The Bundle Analyzer can help you investigate large dependencies in your application that may be able to be removed to improve performance and memory usage.

Starting in v15.0.0, you can add experimental.webpackMemoryOptimizations: true to your next.config.js file to change behavior in Webpack that reduces max memory usage but may increase compilation times by a slight amount.

Good to know: This feature is currently experimental to test on more projects first, but it is considered to be low-risk.

Starting in 14.2.0, you can run next build --experimental-debug-memory-usage to run the build in a mode where Next.js will print out information about memory usage continuously throughout the build, such as heap usage and garbage collection statistics. Heap snapshots will also be taken automatically when memory usage gets close to the configured limit.

Good to know: This feature is not compatible with the Webpack build worker option which is auto-enabled unless you have custom webpack config.

To look for memory issues, you can record a heap profile from Node.js and load it in Chrome DevTools to identify potential sources of memory leaks.

In your terminal, pass the --heap-prof flag to Node.js when starting your Next.js build:

At the end of the build, a .heapprofile file will be created by Node.js.

In Chrome DevTools, you can open the Memory tab and click on the "Load Profile" button to visualize the file.

You can use an inspector tool to analyze the memory usage of the application.

When running the next build or next dev command, add NODE_OPTIONS=--inspect to the beginning of the command. This will expose the inspector agent on the default port. If you wish to break before any user code starts, you can pass --inspect-brk instead. While the process is running, you can use a tool such as Chrome DevTools to connect to the debugging port to record and analyze a snapshot of the heap to see what memory is being retained.

Starting in 14.2.0, you can also run next build with the --experimental-debug-memory-usage flag to make it easier to take heap snapshots.

While running in this mode, you can send a SIGUSR2 signal to the process at any point, and the process will take a heap snapshot.

The heap snapshot will be saved to the project root of the Next.js application and can be loaded in any heap analyzer, such as Chrome DevTools, to see what memory is retained. This mode is not yet compatible with Webpack build workers.

See how to record and analyze heap snapshots for more information.

The Webpack build worker allows you to run Webpack compilations inside a separate Node.js worker which will decrease memory usage of your application during builds.

This option is enabled by default if your application does not have a custom Webpack configuration starting in v14.1.0.

If you are using an older version of Next.js or you have a custom Webpack configuration, you can enable this option by setting experimental.webpackBuildWorker: true inside your next.config.js.

Good to know: This feature may not be compatible with all custom Webpack plugins.

The Webpack cache saves generated Webpack modules in memory and/or to disk to improve the speed of builds. This can help with performance, but it will also increase the memory usage of your application to store the cached data.

You can disable this behavior by adding a custom Webpack configuration to your application:

Typechecking may require a lot of memory, especially in large projects. However, most projects have a dedicated CI runner that already handles these tasks. When the build produces out-of-memory issues during the "Running TypeScript" step, you can disable this task during builds:

Keep in mind that this may produce faulty deploys due to type errors. We strongly recommend only promoting builds to production after static analysis has completed. If you deploy to Vercel, you can check out the guide for staging deployments to learn how to promote builds to production after custom tasks have succeeded.

Generating source maps consumes extra memory during the build process.

You can disable source map generation by adding productionBrowserSourceMaps: false and experimental.serverSourceMaps: false to your Next.js configuration.

When using the cacheComponents feature, Next.js will use source maps by default during the prerender phase of next build. If you consistently encounter memory issues during that phase (after "Generating static pages"), you can try disabling source maps in that phase by adding enablePrerenderSourceMaps: false to your Next.js configuration.

Good to know: Some plugins may turn on source maps and may require custom configuration to disable.

Next.js v14.1.3 fixed a memory issue when using the Edge runtime. Please update to this version (or later) to see if it addresses your issue.

When the Next.js server starts, it preloads each page's JavaScript modules into memory, rather than at request time.

This optimization allows for faster response times, in exchange for a larger initial memory footprint.

To disable this optimization, set the experimental.preloadEntriesOnStart flag to false.

Next.js doesn't unload these JavaScript modules, meaning that even with this optimization disabled, the memory footprint of your Next.js server will eventually be the same if all pages are eventually requested.

**Examples:**

Example 1 (unknown):
```unknown
node --heap-prof node_modules/next/dist/bin/next build
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  webpack: (
    config,
    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }
  ) => {
    if (config.cache && !dev) {
      config.cache = Object.freeze({
        type: 'memory',
      })
    }
    // Important: return the modified config
    return config
  },
}
 
export default nextConfig
```

Example 3 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}
 
export default nextConfig
```

Example 4 (python):
```python
import type { NextConfig } from 'next'
 
const config: NextConfig = {
  experimental: {
    preloadEntriesOnStart: false,
  },
}
 
export default config
```

---

## How to upgrade to version 12

**URL:** https://nextjs.org/docs/pages/guides/upgrading/version-12

**Contents:**
- How to upgrade to version 12
  - Upgrading to 12.2
  - Upgrading to 12.0
    - SWC replacing Babel
    - SWC replacing Terser for minification
    - Improvements to styled-jsx CSS parsing
    - next/image changed wrapping element
    - HMR connection now uses a WebSocket
    - Webpack 4 support has been removed
    - target option deprecated

To upgrade to version 12, run the following command:

Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions.

Middleware - If you were using Middleware prior to 12.2, please see the upgrade guide for more information.

Minimum Node.js Version - The minimum Node.js version has been bumped from 12.0.0 to 12.22.0 which is the first version of Node.js with native ES Modules support.

Minimum React Version - The minimum required React version is 17.0.2. To upgrade you can run the following command in the terminal:

Next.js now uses the Rust-based compiler SWC to compile JavaScript/TypeScript. This new compiler is up to 17x faster than Babel when compiling individual files and up to 5x faster Fast Refresh.

Next.js provides full backward compatibility with applications that have custom Babel configuration. All transformations that Next.js handles by default like styled-jsx and tree-shaking of getStaticProps / getStaticPaths / getServerSideProps have been ported to Rust.

When an application has a custom Babel configuration, Next.js will automatically opt-out of using SWC for compiling JavaScript/Typescript and will fall back to using Babel in the same way that it was used in Next.js 11.

Many of the integrations with external libraries that currently require custom Babel transformations will be ported to Rust-based SWC transforms in the near future. These include but are not limited to:

In order to prioritize transforms that will help you adopt SWC, please provide your .babelrc on this feedback thread.

You can opt-in to replacing Terser with SWC for minifying JavaScript up to 7x faster using a flag in next.config.js:

Minification using SWC is an opt-in flag to ensure it can be tested against more real-world Next.js applications before it becomes the default in Next.js 12.1. If you have feedback about minification, please leave it on this feedback thread.

On top of the Rust-based compiler we've implemented a new CSS parser based on the one used for the styled-jsx Babel transform. This new parser has improved handling of CSS and now errors when invalid CSS is used that would previously slip through and cause unexpected behavior.

Because of this change invalid CSS will throw an error during development and next build. This change only affects styled-jsx usage.

next/image now renders the <img> inside a <span> instead of <div>.

If your application has specific CSS targeting span such as .container span, upgrading to Next.js 12 might incorrectly match the wrapping element inside the <Image> component. You can avoid this by restricting the selector to a specific class such as .container span.item and updating the relevant component with that className, such as <span className="item" />.

If your application has specific CSS targeting the next/image <div> tag, for example .container div, it may not match anymore. You can update the selector .container span, or preferably, add a new <div className="wrapper"> wrapping the <Image> component and target that instead such as .container .wrapper.

The className prop is unchanged and will still be passed to the underlying <img> element.

See the documentation for more info.

Previously, Next.js used a server-sent events connection to receive HMR events. Next.js 12 now uses a WebSocket connection.

In some cases when proxying requests to the Next.js dev server, you will need to ensure the upgrade request is handled correctly. For example, in nginx you would need to add the following configuration:

If you are using Apache (2.x), you can add the following configuration to enable web sockets to the server. Review the port, host name and server names.

For custom servers, such as express, you may need to use app.all to ensure the request is passed correctly, for example:

If you are already using webpack 5 you can skip this section.

Next.js has adopted webpack 5 as the default for compilation in Next.js 11. As communicated in the webpack 5 upgrading documentation Next.js 12 removes support for webpack 4.

If your application is still using webpack 4 using the opt-out flag, you will now see an error linking to the webpack 5 upgrading documentation.

If you do not have target in next.config.js you can skip this section.

The target option has been deprecated in favor of built-in support for tracing what dependencies are needed to run a page.

During next build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application.

If you are currently using the target option set to serverless, please read the documentation on how to leverage the new output.

**Examples:**

Example 1 (unknown):
```unknown
npm i next@12 react@17 react-dom@17 eslint-config-next@12
```

Example 2 (unknown):
```unknown
yarn add next@12 react@17 react-dom@17 eslint-config-next@12
```

Example 3 (unknown):
```unknown
pnpm up next@12 react@17 react-dom@17 eslint-config-next@12
```

Example 4 (unknown):
```unknown
bun add next@12 react@17 react-dom@17 eslint-config-next@12
```

---

## How to set up instrumentation

**URL:** https://nextjs.org/docs/15/app/guides/instrumentation

**Contents:**
- How to set up instrumentation
- Convention
- Examples
  - Importing files with side effects
  - Importing runtime-specific code
- Learn more about Instrumentation
  - instrumentation.js

Instrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production.

To set up instrumentation, create instrumentation.ts|js file in the root directory of your project (or inside the src folder if using one).

Then, export a register function in the file. This function will be called once when a new Next.js server instance is initiated.

For example, to use Next.js with OpenTelemetry and @vercel/otel:

See the Next.js with OpenTelemetry example for a complete implementation.

Sometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared.

We recommend importing files using JavaScript import syntax within your register function. The following example demonstrates a basic usage of import in a register function:

We recommend importing the file from within the register function, rather than at the top of the file. By doing this, you can colocate all of your side effects in one place in your code, and avoid any unintended consequences from importing globally at the top of the file.

Next.js calls register in all environments, so it's important to conditionally import any code that doesn't support specific runtimes (e.g. Edge or Node.js). You can use the NEXT_RUNTIME environment variable to get the current environment:

**Examples:**

Example 1 (python):
```python
import { registerOTel } from '@vercel/otel'
 
export function register() {
  registerOTel('next-app')
}
```

Example 2 (unknown):
```unknown
export async function register() {
  await import('package-with-side-effect')
}
```

Example 3 (unknown):
```unknown
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./instrumentation-node')
  }
 
  if (process.env.NEXT_RUNTIME === 'edge') {
    await import('./instrumentation-edge')
  }
}
```

---

## Internationalization

**URL:** https://nextjs.org/docs/15/app/guides/internationalization

**Contents:**
- Internationalization
- Terminology
- Routing Overview
- Localization
- Static Rendering
- Resources

Next.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to different locales includes translated content (localization) and internationalized routes.

Itâ€™s recommended to use the userâ€™s language preferences in the browser to select which locale to use. Changing your preferred language will modify the incoming Accept-Language header to your application.

For example, using the following libraries, you can look at an incoming Request to determine which locale to select, based on the Headers, locales you plan to support, and the default locale.

Routing can be internationalized by either the sub-path (/fr/products) or domain (my-site.fr/products). With this information, you can now redirect the user based on the locale inside Middleware.

Finally, ensure all special files inside app/ are nested under app/[lang]. This enables the Next.js router to dynamically handle different locales in the route, and forward the lang parameter to every layout and page. For example:

The root layout can also be nested in the new folder (e.g. app/[lang]/layout.js).

Changing displayed content based on the userâ€™s preferred locale, or localization, is not something specific to Next.js. The patterns described below would work the same with any web application.

Letâ€™s assume we want to support both English and Dutch content inside our application. We might maintain two different â€œdictionariesâ€, which are objects that give us a mapping from some key to a localized string. For example:

We can then create a getDictionary function to load the translations for the requested locale:

Given the currently selected language, we can fetch the dictionary inside of a layout or page.

Because all layouts and pages in the app/ directory default to Server Components, we do not need to worry about the size of the translation files affecting our client-side JavaScript bundle size. This code will only run on the server, and only the resulting HTML will be sent to the browser.

To generate static routes for a given set of locales, we can use generateStaticParams with any page or layout. This can be global, for example, in the root layout:

**Examples:**

Example 1 (python):
```python
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'
 
let headers = { 'accept-language': 'en-US,en;q=0.5' }
let languages = new Negotiator({ headers }).languages()
let locales = ['en-US', 'nl-NL', 'nl']
let defaultLocale = 'en-US'
 
match(languages, locales, defaultLocale) // -> 'en-US'
```

Example 2 (python):
```python
import { NextResponse } from "next/server";
 
let locales = ['en-US', 'nl-NL', 'nl']
 
// Get the preferred locale, similar to the above or using a library
function getLocale(request) { ... }
 
export function middleware(request) {
  // Check if there is any supported locale in the pathname
  const { pathname } = request.nextUrl
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )
 
  if (pathnameHasLocale) return
 
  // Redirect if there is no locale
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`
  // e.g. incoming request is /products
  // The new URL is now /en-US/products
  return NextResponse.redirect(request.nextUrl)
}
 
export const config = {
  matcher: [
    // Skip all internal paths (_next)
    '/((?!_next).*)',
    // Optional: only run on root (/) URL
    // '/'
  ],
}
```

Example 3 (javascript):
```javascript
// You now have access to the current locale
// e.g. /en-US/products -> `lang` is "en-US"
export default async function Page({
  params,
}: {
  params: Promise<{ lang: string }>
}) {
  const { lang } = await params
  return ...
}
```

Example 4 (unknown):
```unknown
{
  "products": {
    "cart": "Add to Cart"
  }
}
```

---

## How to set up Playwright with Next.js

**URL:** https://nextjs.org/docs/app/guides/testing/playwright

**Contents:**
- How to set up Playwright with Next.js
- Quickstart
- Manual setup
- Creating your first Playwright E2E test
  - Running your Playwright tests
  - Running Playwright on Continuous Integration (CI)

Playwright is a testing framework that lets you automate Chromium, Firefox, and WebKit with a single API. You can use it to write End-to-End (E2E) testing. This guide will show you how to set up Playwright with Next.js and write your first tests.

The fastest way to get started is to use create-next-app with the with-playwright example. This will create a Next.js project complete with Playwright configured.

To install Playwright, run the following command:

This will take you through a series of prompts to setup and configure Playwright for your project, including adding a playwright.config.ts file. Please refer to the Playwright installation guide for the step-by-step guide.

Create two new Next.js pages:

Then, add a test to verify that your navigation is working correctly:

Good to know: You can use page.goto("/") instead of page.goto("http://localhost:3000/"), if you add "baseURL": "http://localhost:3000" to the playwright.config.ts configuration file.

Playwright will simulate a user navigating your application using three browsers: Chromium, Firefox and Webkit, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave.

Run npm run build and npm run start, then run npx playwright test in another terminal window to run the Playwright tests.

Good to know: Alternatively, you can use the webServer feature to let Playwright start the development server and wait until it's fully available.

Playwright will by default run your tests in the headless mode. To install all the Playwright dependencies, run npx playwright install-deps.

You can learn more about Playwright and Continuous Integration from these resources:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --example with-playwright with-playwright-app
```

Example 2 (unknown):
```unknown
npm init playwright
# or
yarn create playwright
# or
pnpm create playwright
```

Example 3 (python):
```python
import Link from 'next/link'
 
export default function Page() {
  return (
    <div>
      <h1>Home</h1>
      <Link href="/about">About</Link>
    </div>
  )
}
```

Example 4 (python):
```python
import Link from 'next/link'
 
export default function Page() {
  return (
    <div>
      <h1>About</h1>
      <Link href="/">Home</Link>
    </div>
  )
}
```

---

## Pages and Layouts

**URL:** https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts

**Contents:**
- Pages and Layouts
- Index routes
- Nested routes
- Pages with Dynamic Routes
- Layout Pattern
- Examples
  - Single Shared Layout with Custom App
  - Per-Page Layouts
  - With TypeScript
  - Data Fetching

The Pages Router has a file-system based router built on the concept of pages.

When a file is added to the pages directory, it's automatically available as a route.

In Next.js, a page is a React Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name.

Example: If you create pages/about.js that exports a React component like below, it will be accessible at /about.

The router will automatically route files named index to the root of the directory.

The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way still.

Next.js supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc.

To learn more about dynamic routing, check the Dynamic Routing documentation.

The React model allows us to deconstruct a page into a series of components. Many of these components are often reused between pages. For example, you might have the same navigation bar and footer on every page.

If you only have one layout for your entire application, you can create a Custom App and wrap your application with the layout. Since the <Layout /> component is re-used when changing pages, its component state will be preserved (e.g. input values).

If you need multiple layouts, you can add a property getLayout to your page, allowing you to return a React component for the layout. This allows you to define the layout on a per-page basis. Since we're returning a function, we can have complex nested layouts if desired.

When navigating between pages, we want to persist page state (input values, scroll position, etc.) for a Single-Page Application (SPA) experience.

This layout pattern enables state persistence because the React component tree is maintained between page transitions. With the component tree, React can understand which elements have changed to preserve state.

Good to know: This process is called reconciliation, which is how React understands which elements have changed.

When using TypeScript, you must first create a new type for your pages which includes a getLayout function. Then, you must create a new type for your AppProps which overrides the Component property to use the previously created type.

Inside your layout, you can fetch data on the client-side using useEffect or a library like SWR. Because this file is not a Page, you cannot use getStaticProps or getServerSideProps currently.

**Examples:**

Example 1 (unknown):
```unknown
export default function About() {
  return <div>About</div>
}
```

Example 2 (python):
```python
import Navbar from './navbar'
import Footer from './footer'
 
export default function Layout({ children }) {
  return (
    <>
      <Navbar />
      <main>{children}</main>
      <Footer />
    </>
  )
}
```

Example 3 (python):
```python
import Layout from '../components/layout'
 
export default function MyApp({ Component, pageProps }) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  )
}
```

Example 4 (python):
```python
import Layout from '../components/layout'
import NestedLayout from '../components/nested-layout'
 
export default function Page() {
  return (
    /** Your content */
  )
}
 
Page.getLayout = function getLayout(page) {
  return (
    <Layout>
      <NestedLayout>{page}</NestedLayout>
    </Layout>
  )
}
```

---

## proxyClientMaxBodySize

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/proxyClientMaxBodySize

**Contents:**
- proxyClientMaxBodySize
- Options
  - String format (recommended)
  - Number format
- Behavior
- Example
- Good to know

When proxy is used, Next.js automatically clones the request body and buffers it in memory to enable multiple reads - both in proxy and the underlying route handler. To prevent excessive memory usage, this configuration option sets a size limit on the buffered body.

By default, the maximum body size is 10MB. If a request body exceeds this limit, the body will only be buffered up to the limit, and a warning will be logged indicating which route exceeded the limit.

Specify the size using a human-readable string format:

Supported units: b, kb, mb, gb

Alternatively, specify the size in bytes as a number:

When a request body exceeds the configured limit:

If your application needs to process the full request body, you should either:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    proxyClientMaxBodySize: '1mb',
  },
}
 
export default nextConfig
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    proxyClientMaxBodySize: 1048576, // 1MB in bytes
  },
}
 
export default nextConfig
```

Example 3 (python):
```python
import { NextRequest, NextResponse } from 'next/server'
 
export async function proxy(request: NextRequest) {
  // Next.js automatically buffers the body with the configured size limit
  // You can read the body in proxy...
  const body = await request.text()
 
  // If the body exceeded the limit, only partial data will be available
  console.log('Body size:', body.length)
 
  return NextResponse.next()
}
```

Example 4 (python):
```python
import { NextRequest, NextResponse } from 'next/server'
 
export async function POST(request: NextRequest) {
  // ...and the body is still available in your route handler
  const body = await request.text()
 
  console.log('Body in route handler:', body.length)
 
  return NextResponse.json({ received: body.length })
}
```

---

## useSelectedLayoutSegments

**URL:** https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments

**Contents:**
- useSelectedLayoutSegments
- Parameters
- Returns
- Version History

useSelectedLayoutSegments is a Client Component hook that lets you read the active route segments below the Layout it is called from.

It is useful for creating UI in parent Layouts that need knowledge of active child segments such as breadcrumbs.

useSelectedLayoutSegments optionally accepts a parallelRoutesKey, which allows you to read the active route segment within that slot.

useSelectedLayoutSegments returns an array of strings containing the active segments one level down from the layout the hook was called from. Or an empty array if none exist.

For example, given the Layouts and URLs below, the returned segments would be:

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useSelectedLayoutSegments } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const segments = useSelectedLayoutSegments()
 
  return (
    <ul>
      {segments.map((segment, index) => (
        <li key={index}>{segment}</li>
      ))}
    </ul>
  )
}
```

Example 2 (javascript):
```javascript
const segments = useSelectedLayoutSegments(parallelRoutesKey?: string)
```

---

## No HTML link for pages

**URL:** https://nextjs.org/docs/messages/no-html-link-for-pages

**Contents:**
- No HTML link for pages
- Why This Error Occurred
- Possible Ways to Fix It
  - Options
    - pagesDir
- Useful Links

Prevent usage of <a> elements to navigate to internal Next.js pages.

An <a> element was used to navigate to a page route without using the next/link component, causing unnecessary full-page refreshes.

The Link component is required to enable client-side route transitions between pages and provide a single-page app experience.

Make sure to import the Link component and wrap anchor elements that route to different page routes.

This rule can normally locate your pages directory automatically.

If you're working in a monorepo, we recommend configuring the rootDir setting in eslint-plugin-next, which pagesDir will use to locate your pages directory.

In some cases, you may also need to configure this rule directly by providing a pages directory. This can be a path or an array of paths.

**Examples:**

Example 1 (unknown):
```unknown
function Home() {
  return (
    <div>
      <a href="/about">About Us</a>
    </div>
  )
}
```

Example 2 (python):
```python
import Link from 'next/link'
 
function Home() {
  return (
    <div>
      <Link href="/about">About Us</Link>
    </div>
  )
}
 
export default Home
```

Example 3 (unknown):
```unknown
{
  "rules": {
    "@next/next/no-html-link-for-pages": ["error", "packages/my-app/pages/"]
  }
}
```

---

## urlImports

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/urlImports

**Contents:**
- urlImports
- Security Model
- Lockfile
- Examples
  - Skypack
  - Static Image Imports
  - URLs in CSS
  - Asset Imports

URL imports are an experimental feature that allows you to import modules directly from external servers (instead of from the local disk).

Warning: Only use domains that you trust to download and execute on your machine. Please exercise discretion, and caution until the feature is flagged as stable.

To opt-in, add the allowed URL prefixes inside next.config.js:

Then, you can import modules directly from URLs:

URL Imports can be used everywhere normal package imports can be used.

This feature is being designed with security as the top priority. To start, we added an experimental flag forcing you to explicitly allow the domains you accept URL imports from. We're working to take this further by limiting URL imports to execute in the browser sandbox using the Edge Runtime.

When using URL imports, Next.js will create a next.lock directory containing a lockfile and fetched assets. This directory must be committed to Git, not ignored by .gitignore.

Typically, no network requests are needed and any outdated lockfile will cause the build to fail. One exception is resources that respond with Cache-Control: no-cache. These resources will have a no-cache entry in the lockfile and will always be fetched from the network on each build.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  experimental: {
    urlImports: ['https://example.com/assets/', 'https://cdn.skypack.dev'],
  },
}
```

Example 2 (python):
```python
import { a, b, c } from 'https://example.com/assets/some/module.js'
```

Example 3 (python):
```python
import confetti from 'https://cdn.skypack.dev/canvas-confetti'
import { useEffect } from 'react'
 
export default () => {
  useEffect(() => {
    confetti()
  })
  return <p>Hello</p>
}
```

Example 4 (python):
```python
import Image from 'next/image'
import logo from 'https://example.com/assets/logo.png'
 
export default () => (
  <div>
    <Image src={logo} placeholder="blur" />
  </div>
)
```

---

## How to migrate from Pages to the App Router

**URL:** https://nextjs.org/docs/pages/guides/migrating/app-router-migration

**Contents:**
- How to migrate from Pages to the App Router
- Upgrading
  - Node.js Version
  - Next.js Version
  - ESLint Version
- Next Steps
- Upgrading New Features
  - <Image/> Component
  - <Link> Component
  - <Script> Component

This guide will help you:

The minimum Node.js version is now v18.17. See the Node.js documentation for more information.

To update to Next.js version 13, run the following command using your preferred package manager:

If you're using ESLint, you need to upgrade your ESLint version:

Good to know: You may need to restart the ESLint server in VS Code for the ESLint changes to take effect. Open the Command Palette (cmd+shift+p on Mac; ctrl+shift+p on Windows) and search for ESLint: Restart ESLint Server.

After you've updated, see the following sections for next steps:

Next.js 13 introduced the new App Router with new features and conventions. The new Router is available in the app directory and co-exists with the pages directory.

Upgrading to Next.js 13 does not require using the App Router. You can continue using pages with new features that work in both directories, such as the updated Image component, Link component, Script component, and Font optimization.

Next.js 12 introduced new improvements to the Image Component with a temporary import: next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading.

In version 13, this new behavior is now the default for next/image.

There are two codemods to help you migrate to the new Image Component:

The <Link> Component no longer requires manually adding an <a> tag as a child. This behavior was added as an experimental option in version 12.2 and is now the default. In Next.js 13, <Link> always renders <a> and allows you to forward props to the underlying tag.

To upgrade your links to Next.js 13, you can use the new-link codemod.

The behavior of next/script has been updated to support both pages and app, but some changes need to be made to ensure a smooth migration:

Previously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new next/font module which gives you the ability to customize your font loading experience while still ensuring great performance and privacy. next/font is supported in both the pages and app directories.

While inlining CSS still works in pages, it does not work in app. You should use next/font instead.

See the Font Optimization page to learn how to use next/font.

ðŸŽ¥ Watch: Learn how to incrementally adopt the App Router â†’ YouTube (16 minutes).

Moving to the App Router may be the first time using React features that Next.js builds on top of such as Server Components, Suspense, and more. When combined with new Next.js features such as special files and layouts, migration means new concepts, mental models, and behavioral changes to learn.

We recommend reducing the combined complexity of these updates by breaking down your migration into smaller steps. The app directory is intentionally designed to work simultaneously with the pages directory to allow for incremental page-by-page migration.

Update to the latest Next.js version (requires 13.4 or greater):

Then, create a new app directory at the root of your project (or src/ directory).

Create a new app/layout.tsx file inside the app directory. This is a root layout that will apply to all routes inside app.

To manage <head> HTML elements, you can use the built-in SEO support:

If you have an existing _app or _document file, you can copy the contents (e.g. global styles) to the root layout (app/layout.tsx). Styles in app/layout.tsx will not apply to pages/*. You should keep _app/_document while migrating to prevent your pages/* routes from breaking. Once fully migrated, you can then safely delete them.

If you are using any React Context providers, they will need to be moved to a Client Component.

Next.js recommended adding a property to Page components to achieve per-page layouts in the pages directory. This pattern can be replaced with native support for nested layouts in the app directory.

Remove the Page.getLayout property from pages/dashboard/index.js and follow the steps for migrating pages to the app directory.

Move the contents of DashboardLayout into a new Client Component to retain pages directory behavior.

Import the DashboardLayout into a new layout.js file inside the app directory.

You can incrementally move non-interactive parts of DashboardLayout.js (Client Component) into layout.js (Server Component) to reduce the amount of component JavaScript you send to the client.

In the pages directory, the next/head React component is used to manage <head> HTML elements such as title and meta . In the app directory, next/head is replaced with the new built-in SEO support.

See all metadata options.

We recommend breaking down the migration of a page into two main steps:

Good to know: This is the easiest migration path because it has the most comparable behavior to the pages directory.

Step 1: Create a new Client Component

Step 2: Create a new page

Create a new app/page.tsx file inside the app directory. This is a Server Component by default.

Import the home-page.tsx Client Component into the page.

If you were fetching data in pages/index.js, move the data fetching logic directly into the Server Component using the new data fetching APIs. See the data fetching upgrade guide for more details.

If your previous page used useRouter, you'll need to update to the new routing hooks. Learn more.

Start your development server and visit http://localhost:3000. You should see your existing index route, now served through the app directory.

A new router has been added to support the new behavior in the app directory.

In app, you should use the three new hooks imported from next/navigation: useRouter(), usePathname(), and useSearchParams().

In addition, the new useRouter hook has the following changes:

View the useRouter() API reference.

To keep components compatible between the pages and app routers, refer to the useRouter hook from next/compat/router. This is the useRouter hook from the pages directory, but intended to be used while sharing components between routers. Once you are ready to use it only on the app router, update to the new useRouter from next/navigation.

The pages directory uses getServerSideProps and getStaticProps to fetch data for pages. Inside the app directory, these previous data fetching functions are replaced with a simpler API built on top of fetch() and async React Server Components.

In the pages directory, getServerSideProps is used to fetch data on the server and forward props to the default exported React component in the file. The initial HTML for the page is prerendered from the server, followed by "hydrating" the page in the browser (making it interactive).

In the App Router, we can colocate our data fetching inside our React components using Server Components. This allows us to send less JavaScript to the client, while maintaining the rendered HTML from the server.

By setting the cache option to no-store, we can indicate that the fetched data should never be cached. This is similar to getServerSideProps in the pages directory.

In the pages directory, you can retrieve request-based data based on the Node.js HTTP API.

For example, you can retrieve the req object from getServerSideProps and use it to retrieve the request's cookies and headers.

The app directory exposes new read-only functions to retrieve request data:

In the pages directory, the getStaticProps function is used to pre-render a page at build time. This function can be used to fetch data from an external API or directly from a database, and pass this data down to the entire page as it's being generated during the build.

In the app directory, data fetching with fetch() will default to cache: 'force-cache', which will cache the request data until manually invalidated. This is similar to getStaticProps in the pages directory.

In the pages directory, the getStaticPaths function is used to define the dynamic paths that should be pre-rendered at build time.

In the app directory, getStaticPaths is replaced with generateStaticParams.

generateStaticParams behaves similarly to getStaticPaths, but has a simplified API for returning route parameters and can be used inside layouts. The return shape of generateStaticParams is an array of segments instead of an array of nested param objects or a string of resolved paths.

Using the name generateStaticParams is more appropriate than getStaticPaths for the new model in the app directory. The get prefix is replaced with a more descriptive generate, which sits better alone now that getStaticProps and getServerSideProps are no longer necessary. The Paths suffix is replaced by Params, which is more appropriate for nested routing with multiple dynamic segments.

In the pages directory, the fallback property returned from getStaticPaths is used to define the behavior of a page that isn't pre-rendered at build time. This property can be set to true to show a fallback page while the page is being generated, false to show a 404 page, or blocking to generate the page at request time.

In the app directory the config.dynamicParams property controls how params outside of generateStaticParams are handled:

This replaces the fallback: true | false | 'blocking' option of getStaticPaths in the pages directory. The fallback: 'blocking' option is not included in dynamicParams because the difference between 'blocking' and true is negligible with streaming.

With dynamicParams set to true (the default), when a route segment is requested that hasn't been generated, it will be server-rendered and cached.

In the pages directory, the getStaticProps function allows you to add a revalidate field to automatically regenerate a page after a certain amount of time.

In the app directory, data fetching with fetch() can use revalidate, which will cache the request for the specified amount of seconds.

API Routes continue to work in the pages/api directory without any changes. However, they have been replaced by Route Handlers in the app directory.

Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.

Good to know: If you previously used API routes to call an external API from the client, you can now use Server Components instead to securely fetch data. Learn more about data fetching.

If you are also migrating to Next.js from a Single-Page Application (SPA) at the same time, see our documentation to learn more.

In the pages directory, global stylesheets are restricted to only pages/_app.js. With the app directory, this restriction has been lifted. Global styles can be added to any layout, page, or component.

If you're using Tailwind CSS, you'll need to add the app directory to your tailwind.config.js file:

You'll also need to import your global styles in your app/layout.js file:

Learn more about styling with Tailwind CSS

When navigating between routes served by the different Next.js routers, there will be a hard navigation. Automatic link prefetching with next/link will not prefetch across routers.

Instead, you can optimize navigations between App Router and Pages Router to retain the prefetched and fast page transitions. Learn more.

Next.js provides Codemod transformations to help upgrade your codebase when a feature is deprecated. See Codemods for more information.

**Examples:**

Example 1 (unknown):
```unknown
npm install next@latest react@latest react-dom@latest
```

Example 2 (unknown):
```unknown
npm install -D eslint-config-next@latest
```

Example 3 (python):
```python
import Link from 'next/link'
 
// Next.js 12: `<a>` has to be nested otherwise it's excluded
<Link href="/about">
  <a>About</a>
</Link>
 
// Next.js 13: `<Link>` always renders `<a>` under the hood
<Link href="/about">
  About
</Link>
```

Example 4 (unknown):
```unknown
npm install next@latest
```

---

## How to set up instrumentation with OpenTelemetry

**URL:** https://nextjs.org/docs/app/guides/open-telemetry

**Contents:**
- How to set up instrumentation with OpenTelemetry
- Getting Started
  - Using @vercel/otel
  - Manual OpenTelemetry configuration
- Testing your instrumentation
- Deployment
  - Using OpenTelemetry Collector
    - Deploying on Vercel
    - Self-hosting
  - Custom Exporters

Observability is crucial for understanding and optimizing the behavior and performance of your Next.js app.

As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience.

We recommend using OpenTelemetry for instrumenting your apps. It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code. Read Official OpenTelemetry docs for more information about OpenTelemetry and how it works.

This documentation uses terms like Span, Trace or Exporter throughout this doc, all of which can be found in the OpenTelemetry Observability Primer.

Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself.

OpenTelemetry is extensible but setting it up properly can be quite verbose. That's why we prepared a package @vercel/otel that helps you get started quickly.

To get started, install the following packages:

Next, create a custom instrumentation.ts (or .js) file in the root directory of the project (or inside src folder if using one):

See the @vercel/otel documentation for additional configuration options.

The @vercel/otel package provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually.

Firstly you need to install OpenTelemetry packages:

Now you can initialize NodeSDK in your instrumentation.ts. Unlike @vercel/otel, NodeSDK is not compatible with edge runtime, so you need to make sure that you are importing them only when process.env.NEXT_RUNTIME === 'nodejs'. We recommend creating a new file instrumentation.node.ts which you conditionally import only when using node:

Doing this is equivalent to using @vercel/otel, but it's possible to modify and extend some features that are not exposed by the @vercel/otel. If edge runtime support is necessary, you will have to use @vercel/otel.

You need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally. We recommend using our OpenTelemetry dev environment.

If everything works well you should be able to see the root server span labeled as GET /requested/pathname. All other spans from that particular trace will be nested under it.

Next.js traces more spans than are emitted by default. To see more spans, you must set NEXT_OTEL_VERBOSE=1.

When you are deploying with OpenTelemetry Collector, you can use @vercel/otel. It will work both on Vercel and when self-hosted.

We made sure that OpenTelemetry works out of the box on Vercel.

Follow Vercel documentation to connect your project to an observability provider.

Deploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process the telemetry data from your Next.js app.

To do this, follow the OpenTelemetry Collector Getting Started guide, which will walk you through setting up the collector and configuring it to receive data from your Next.js app.

Once you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective deployment guides.

OpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with @vercel/otel or manual OpenTelemetry configuration.

You can add a custom span with OpenTelemetry APIs.

The following example demonstrates a function that fetches GitHub stars and adds a custom fetchGithubStars span to track the fetch request's result:

The register function will execute before your code runs in a new environment. You can start creating new spans, and they should be correctly added to the exported trace.

Next.js automatically instruments several spans for you to provide useful insights into your application's performance.

Attributes on spans follow OpenTelemetry semantic conventions. We also add some custom attributes under the next namespace:

This span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and status code of the request.

This span represents the process of rendering a route in the app router.

This span represents the fetch request executed in your code.

This span can be turned off by setting NEXT_OTEL_FETCH_DISABLED=1 in your environment. This is useful when you want to use a custom fetch instrumentation library.

This span represents the execution of an API Route Handler in the app router.

This span represents the execution of getServerSideProps for a specific route.

This span represents the execution of getStaticProps for a specific route.

This span represents the process of rendering the document for a specific route.

This span represents the process of generating metadata for a specific page (a single route can have multiple of these spans).

This span represents the process of resolving page components for a specific page.

This span represents loading of code modules for a layout or a page.

This zero-length span represents the time when the first byte has been sent in the response.

**Examples:**

Example 1 (unknown):
```unknown
npm install @vercel/otel @opentelemetry/sdk-logs @opentelemetry/api-logs @opentelemetry/instrumentation
```

Example 2 (python):
```python
import { registerOTel } from '@vercel/otel'
 
export function register() {
  registerOTel({ serviceName: 'next-app' })
}
```

Example 3 (unknown):
```unknown
npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http
```

Example 4 (unknown):
```unknown
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./instrumentation.node.ts')
  }
}
```

---

## generateSitemaps

**URL:** https://nextjs.org/docs/app/api-reference/functions/generate-sitemaps

**Contents:**
- generateSitemaps
- Returns
- URLs
- Example
- Version History
- Next Steps
  - sitemap.xml

You can use the generateSitemaps function to generate multiple sitemaps for your application.

The generateSitemaps returns an array of objects with an id property.

Your generated sitemaps will be available at /.../sitemap/[id].xml. For example, /product/sitemap/1.xml.

For example, to split a sitemap using generateSitemaps, return an array of objects with the sitemap id. Then, use the id to generate the unique sitemaps.

**Examples:**

Example 1 (python):
```python
import type { MetadataRoute } from 'next'
import { BASE_URL } from '@/app/lib/constants'
 
export async function generateSitemaps() {
  // Fetch the total number of products and calculate the number of sitemaps needed
  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]
}
 
export default async function sitemap(props: {
  id: Promise<number>
}): Promise<MetadataRoute.Sitemap> {
  const id = await props.id
  // Google's limit is 50,000 URLs per sitemap
  const start = id * 50000
  const end = start + 50000
  const products = await getProducts(
    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`
  )
  return products.map((product) => ({
    url: `${BASE_URL}/product/${product.id}`,
    lastModified: product.date,
  }))
}
```

---

## How to handle redirects in Next.js

**URL:** https://nextjs.org/docs/pages/guides/redirecting

**Contents:**
- How to handle redirects in Next.js
- useRouter() hook
- redirects in next.config.js
- NextResponse.redirect in Proxy
- Managing redirects at scale (advanced)
  - 1. Creating and storing a redirect map
  - 2. Optimizing data lookup performance

There are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects.

If you need to redirect inside a component, you can use the push method from the useRouter hook. For example:

See the useRouter API reference for more information.

The redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time.

redirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request.

To use redirects, add the option to your next.config.js file:

See the redirects API reference for more information.

Proxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects.

For example, to redirect the user to a /login page if they are not authenticated:

See the Proxy documentation for more information.

To manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application.

To do this, you'll need to consider:

Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below.

A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file.

Consider the following data structure:

In Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request:

Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance:

Considering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter.

If it does, forward the request to a API Routes which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request.

Then, in the API Route:

**Examples:**

Example 1 (python):
```python
import { useRouter } from 'next/router'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  async redirects() {
    return [
      // Basic redirect
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
      // Wildcard path matching
      {
        source: '/blog/:slug',
        destination: '/news/:slug',
        permanent: true,
      },
    ]
  },
}
 
export default nextConfig
```

Example 3 (python):
```python
import { NextResponse, NextRequest } from 'next/server'
import { authenticate } from 'auth-provider'
 
export function proxy(request: NextRequest) {
  const isAuthenticated = authenticate(request)
 
  // If the user is authenticated, continue as normal
  if (isAuthenticated) {
    return NextResponse.next()
  }
 
  // Redirect to login page if not authenticated
  return NextResponse.redirect(new URL('/login', request.url))
}
 
export const config = {
  matcher: '/dashboard/:path*',
}
```

Example 4 (unknown):
```unknown
{
  "/old": {
    "destination": "/new",
    "permanent": true
  },
  "/blog/post-old": {
    "destination": "/blog/post-new",
    "permanent": true
  }
}
```

---

## Linking and Navigating

**URL:** https://nextjs.org/docs/pages/building-your-application/routing/linking-and-navigating

**Contents:**
- Linking and Navigating
- Linking to dynamic paths
- Injecting the router
- Imperative Routing
- Shallow Routing
  - Caveats

The Next.js router allows you to do client-side route transitions between pages, similar to a single-page application.

A React component called Link is provided to do this client-side route transition.

The example above uses multiple links. Each one maps a path (href) to a known page:

Any <Link /> in the viewport (initially or through scroll) will be prefetched by default (including the corresponding data) for pages using Static Generation. The corresponding data for server-rendered routes is fetched only when the <Link /> is clicked.

You can also use interpolation to create the path, which comes in handy for dynamic route segments. For example, to show a list of posts which have been passed to the component as a prop:

encodeURIComponent is used in the example to keep the path utf-8 compatible.

Alternatively, using a URL Object:

Now, instead of using interpolation to create the path, we use a URL object in href where:

To access the router object in a React component you can use useRouter or withRouter.

In general we recommend using useRouter.

next/link should be able to cover most of your routing needs, but you can also do client-side navigations without it, take a look at the documentation for next/router.

The following example shows how to do basic page navigations with useRouter:

Shallow routing allows you to change the URL without running data fetching methods again, that includes getServerSideProps, getStaticProps, and getInitialProps.

You'll receive the updated pathname and the query via the router object (added by useRouter or withRouter), without losing state.

To enable shallow routing, set the shallow option to true. Consider the following example:

The URL will get updated to /?counter=10 and the page won't get replaced, only the state of the route is changed.

You can also watch for URL changes via componentDidUpdate as shown below:

Shallow routing only works for URL changes in the current page. For example, let's assume we have another page called pages/about.js, and you run this:

Since that's a new page, it'll unload the current page, load the new one and wait for data fetching even though we asked to do shallow routing.

When shallow routing is used with proxy it will not ensure the new page matches the current page like previously done without proxy. This is due to proxy being able to rewrite dynamically and can't be verified client-side without a data fetch which is skipped with shallow, so a shallow route change must always be treated as shallow.

**Examples:**

Example 1 (python):
```python
import Link from 'next/link'
 
function Home() {
  return (
    <ul>
      <li>
        <Link href="/">Home</Link>
      </li>
      <li>
        <Link href="/about">About Us</Link>
      </li>
      <li>
        <Link href="/blog/hello-world">Blog Post</Link>
      </li>
    </ul>
  )
}
 
export default Home
```

Example 2 (python):
```python
import Link from 'next/link'
 
function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${encodeURIComponent(post.slug)}`}>
            {post.title}
          </Link>
        </li>
      ))}
    </ul>
  )
}
 
export default Posts
```

Example 3 (python):
```python
import Link from 'next/link'
 
function Posts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link
            href={{
              pathname: '/blog/[slug]',
              query: { slug: post.slug },
            }}
          >
            {post.title}
          </Link>
        </li>
      ))}
    </ul>
  )
}
 
export default Posts
```

Example 4 (python):
```python
import { useRouter } from 'next/router'
 
export default function ReadMore() {
  const router = useRouter()
 
  return (
    <button onClick={() => router.push('/about')}>
      Click here to read more
    </button>
  )
}
```

---

## updateTag

**URL:** https://nextjs.org/docs/app/api-reference/functions/updateTag

**Contents:**
- updateTag
- Usage
- Parameters
- Returns
- Differences from revalidateTag
- Examples
  - Server Action with Read-Your-Own-Writes
  - Error when used outside Server Actions
- When to use updateTag
- Related

updateTag allows you to update cached data on-demand for a specific cache tag from within Server Actions.

This function is designed for read-your-own-writes scenarios, where a user makes a change (like creating a post), and the UI immediately shows the change, rather than stale data.

updateTag can only be called from within Server Actions. It cannot be used in Route Handlers, Client Components, or any other context.

If you need to invalidate cache tags in Route Handlers or other contexts, use revalidateTag instead.

Good to know: updateTag immediately expires the cached data for the specified tag. The next request will wait to fetch fresh data rather than serving stale content from the cache, ensuring users see their changes immediately.

Tags must first be assigned to cached data. You can do this in two ways:

updateTag does not return a value.

While both updateTag and revalidateTag invalidate cached data, they serve different purposes:

Use revalidateTag instead when:

**Examples:**

Example 1 (unknown):
```unknown
updateTag(tag: string): void;
```

Example 2 (unknown):
```unknown
fetch(url, { next: { tags: ['posts'] } })
```

Example 3 (python):
```python
import { cacheTag } from 'next/cache'
 
async function getData() {
  'use cache'
  cacheTag('posts')
  // ...
}
```

Example 4 (python):
```python
'use server'
 
import { updateTag } from 'next/cache'
import { redirect } from 'next/navigation'
 
export async function createPost(formData: FormData) {
  const title = formData.get('title')
  const content = formData.get('content')
 
  // Create the post in your database
  const post = await db.post.create({
    data: { title, content },
  })
 
  // Invalidate cache tags so the new post is immediately visible
  // 'posts' tag: affects any page that displays a list of posts
  updateTag('posts')
  // 'post-{id}' tag: affects the individual post detail page
  updateTag(`post-${post.id}`)
 
  // Redirect to the new post - user will see fresh data, not cached
  redirect(`/posts/${post.id}`)
}
```

---

## Metadata Files API Reference

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/metadata

**Contents:**
- Metadata Files API Reference
  - favicon, icon, and apple-icon
  - manifest.json
  - opengraph-image and twitter-image
  - robots.txt
  - sitemap.xml

This section of the docs covers Metadata file conventions. File-based metadata can be defined by adding special metadata files to route segments.

Each file convention can be defined using a static file (e.g. opengraph-image.jpg), or a dynamic variant that uses code to generate the file (e.g. opengraph-image.js).

Once a file is defined, Next.js will automatically serve the file (with hashes in production for caching) and update the relevant head elements with the correct metadata, such as the asset's URL, file type, and image size.

---

## How to preview content with Draft Mode in Next.js

**URL:** https://nextjs.org/docs/pages/guides/draft-mode

**Contents:**
- How to preview content with Draft Mode in Next.js
- Step 1: Create and access the API route
  - Securely accessing it from your Headless CMS
- Step 2: Update getStaticProps
  - Fetch draft data
- More Details
  - Clear the Draft Mode cookie
  - Works with getServerSideProps
  - Works with API Routes
  - Unique per next build

In the Pages documentation and the Data Fetching documentation, we talked about how to pre-render a page at build time (Static Generation) using getStaticProps and getStaticPaths.

Static Generation is useful when your pages fetch data from a headless CMS. However, itâ€™s not ideal when youâ€™re writing a draft on your headless CMS and want to view the draft immediately on your page. Youâ€™d want Next.js to render these pages at request time instead of build time and fetch the draft content instead of the published content. Youâ€™d want Next.js to bypass Static Generation only for this specific case.

Next.js has a feature called Draft Mode which solves this problem. Here are instructions on how to use it.

Take a look at the API Routes documentation first if youâ€™re not familiar with Next.js API Routes.

First, create the API route. It can have any name - e.g. pages/api/draft.ts

In this API route, you need to call setDraftMode on the response object.

This will set a cookie to enable draft mode. Subsequent requests containing this cookie will trigger Draft Mode changing the behavior for statically generated pages (more on this later).

You can test this manually by creating an API route like below and accessing it from your browser manually:

If you open your browserâ€™s developer tools and visit /api/draft, youâ€™ll notice a Set-Cookie response header with a cookie named __prerender_bypass.

In practice, youâ€™d want to call this API route securely from your headless CMS. The specific steps will vary depending on which headless CMS youâ€™re using, but here are some common steps you could take.

These steps assume that the headless CMS youâ€™re using supports setting custom draft URLs. If it doesnâ€™t, you can still use this method to secure your draft URLs, but youâ€™ll need to construct and access the draft URL manually.

First, you should create a secret token string using a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS. This secret prevents people who donâ€™t have access to your CMS from accessing draft URLs.

Second, if your headless CMS supports setting custom draft URLs, specify the following as the draft URL. This assumes that your draft API route is located at pages/api/draft.ts.

Your headless CMS might allow you to include a variable in the draft URL so that <path> can be set dynamically based on the CMSâ€™s data like so: &slug=/posts/{entry.fields.slug}

Finally, in the draft API route:

If it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie.

The next step is to update getStaticProps to support draft mode.

If you request a page which has getStaticProps with the cookie set (via res.setDraftMode), then getStaticProps will be called at request time (instead of at build time).

Furthermore, it will be called with a context object where context.draftMode will be true.

We used res.setDraftMode in the draft API route, so context.draftMode will be true.

If youâ€™re also using getStaticPaths, then context.params will also be available.

You can update getStaticProps to fetch different data based on context.draftMode.

For example, your headless CMS might have a different API endpoint for draft posts. If so, you can modify the API endpoint URL like below:

Thatâ€™s it! If you access the draft API route (with secret and slug) from your headless CMS or manually, you should now be able to see the draft content. And if you update your draft without publishing, you should be able to view the draft.

Set this as the draft URL on your headless CMS or access manually, and you should be able to see the draft.

By default, the Draft Mode session ends when the browser is closed.

To clear the Draft Mode cookie manually, create an API route that calls setDraftMode({ enable: false }):

Then, send a request to /api/disable-draft to invoke the API Route. If calling this route using next/link, you must pass prefetch={false} to prevent accidentally deleting the cookie on prefetch.

Draft Mode works with getServerSideProps, and is available as a draftMode key in the context object.

Good to know: You shouldn't set the Cache-Control header when using Draft Mode because it cannot be bypassed. Instead, we recommend using ISR.

API Routes will have access to draftMode on the request object. For example:

A new bypass cookie value will be generated each time you run next build.

This ensures that the bypass cookie canâ€™t be guessed.

Good to know: To test Draft Mode locally over HTTP, your browser will need to allow third-party cookies and local storage access.

**Examples:**

Example 1 (unknown):
```unknown
export default function handler(req, res) {
  // ...
  res.setDraftMode({ enable: true })
  // ...
}
```

Example 2 (unknown):
```unknown
// simple example for testing it manually from your browser.
export default function handler(req, res) {
  res.setDraftMode({ enable: true })
  res.end('Draft mode is enabled')
}
```

Example 3 (unknown):
```unknown
https://<your-site>/api/draft?secret=<token>&slug=<path>
```

Example 4 (javascript):
```javascript
export default async (req, res) => {
  // Check the secret and next parameters
  // This secret should only be known to this API route and the CMS
  if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {
    return res.status(401).json({ message: 'Invalid token' })
  }
 
  // Fetch the headless CMS to check if the provided `slug` exists
  // getPostBySlug would implement the required fetching logic to the headless CMS
  const post = await getPostBySlug(req.query.slug)
 
  // If the slug doesn't exist prevent draft mode from being enabled
  if (!post) {
    return res.status(401).json({ message: 'Invalid slug' })
  }
 
  // Enable Draft Mode by setting the cookie
  res.setDraftMode({ enable: true })
 
  // Redirect to the path from the fetched post
  // We don't redirect to req.query.slug as that might lead to open redirect vulnerabilities
  res.redirect(post.slug)
}
```

---

## How to set up Playwright with Next.js

**URL:** https://nextjs.org/docs/pages/guides/testing/playwright

**Contents:**
- How to set up Playwright with Next.js
- Quickstart
- Manual setup
- Creating your first Playwright E2E test
  - Running your Playwright tests
  - Running Playwright on Continuous Integration (CI)

Playwright is a testing framework that lets you automate Chromium, Firefox, and WebKit with a single API. You can use it to write End-to-End (E2E) testing. This guide will show you how to set up Playwright with Next.js and write your first tests.

The fastest way to get started is to use create-next-app with the with-playwright example. This will create a Next.js project complete with Playwright configured.

To install Playwright, run the following command:

This will take you through a series of prompts to setup and configure Playwright for your project, including adding a playwright.config.ts file. Please refer to the Playwright installation guide for the step-by-step guide.

Create two new Next.js pages:

Then, add a test to verify that your navigation is working correctly:

Good to know: You can use page.goto("/") instead of page.goto("http://localhost:3000/"), if you add "baseURL": "http://localhost:3000" to the playwright.config.ts configuration file.

Playwright will simulate a user navigating your application using three browsers: Chromium, Firefox and Webkit, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave.

Run npm run build and npm run start, then run npx playwright test in another terminal window to run the Playwright tests.

Good to know: Alternatively, you can use the webServer feature to let Playwright start the development server and wait until it's fully available.

Playwright will by default run your tests in the headless mode. To install all the Playwright dependencies, run npx playwright install-deps.

You can learn more about Playwright and Continuous Integration from these resources:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --example with-playwright with-playwright-app
```

Example 2 (unknown):
```unknown
npm init playwright
# or
yarn create playwright
# or
pnpm create playwright
```

Example 3 (python):
```python
import Link from 'next/link'
 
export default function Home() {
  return (
    <div>
      <h1>Home</h1>
      <Link href="/about">About</Link>
    </div>
  )
}
```

Example 4 (python):
```python
import Link from 'next/link'
 
export default function About() {
  return (
    <div>
      <h1>About</h1>
      <Link href="/">Home</Link>
    </div>
  )
}
```

---

## connection

**URL:** https://nextjs.org/docs/app/api-reference/functions/connection

**Contents:**
- connection
- Reference
  - Type
  - Parameters
  - Returns
- Good to know
  - Version History

The connection() function allows you to indicate rendering should wait for an incoming user request before continuing.

It's useful when a component doesn't use Dynamic APIs, but you want it to be dynamically rendered at runtime and not statically rendered at build time. This usually occurs when you access external information that you intentionally want to change the result of a render, such as Math.random() or new Date().

**Examples:**

Example 1 (python):
```python
import { connection } from 'next/server'
 
export default async function Page() {
  await connection()
  // Everything below will be excluded from prerendering
  const rand = Math.random()
  return <span>{rand}</span>
}
```

Example 2 (unknown):
```unknown
function connection(): Promise<void>
```

---

## transpilePackages

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/transpilePackages

**Contents:**
- transpilePackages
- Version History

Next.js can automatically transpile and bundle dependencies from local packages (like monorepos) or from external dependencies (node_modules). This replaces the next-transpile-modules package.

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  transpilePackages: ['package-name'],
}
 
module.exports = nextConfig
```

---

## unstable_cache

**URL:** https://nextjs.org/docs/app/api-reference/functions/unstable_cache

**Contents:**
- unstable_cache
- Parameters
- Returns
- Example
- Version History

Warning: This API will be replaced by use cache when it reaches stability.

unstable_cache allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.

unstable_cache returns a function that when invoked, returns a Promise that resolves to the cached data. If the data is not in the cache, the provided function will be invoked, and its result will be cached and returned.

**Examples:**

Example 1 (python):
```python
import { getUser } from './data';
import { unstable_cache } from 'next/cache';
 
const getCachedUser = unstable_cache(
  async (id) => getUser(id),
  ['my-app-user']
);
 
export default async function Component({ userID }) {
  const user = await getCachedUser(userID);
  ...
}
```

Example 2 (javascript):
```javascript
const data = unstable_cache(fetchData, keyParts, options)()
```

Example 3 (python):
```python
import { unstable_cache } from 'next/cache'
 
export default async function Page({
  params,
}: {
  params: Promise<{ userId: string }>
}) {
  const { userId } = await params
  const getCachedUser = unstable_cache(
    async () => {
      return { id: userId }
    },
    [userId], // add the user ID to the cache key
    {
      tags: ['users'],
      revalidate: 60,
    }
  )
 
  //...
}
```

---

## Guides

**URL:** https://nextjs.org/docs/pages/guides

**Contents:**
- Guides
  - Analytics
  - Authentication
  - Babel
  - CI Build Caching
  - Content Security Policy
  - CSS-in-JS
  - Custom Server
  - Debugging
  - Draft Mode

---

## Guides

**URL:** https://nextjs.org/docs/15/app/guides

**Contents:**
- Guides
  - Analytics
  - Authentication
  - Backend for Frontend
  - Caching
  - CI Build Caching
  - Content Security Policy
  - CSS-in-JS
  - Custom Server
  - Data Security

---

## usePathname

**URL:** https://nextjs.org/docs/app/api-reference/functions/use-pathname

**Contents:**
- usePathname
- Parameters
- Returns
- Examples
  - Do something in response to a route change
  - Avoid hydration mismatch with rewrites

usePathname is a Client Component hook that lets you read the current URL's pathname.

Good to know: When cacheComponents is enabled usePathname may require a Suspense boundary around it if your route has a dynamic param. If you use generateStaticParams the Suspense boundary is optional

usePathname intentionally requires using a Client Component. It's important to note Client Components are not a de-optimization. They are an integral part of the Server Components architecture.

For example, a Client Component with usePathname will be rendered into HTML on the initial page load. When navigating to a new route, this component does not need to be re-fetched. Instead, the component is downloaded once (in the client JavaScript bundle), and re-renders based on the current state.

If you have components that use usePathname and they are imported into routes within the Pages Router, be aware that usePathname may return null if the router is not yet initialized. This can occur in cases such as fallback routes or during Automatic Static Optimization in the Pages Router.

To enhance compatibility between routing systems, if your project contains both an app and a pages directory, Next.js will automatically adjust the return type of usePathname.

usePathname does not take any parameters.

usePathname returns a string of the current URL's pathname. For example:

When a page is pre-rendered, the HTML is generated for the source pathname. If the page is then reached through a rewrite using next.config or Proxy, the browser URL may differ, and usePathname() will read the rewritten pathname on the client.

To avoid hydration mismatches, design the UI so that only a small, isolated part depends on the client pathname. Render a stable fallback on the server and update that part after mount.

**Examples:**

Example 1 (python):
```python
'use client'
 
import { usePathname } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const pathname = usePathname()
  return <p>Current pathname: {pathname}</p>
}
```

Example 2 (javascript):
```javascript
const pathname = usePathname()
```

Example 3 (python):
```python
'use client'
 
import { useEffect } from 'react'
import { usePathname, useSearchParams } from 'next/navigation'
 
function ExampleClientComponent() {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  useEffect(() => {
    // Do something here...
  }, [pathname, searchParams])
}
```

Example 4 (python):
```python
'use client'
 
import { useEffect, useState } from 'react'
import { usePathname } from 'next/navigation'
 
export default function PathnameBadge() {
  const pathname = usePathname()
  const [clientPathname, setClientPathname] = useState('')
 
  useEffect(() => {
    setClientPathname(pathname)
  }, [pathname])
 
  return (
    <p>
      Current pathname: <span>{clientPathname}</span>
    </p>
  )
}
```

---

## Form

**URL:** https://nextjs.org/docs/pages/api-reference/components/form

**Contents:**
- Form
- Reference
  - action (string) Props
  - Caveats

The <Form> component extends the HTML <form> element to provide client-side navigation on submission, and progressive enhancement.

It's useful for forms that update URL search params as it reduces the boilerplate code needed to achieve the above.

The behavior of the <Form> component depends on whether the action prop is passed a string or function.

When action is a string, the <Form> component supports the following props:

**Examples:**

Example 1 (python):
```python
import Form from 'next/form'
 
export default function Page() {
  return (
    <Form action="/search">
      {/* On submission, the input value will be appended to
          the URL, e.g. /search?query=abc */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

---

## useParams

**URL:** https://nextjs.org/docs/app/api-reference/functions/use-params

**Contents:**
- useParams
- Parameters
- Returns
- Version History

useParams is a Client Component hook that lets you read a route's dynamic params filled in by the current URL.

useParams does not take any parameters.

useParams returns an object containing the current route's filled in dynamic parameters.

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useParams } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const params = useParams<{ tag: string; item: string }>()
 
  // Route -> /shop/[tag]/[item]
  // URL -> /shop/shoes/nike-air-max-97
  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }
  console.log(params)
 
  return '...'
}
```

Example 2 (javascript):
```javascript
const params = useParams()
```

---

## How to build single-page applications with Next.js

**URL:** https://nextjs.org/docs/15/app/guides/single-page-applications

**Contents:**
- How to build single-page applications with Next.js
- What is a Single-Page Application?
- Why use Next.js for SPAs?
- Examples
  - Using Reactâ€™s use within a Context Provider
  - SPAs with SWR
  - SPAs with React Query
  - Rendering components only in the browser
  - Shallow routing on the client
  - Using Server Actions in Client Components

Next.js fully supports building Single-Page Applications (SPAs).

This includes fast route transitions with prefetching, client-side data fetching, using browser APIs, integrating with third-party client libraries, creating static routes, and more.

If you have an existing SPA, you can migrate to Next.js without large changes to your code. Next.js then allows you to progressively add server features as needed.

The definition of a SPA varies. Weâ€™ll define a â€œstrict SPAâ€ as:

Strict SPAs often require large amounts of JavaScript to load before the page can be interactive. Further, client data waterfalls can be challenging to manage. Building SPAs with Next.js can address these issues.

Next.js can automatically code split your JavaScript bundles, and generate multiple HTML entry points into different routes. This avoids loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.

The next/link component automatically prefetches routes, giving you the fast page transitions of a strict SPA, but with the advantage of persisting application routing state to the URL for linking and sharing.

Next.js can start as a static site or even a strict SPA where everything is rendered client-side. If your project grows, Next.js allows you to progressively add more server features (e.g. React Server Components, Server Actions, and more) as needed.

Let's explore common patterns used to build SPAs and how Next.js solves them.

We recommend fetching data in a parent component (or layout), returning the Promise, and then unwrapping the value in a Client Component with Reactâ€™s use hook.

Next.js can start data fetching early on the server. In this example, thatâ€™s the root layout â€” the entry point to your application. The server can immediately begin streaming a response to the client.

By â€œhoistingâ€ your data fetching to the root layout, Next.js starts the specified requests on the server early before any other components in your application. This eliminates client waterfalls and prevents having multiple roundtrips between client and server. It can also significantly improve performance, as your server is closer (and ideally colocated) to where your database is located.

For example, update your root layout to call the Promise, but do not await it.

While you can defer and pass a single Promise as a prop to a Client Component, we generally see this pattern paired with a React context provider. This enables easier access from Client Components with a custom React Hook.

You can forward a Promise to the React context provider:

Finally, you can call the useUser() custom hook in any Client Component and unwrap the Promise:

The component that consumes the Promise (e.g. Profile above) will be suspended. This enables partial hydration. You can see the streamed and prerendered HTML before JavaScript has finished loading.

SWR is a popular React library for data fetching.

With SWR 2.3.0 (and React 19+), you can gradually adopt server features alongside your existing SWR-based client data fetching code. This is an abstraction of the above use() pattern. This means you can move data fetching between the client and server-side, or use both:

For example, wrap your application with <SWRConfig> and a fallback:

Because this is a Server Component, getUser() can securely read cookies, headers, or talk to your database. No separate API route is needed. Client components below the <SWRConfig> can call useSWR() with the same key to retrieve the user data. The component code with useSWR does not require any changes from your existing client-fetching solution.

The fallback data can be prerendered and included in the initial HTML response, then immediately read in the child components using useSWR. SWRâ€™s polling, revalidation, and caching still run client-side only, so it preserves all the interactivity you rely on for an SPA.

Since the initial fallback data is automatically handled by Next.js, you can now delete any conditional logic previously needed to check if data was undefined. When the data is loading, the closest <Suspense> boundary will be suspended.

You can use React Query with Next.js on both the client and server. This enables you to build both strict SPAs, as well as take advantage of server features in Next.js paired with React Query.

Learn more in the React Query documentation.

Client components are prerendered during next build. If you want to disable prerendering for a Client Component and only load it in the browser environment, you can use next/dynamic:

This can be useful for third-party libraries that rely on browser APIs like window or document. You can also add a useEffect that checks for the existence of these APIs, and if they do not exist, return null or a loading state which would be prerendered.

If you are migrating from a strict SPA like Create React App or Vite, you might have existing code which shallow routes to update the URL state. This can be useful for manual transitions between views in your application without using the default Next.js file-system routing.

Next.js allows you to use the native window.history.pushState and window.history.replaceState methods to update the browser's history stack without reloading the page.

pushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams.

Learn more about how routing and navigation work in Next.js.

You can progressively adopt Server Actions while still using Client Components. This allows you to remove boilerplate code to call an API route, and instead use React features like useActionState to handle loading and error states.

For example, create your first Server Action:

You can import and use a Server Action from the client, similar to calling a JavaScript function. You do not need to create an API endpoint manually:

Learn more about mutating data with Server Actions.

Next.js also supports generating a fully static site. This has some advantages over strict SPAs:

To enable a static export, update your configuration:

After running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application.

Note: Next.js server features are not supported with static exports. Learn more.

You can incrementally migrate to Next.js by following our guides:

If you are already using a SPA with the Pages Router, you can learn how to incrementally adopt the App Router.

**Examples:**

Example 1 (python):
```python
import { UserProvider } from './user-provider'
import { getUser } from './user' // some server-side function
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  let userPromise = getUser() // do NOT await
 
  return (
    <html lang="en">
      <body>
        <UserProvider userPromise={userPromise}>{children}</UserProvider>
      </body>
    </html>
  )
}
```

Example 2 (python):
```python
'use client';
 
import { createContext, useContext, ReactNode } from 'react';
 
type User = any;
type UserContextType = {
  userPromise: Promise<User | null>;
};
 
const UserContext = createContext<UserContextType | null>(null);
 
export function useUser(): UserContextType {
  let context = useContext(UserContext);
  if (context === null) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}
 
export function UserProvider({
  children,
  userPromise
}: {
  children: ReactNode;
  userPromise: Promise<User | null>;
}) {
  return (
    <UserContext.Provider value={{ userPromise }}>
      {children}
    </UserContext.Provider>
  );
}
```

Example 3 (python):
```python
'use client'
 
import { use } from 'react'
import { useUser } from './user-provider'
 
export function Profile() {
  const { userPromise } = useUser()
  const user = use(userPromise)
 
  return '...'
}
```

Example 4 (python):
```python
import { SWRConfig } from 'swr'
import { getUser } from './user' // some server-side function
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <SWRConfig
      value={{
        fallback: {
          // We do NOT await getUser() here
          // Only components that read this data will suspend
          '/api/user': getUser(),
        },
      }}
    >
      {children}
    </SWRConfig>
  )
}
```

---

## browserDebugInfoInTerminal

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/browserDebugInfoInTerminal

**Contents:**
- browserDebugInfoInTerminal
- Usage
  - Serialization limits
  - Source location

The experimental.browserDebugInfoInTerminal option forwards console output and runtime errors originating in the browser to the dev server terminal.

This option is disabled by default. When enabled it only works in development mode.

Deeply nested objects/arrays are truncated using sensible defaults. You can tweak these limits:

Source locations are included by default when this feature is enabled.

Clicking the button prints this message to the terminal.

To suppress them, set showSourceLocation: false.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    browserDebugInfoInTerminal: true,
  },
}
 
export default nextConfig
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    browserDebugInfoInTerminal: {
      depthLimit: 5,
      edgeLimit: 100,
    },
  },
}
 
export default nextConfig
```

Example 3 (javascript):
```javascript
'use client'
 
export default function Home() {
  return (
    <button
      type="button"
      onClick={() => {
        console.log('Hello World')
      }}
    >
      Click me
    </button>
  )
}
```

Example 4 (unknown):
```unknown
[browser] Hello World (app/page.tsx:8:17)
```

---

## How to use and optimize videos

**URL:** https://nextjs.org/docs/app/guides/videos

**Contents:**
- How to use and optimize videos
- Using <video> and <iframe>
  - <video>
  - Common <video> tag attributes
  - Video best practices
  - <iframe>
  - Common <iframe> tag attributes
  - Choosing a video embedding method
  - Embedding externally hosted videos
- Self-hosted videos

This page outlines how to use videos with Next.js applications, showing how to store and display video files without affecting performance.

Videos can be embedded on the page using the HTML <video> tag for direct video files and <iframe> for external platform-hosted videos.

The HTML <video> tag can embed self-hosted or directly served video content, allowing full control over the playback and appearance.

Good to know: When using the autoPlay attribute, it is important to also include the muted attribute to ensure the video plays automatically in most browsers and the playsInline attribute for compatibility with iOS devices.

For a comprehensive list of video attributes, refer to the MDN documentation.

The HTML <iframe> tag allows you to embed videos from external platforms like YouTube or Vimeo.

For a comprehensive list of iframe attributes, refer to the MDN documentation.

There are two ways you can embed videos in your Next.js application:

Choose the embedding method that aligns with your application's requirements and the user experience you aim to deliver.

To embed videos from external platforms, you can use Next.js to fetch the video information and React Suspense to handle the fallback state while loading.

1. Create a Server Component for video embedding

The first step is to create a Server Component that generates the appropriate iframe for embedding the video. This component will fetch the source URL for the video and render the iframe.

2. Stream the video component using React Suspense

After creating the Server Component to embed the video, the next step is to stream the component using React Suspense.

Good to know: When embedding videos from external platforms, consider the following best practices:

This approach results in a better user experience as it prevents the page from blocking, meaning the user can interact with the page while the video component streams in.

For a more engaging and informative loading experience, consider using a loading skeleton as the fallback UI. So instead of showing a simple loading message, you can show a skeleton that resembles the video player like this:

Self-hosting videos may be preferable for several reasons:

Vercel Blob offers an efficient way to host videos, providing a scalable cloud storage solution that works well with Next.js. Here's how you can host a video using Vercel Blob:

1. Uploading a video to Vercel Blob

In your Vercel dashboard, navigate to the "Storage" tab and select your Vercel Blob store. In the Blob table's upper-right corner, find and click the "Upload" button. Then, choose the video file you wish to upload. After the upload completes, the video file will appear in the Blob table.

Alternatively, you can upload your video using a server action. For detailed instructions, refer to the Vercel documentation on server-side uploads. Vercel also supports client-side uploads. This method may be preferable for certain use cases.

2. Displaying the video in Next.js

Once the video is uploaded and stored, you can display it in your Next.js application. Here's an example of how to do this using the <video> tag and React Suspense:

In this approach, the page uses the video's @vercel/blob URL to display the video using the VideoComponent. React Suspense is used to show a fallback until the video URL is fetched and the video is ready to be displayed.

If you have subtitles for your video, you can easily add them using the <track> element inside your <video> tag. You can fetch the subtitle file from Vercel Blob in a similar way as the video file. Here's how you can update the <VideoComponent> to include subtitles.

By following this approach, you can effectively self-host and integrate videos into your Next.js applications.

To continue learning more about video optimization and best practices, please refer to the following resources:

Explore these video streaming platforms for integrating video into your Next.js projects:

**Examples:**

Example 1 (unknown):
```unknown
export function Video() {
  return (
    <video width="320" height="240" controls preload="none">
      <source src="/path/to/video.mp4" type="video/mp4" />
      <track
        src="/path/to/captions.vtt"
        kind="subtitles"
        srcLang="en"
        label="English"
      />
      Your browser does not support the video tag.
    </video>
  )
}
```

Example 2 (unknown):
```unknown
export default function Page() {
  return (
    <iframe src="https://www.youtube.com/embed/19g66ezsKAg" allowFullScreen />
  )
}
```

Example 3 (javascript):
```javascript
export default async function VideoComponent() {
  const src = await getVideoSrc()
 
  return <iframe src={src} allowFullScreen />
}
```

Example 4 (python):
```python
import { Suspense } from 'react'
import VideoComponent from '../ui/VideoComponent.jsx'
 
export default function Page() {
  return (
    <section>
      <Suspense fallback={<p>Loading video...</p>}>
        <VideoComponent />
      </Suspense>
      {/* Other content of the page */}
    </section>
  )
}
```

---

## Functions

**URL:** https://nextjs.org/docs/pages/api-reference/functions

**Contents:**
- Functions
  - getInitialProps
  - getServerSideProps
  - getStaticPaths
  - getStaticProps
  - NextRequest
  - NextResponse
  - useReportWebVitals
  - useRouter
  - userAgent

---

## How to think about data security in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/data-security

**Contents:**
- How to think about data security in Next.js
- Data fetching approaches
  - External HTTP APIs
  - Data Access Layer
  - Component-level data access
- Reading data
  - Passing data from server to client
  - Tainting
  - Preventing client-side execution of server-only code
- Mutating Data

React Server Components improve performance and simplify data fetching, but also shift where and how data is accessed, changing some of the traditional security assumptions for handling data in frontend apps.

This guide will help you understand how to think about data security in Next.js and how to implement best practices.

There are three main approaches we recommend for fetching data in Next.js, depending on the size and age of your project:

We recommend choosing one data fetching approach and avoiding mixing them. This makes it clear for both developers working in your code base and security auditors what to expect.

You should follow a Zero Trust model when adopting Server Components in an existing project. You can continue calling your existing API endpoints such as REST or GraphQL from Server Components using fetch, just as you would in Client Components.

This approach works well when:

For new projects, we recommend creating a dedicated Data Access Layer (DAL). This is a internal library that controls how and when data is fetched, and what gets passed to your render context.

A Data Access Layer should:

This approach centralizes all data access logic, making it easier to enforce consistent data access and reduces the risk of authorization bugs. You also get the benefit of sharing an in-memory cache across different parts of a request.

Good to know: Secret keys should be stored in environment variables, but only the Data Access Layer should access process.env. This keeps secrets from being exposed to other parts of the application.

For quick prototypes and iteration, database queries can be placed directly in Server Components.

This approach, however, makes it easier to accidentally expose private data to the client, for example:

You should sanitize the data before passing it to the Client Component:

On the initial load, both Server and Client Components run on the server to generate HTML. However, they execute in isolated module systems. This ensures that Server Components can access private data and APIs, while Client Components cannot.

This ensures the app is secure by default, but it's possible to accidentally expose private data through how data is fetched or passed to components.

To prevent accidental exposure of private data to the client, you can use React Taint APIs:

You can enable usage in your Next.js app with the experimental.taint option in next.config.js:

This prevents the tainted objects or values from being passed to the client. However, it's an additional layer of protection, you should still filter and sanitize the data in your DAL before passing it to React's render context.

To prevent server-only code from being executed on the client, you can mark a module with the server-only package:

This ensures that proprietary code or internal business logic stays on the server by causing a build error if the module is imported in the client environment.

Next.js handles mutations with Server Actions.

By default, when a Server Action is created and exported, it creates a public HTTP endpoint and should be treated with the same security assumptions and authorization checks. This means, even if a Server Action or utility function is not imported elsewhere in your code, it's still publicly accessible.

To improve security, Next.js has the following built-in features:

The IDs are created during compilation and are cached for a maximum of 14 days. They will be regenerated when a new build is initiated or when the build cache is invalidated. This security improvement reduces the risk in cases where an authentication layer is missing. However, you should still treat Server Actions like public HTTP endpoints.

You should always validate input from client, as they can be easily modified. For example, form data, URL parameters, headers, and searchParams:

You should always ensure that a user is authorized to perform an action. For example:

Learn more about Authentication in Next.js.

Defining a Server Action inside a component creates a closure where the action has access to the outer function's scope. For example, the publish action has access to the publishVersion variable:

Closures are useful when you need to capture a snapshot of data (e.g. publishVersion) at the time of rendering so that it can be used later when the action is invoked.

However, for this to happen, the captured variables are sent to the client and back to the server when the action is invoked. To prevent sensitive data from being exposed to the client, Next.js automatically encrypts the closed-over variables. A new private key is generated for each action every time a Next.js application is built. This means actions can only be invoked for a specific build.

Good to know: We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client.

When self-hosting your Next.js application across multiple servers, each server instance may end up with a different encryption key, leading to potential inconsistencies.

To mitigate this, you can overwrite the encryption key using the process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY environment variable. Specifying this variable ensures that your encryption keys are persistent across builds, and all server instances use the same key. This variable must be AES-GCM encrypted.

This is an advanced use case where consistent encryption behavior across multiple deployments is critical for your application. You should consider standard security practices such key rotation and signing.

Good to know: Next.js applications deployed to Vercel automatically handle this.

Since Server Actions can be invoked in a <form> element, this opens them up to CSRF attacks.

Behind the scenes, Server Actions use the POST method, and only this HTTP method is allowed to invoke them. This prevents most CSRF vulnerabilities in modern browsers, particularly with SameSite cookies being the default.

As an additional protection, Server Actions in Next.js also compare the Origin header to the Host header (or X-Forwarded-Host). If these don't match, the request will be aborted. In other words, Server Actions can only be invoked on the same host as the page that hosts it.

For large applications that use reverse proxies or multi-layered backend architectures (where the server API differs from the production domain), it's recommended to use the configuration option serverActions.allowedOrigins option to specify a list of safe origins. The option accepts an array of strings.

Learn more about Security and Server Actions.

Mutations (e.g. logging out users, updating databases, invalidating caches) should never be a side-effect, either in Server or Client Components. Next.js explicitly prevents setting cookies or triggering cache revalidation within render methods to avoid unintended side effects.

Instead, you should use Server Actions to handle mutations.

Good to know: Next.js uses POST requests to handle mutations. This prevents accidental side-effects from GET requests, reducing Cross-Site Request Forgery (CSRF) risks.

If you're doing an audit of a Next.js project, here are a few things we recommend looking extra at:

**Examples:**

Example 1 (python):
```python
import { cookies } from 'next/headers'
 
export default async function Page() {
  const cookieStore = cookies()
  const token = cookieStore.get('AUTH_TOKEN')?.value
 
  const res = await fetch('https://api.example.com/profile', {
    headers: {
      Cookie: `AUTH_TOKEN=${token}`,
      // Other headers
    },
  })
 
  // ....
}
```

Example 2 (python):
```python
import { cache } from 'react'
import { cookies } from 'next/headers'
 
// Cached helper methods makes it easy to get the same value in many places
// without manually passing it around. This discourages passing it from Server
// Component to Server Component which minimizes risk of passing it to a Client
// Component.
export const getCurrentUser = cache(async () => {
  const token = cookies().get('AUTH_TOKEN')
  const decodedToken = await decryptAndValidate(token)
  // Don't include secret tokens or private information as public fields.
  // Use classes to avoid accidentally passing the whole object to the client.
  return new User(decodedToken.id)
})
```

Example 3 (python):
```python
import 'server-only'
import { getCurrentUser } from './auth'
 
function canSeeUsername(viewer: User) {
  // Public info for now, but can change
  return true
}
 
function canSeePhoneNumber(viewer: User, team: string) {
  // Privacy rules
  return viewer.isAdmin || team === viewer.team
}
 
export async function getProfileDTO(slug: string) {
  // Don't pass values, read back cached values, also solves context and easier to make it lazy
 
  // use a database API that supports safe templating of queries
  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`
  const userData = rows[0]
 
  const currentUser = await getCurrentUser()
 
  // only return the data relevant for this query and not everything
  // <https://www.w3.org/2001/tag/doc/APIMinimization>
  return {
    username: canSeeUsername(currentUser) ? userData.username : null,
    phonenumber: canSeePhoneNumber(currentUser, userData.team)
      ? userData.phonenumber
      : null,
  }
}
```

Example 4 (python):
```python
import { getProfile } from '../../data/user'
 
export async function Page({ params: { slug } }) {
  // This page can now safely pass around this profile knowing
  // that it shouldn't contain anything sensitive.
  const profile = await getProfile(slug);
  ...
}
```

---

## proxy.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/proxy

**Contents:**
- proxy.js
- Exports
  - Proxy function
  - Config object (optional)
  - Matcher
- Params
  - request
- NextResponse
- Execution order
- Runtime

Note: The middleware file convention is deprecated and has been renamed to proxy. See Migration to Proxy for more details.

The proxy.js|ts file is used to write Proxy and run code on the server before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.

Proxy executes before routes are rendered. It's particularly useful for implementing custom server-side logic like authentication, logging, or handling redirects.

Proxy is meant to be invoked separately of your render code and in optimized cases deployed to your CDN for fast redirect/rewrite handling, you should not attempt relying on shared modules or globals.

To pass information from Proxy to your application, use headers, cookies, rewrites, redirects, or the URL.

Create a proxy.ts (or .js) file in the project root, or inside src if applicable, so that it is located at the same level as pages or app.

If youâ€™ve customized pageExtensions, for example to .page.ts or .page.js, name your file proxy.page.ts or proxy.page.js accordingly.

The file must export a single function, either as a default export or named proxy. Note that multiple proxy from the same file are not supported.

Optionally, a config object can be exported alongside the Proxy function. This object includes the matcher to specify paths where the Proxy applies.

The matcher option allows you to target specific paths for the Proxy to run on. You can specify these paths in several ways:

Additionally, the matcher option supports complex path specifications using regular expressions. For example, you can exclude certain paths with a regular expression matcher:

This enables precise control over which paths to include or exclude.

The matcher option accepts an array of objects with the following keys:

Read more details on path-to-regexp documentation.

When defining Proxy, the default export function accepts a single parameter, request. This parameter is an instance of NextRequest, which represents the incoming HTTP request.

The NextResponse API allows you to:

To produce a response from Proxy, you can:

Good to know: For redirects, you can also use Response.redirect instead of NextResponse.redirect.

Proxy will be invoked for every route in your project. Given this, it's crucial to use matchers to precisely target or exclude specific routes. The following is the execution order:

Proxy defaults to using the Node.js runtime. The runtime config option is not available in Proxy files. Setting the runtime config option in Proxy will throw an error.

In v13.1 of Next.js two additional flags were introduced for proxy, skipMiddlewareUrlNormalize and skipTrailingSlashRedirect to handle advanced use cases.

skipTrailingSlashRedirect disables Next.js redirects for adding or removing trailing slashes. This allows custom handling inside proxy to maintain the trailing slash for some paths but not others, which can make incremental migrations easier.

skipMiddlewareUrlNormalize allows for disabling the URL normalization in Next.js to make handling direct visits and client-transitions the same. In some advanced cases, this option provides full control by using the original URL.

Cookies are regular headers. On a Request, they are stored in the Cookie header. On a Response they are in the Set-Cookie header. Next.js provides a convenient way to access and manipulate these cookies through the cookies extension on NextRequest and NextResponse.

You can set request and response headers using the NextResponse API (setting request headers is available since Next.js v13.0.0).

Note that the snippet uses:

Learn more in NextResponse headers in Proxy.

Good to know: Avoid setting large headers as it might cause 431 Request Header Fields Too Large error depending on your backend web server configuration.

You can set CORS headers in Proxy to allow cross-origin requests, including simple and preflighted requests.

Good to know: You can configure CORS headers for individual routes in Route Handlers.

You can respond from Proxy directly by returning a Response or NextResponse instance. (This is available since Next.js v13.1.0)

The matcher config allows full regex so matching like negative lookaheads or character matching is supported. An example of a negative lookahead to match all except specific paths can be seen here:

You can also bypass Proxy for certain requests by using the missing or has arrays, or a combination of both:

Even when _next/data is excluded in a negative matcher pattern, proxy will still be invoked for _next/data routes. This is intentional behavior to prevent accidental security issues where you might protect a page but forget to protect the corresponding data route.

The NextFetchEvent object extends the native FetchEvent object, and includes the waitUntil() method.

The waitUntil() method takes a promise as an argument, and extends the lifetime of the Proxy until the promise settles. This is useful for performing work in the background.

Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test proxy files. Unit testing proxy can help ensure that it's only run on desired paths and that custom routing logic works as intended before code reaches production.

The unstable_doesProxyMatch function can be used to assert whether proxy will run for the provided URL, headers, and cookies.

The entire proxy function can also be tested.

Learn how to configure Proxy when self-hosting Next.js.

The reason behind the renaming of middleware is that the term "middleware" can often be confused with Express.js middleware, leading to a misinterpretation of its purpose. Also, Middleware is highly capable, so it may encourage the usage; however, this feature is recommended to be used as a last resort.

Next.js is moving forward to provide better APIs with better ergonomics so that developers can achieve their goals without Middleware. This is the reason behind the renaming of middleware.

The name Proxy clarifies what Middleware is capable of. The term "proxy" implies that it has a network boundary in front of the app, which is the behavior of Middleware. Also, Middleware defaults to run at the Edge Runtime, which can run closer to the client, separated from the app's region. These behaviors align better with the term "proxy" and provide a clearer purpose of the feature.

We recommend users avoid relying on Middleware unless no other options exist. Our goal is to give them APIs with better ergonomics so they can achieve their goals without Middleware.

The term â€œmiddlewareâ€ often confuses users with Express.js middleware, which can encourage misuse. To clarify our direction, we are renaming the file convention to â€œproxy.â€ This highlights that we are moving away from Middleware, breaking down its overloaded features, and making the Proxy clear in its purpose.

Next.js provides a codemod to migrate from middleware.ts to proxy.ts. You can run the following command to migrate:

The codemod will rename the file and the function name from middleware to proxy.

**Examples:**

Example 1 (python):
```python
import { NextResponse, NextRequest } from 'next/server'
 
// This function can be marked `async` if using `await` inside
export function proxy(request: NextRequest) {
  return NextResponse.redirect(new URL('/home', request.url))
}
 
export const config = {
  matcher: '/about/:path*',
}
```

Example 2 (unknown):
```unknown
// Example of default export
export default function proxy(request) {
  // Proxy logic
}
```

Example 3 (javascript):
```javascript
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
}
```

Example 4 (javascript):
```javascript
export const config = {
  matcher: [
    // Exclude API routes, static files, image optimizations, and .png files
    '/((?!api|_next/static|_next/image|.*\\.png$).*)',
  ],
}
```

---

## How to build micro-frontends using multi-zones and Next.js

**URL:** https://nextjs.org/docs/pages/guides/multi-zones

**Contents:**
- How to build micro-frontends using multi-zones and Next.js
- How to define a zone
- How to route requests to the right zone
  - Routing requests using proxy
- Linking between zones
- Sharing code

Multi-Zones are an approach to micro-frontends that separate a large application on a domain into smaller Next.js applications that each serve a set of paths. This is useful when there are collections of pages unrelated to the other pages in the application. By moving those pages to a separate zone (i.e., a separate application), you can reduce the size of each application which improves build times and removes code that is only necessary for one of the zones. Since applications are decoupled, Multi-Zones also allows other applications on the domain to use their own choice of framework.

For example, let's say you have the following set of pages that you would like to split up:

With Multi-Zones support, you can create three applications that all are served on the same domain and look the same to the user, but you can develop and deploy each of the applications independently.

Navigating between pages in the same zone will perform soft navigations, a navigation that does not require reloading the page. For example, in this diagram, navigating from / to /products will be a soft navigation.

Navigating from a page in one zone to a page in another zone, such as from / to /dashboard, will perform a hard navigation, unloading the resources of the current page and loading the resources of the new page. Pages that are frequently visited together should live in the same zone to avoid hard navigations.

A zone is a normal Next.js application where you also configure an assetPrefix to avoid conflicts with pages and static files in other zones.

Next.js assets, such as JavaScript and CSS, will be prefixed with assetPrefix to make sure that they don't conflict with assets from other zones. These assets will be served under /assetPrefix/_next/... for each of the zones.

The default application handling all paths not routed to another more specific zone does not need an assetPrefix.

In versions older than Next.js 15, you may also need an additional rewrite to handle the static assets. This is no longer necessary in Next.js 15.

With the Multi Zones set-up, you need to route the paths to the correct zone since they are served by different applications. You can use any HTTP proxy to do this, but one of the Next.js applications can also be used to route requests for the entire domain.

To route to the correct zone using a Next.js application, you can use rewrites. For each path served by a different zone, you would add a rewrite rule to send that path to the domain of the other zone, and you also need to rewrite the requests for the static assets. For example:

destination should be a URL that is served by the zone, including scheme and domain. This should point to the zone's production domain, but it can also be used to route requests to localhost in local development.

Good to know: URL paths should be unique to a zone. For example, two zones trying to serve /blog would create a routing conflict.

Routing requests through rewrites is recommended to minimize latency overhead for the requests, but proxy can also be used when there is a need for a dynamic decision when routing. For example, if you are using a feature flag to decide where a path should be routed such as during a migration, you can use proxy.

Links to paths in a different zone should use an a tag instead of the Next.js <Link> component. This is because Next.js will try to prefetch and soft navigate to any relative path in <Link> component, which will not work across zones.

The Next.js applications that make up the different zones can live in any repository. However, it is often convenient to put these zones in a monorepo to more easily share code. For zones that live in different repositories, code can also be shared using public or private NPM packages.

Since the pages in different zones may be released at different times, feature flags can be useful for enabling or disabling features in unison across the different zones.

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  assetPrefix: '/blog-static',
}
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  assetPrefix: '/blog-static',
  async rewrites() {
    return {
      beforeFiles: [
        {
          source: '/blog-static/_next/:path+',
          destination: '/_next/:path+',
        },
      ],
    }
  },
}
```

Example 3 (unknown):
```unknown
async rewrites() {
    return [
        {
            source: '/blog',
            destination: `${process.env.BLOG_DOMAIN}/blog`,
        },
        {
            source: '/blog/:path+',
            destination: `${process.env.BLOG_DOMAIN}/blog/:path+`,
        },
        {
            source: '/blog-static/:path+',
            destination: `${process.env.BLOG_DOMAIN}/blog-static/:path+`,
        }
    ];
}
```

Example 4 (javascript):
```javascript
export async function proxy(request) {
  const { pathname, search } = req.nextUrl;
  if (pathname === '/your-path' && myFeatureFlag.isEnabled()) {
    return NextResponse.rewrite(`${rewriteDomain}${pathname}${search});
  }
}
```

---

## How to build single-page applications with Next.js

**URL:** https://nextjs.org/docs/app/guides/single-page-applications

**Contents:**
- How to build single-page applications with Next.js
- What is a Single-Page Application?
- Why use Next.js for SPAs?
- Examples
  - Using Reactâ€™s use within a Context Provider
  - SPAs with SWR
  - SPAs with React Query
  - Rendering components only in the browser
  - Shallow routing on the client
  - Using Server Actions in Client Components

Next.js fully supports building Single-Page Applications (SPAs).

This includes fast route transitions with prefetching, client-side data fetching, using browser APIs, integrating with third-party client libraries, creating static routes, and more.

If you have an existing SPA, you can migrate to Next.js without large changes to your code. Next.js then allows you to progressively add server features as needed.

The definition of a SPA varies. Weâ€™ll define a â€œstrict SPAâ€ as:

Strict SPAs often require large amounts of JavaScript to load before the page can be interactive. Further, client data waterfalls can be challenging to manage. Building SPAs with Next.js can address these issues.

Next.js can automatically code split your JavaScript bundles, and generate multiple HTML entry points into different routes. This avoids loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.

The next/link component automatically prefetches routes, giving you the fast page transitions of a strict SPA, but with the advantage of persisting application routing state to the URL for linking and sharing.

Next.js can start as a static site or even a strict SPA where everything is rendered client-side. If your project grows, Next.js allows you to progressively add more server features (e.g. React Server Components, Server Actions, and more) as needed.

Let's explore common patterns used to build SPAs and how Next.js solves them.

We recommend fetching data in a parent component (or layout), returning the Promise, and then unwrapping the value in a Client Component with Reactâ€™s use hook.

Next.js can start data fetching early on the server. In this example, thatâ€™s the root layout â€” the entry point to your application. The server can immediately begin streaming a response to the client.

By â€œhoistingâ€ your data fetching to the root layout, Next.js starts the specified requests on the server early before any other components in your application. This eliminates client waterfalls and prevents having multiple roundtrips between client and server. It can also significantly improve performance, as your server is closer (and ideally colocated) to where your database is located.

For example, update your root layout to call the Promise, but do not await it.

While you can defer and pass a single Promise as a prop to a Client Component, we generally see this pattern paired with a React context provider. This enables easier access from Client Components with a custom React Hook.

You can forward a Promise to the React context provider:

Finally, you can call the useUser() custom hook in any Client Component and unwrap the Promise:

The component that consumes the Promise (e.g. Profile above) will be suspended. This enables partial hydration. You can see the streamed and prerendered HTML before JavaScript has finished loading.

SWR is a popular React library for data fetching.

With SWR 2.3.0 (and React 19+), you can gradually adopt server features alongside your existing SWR-based client data fetching code. This is an abstraction of the above use() pattern. This means you can move data fetching between the client and server-side, or use both:

For example, wrap your application with <SWRConfig> and a fallback:

Because this is a Server Component, getUser() can securely read cookies, headers, or talk to your database. No separate API route is needed. Client components below the <SWRConfig> can call useSWR() with the same key to retrieve the user data. The component code with useSWR does not require any changes from your existing client-fetching solution.

The fallback data can be prerendered and included in the initial HTML response, then immediately read in the child components using useSWR. SWRâ€™s polling, revalidation, and caching still run client-side only, so it preserves all the interactivity you rely on for an SPA.

Since the initial fallback data is automatically handled by Next.js, you can now delete any conditional logic previously needed to check if data was undefined. When the data is loading, the closest <Suspense> boundary will be suspended.

You can use React Query with Next.js on both the client and server. This enables you to build both strict SPAs, as well as take advantage of server features in Next.js paired with React Query.

Learn more in the React Query documentation.

Client components are prerendered during next build. If you want to disable prerendering for a Client Component and only load it in the browser environment, you can use next/dynamic:

This can be useful for third-party libraries that rely on browser APIs like window or document. You can also add a useEffect that checks for the existence of these APIs, and if they do not exist, return null or a loading state which would be prerendered.

If you are migrating from a strict SPA like Create React App or Vite, you might have existing code which shallow routes to update the URL state. This can be useful for manual transitions between views in your application without using the default Next.js file-system routing.

Next.js allows you to use the native window.history.pushState and window.history.replaceState methods to update the browser's history stack without reloading the page.

pushState and replaceState calls integrate into the Next.js Router, allowing you to sync with usePathname and useSearchParams.

Learn more about how routing and navigation work in Next.js.

You can progressively adopt Server Actions while still using Client Components. This allows you to remove boilerplate code to call an API route, and instead use React features like useActionState to handle loading and error states.

For example, create your first Server Action:

You can import and use a Server Action from the client, similar to calling a JavaScript function. You do not need to create an API endpoint manually:

Learn more about mutating data with Server Actions.

Next.js also supports generating a fully static site. This has some advantages over strict SPAs:

To enable a static export, update your configuration:

After running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application.

Note: Next.js server features are not supported with static exports. Learn more.

You can incrementally migrate to Next.js by following our guides:

If you are already using a SPA with the Pages Router, you can learn how to incrementally adopt the App Router.

**Examples:**

Example 1 (python):
```python
import { UserProvider } from './user-provider'
import { getUser } from './user' // some server-side function
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  let userPromise = getUser() // do NOT await
 
  return (
    <html lang="en">
      <body>
        <UserProvider userPromise={userPromise}>{children}</UserProvider>
      </body>
    </html>
  )
}
```

Example 2 (python):
```python
'use client';
 
import { createContext, useContext, ReactNode } from 'react';
 
type User = any;
type UserContextType = {
  userPromise: Promise<User | null>;
};
 
const UserContext = createContext<UserContextType | null>(null);
 
export function useUser(): UserContextType {
  let context = useContext(UserContext);
  if (context === null) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}
 
export function UserProvider({
  children,
  userPromise
}: {
  children: ReactNode;
  userPromise: Promise<User | null>;
}) {
  return (
    <UserContext.Provider value={{ userPromise }}>
      {children}
    </UserContext.Provider>
  );
}
```

Example 3 (python):
```python
'use client'
 
import { use } from 'react'
import { useUser } from './user-provider'
 
export function Profile() {
  const { userPromise } = useUser()
  const user = use(userPromise)
 
  return '...'
}
```

Example 4 (python):
```python
import { SWRConfig } from 'swr'
import { getUser } from './user' // some server-side function
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <SWRConfig
      value={{
        fallback: {
          // We do NOT await getUser() here
          // Only components that read this data will suspend
          '/api/user': getUser(),
        },
      }}
    >
      {children}
    </SWRConfig>
  )
}
```

---

## Route Groups

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/route-groups

**Contents:**
- Route Groups
- Convention
- Use cases
- Caveats

Route Groups are a folder convention that let you organize routes by category or team.

A route group can be created by wrapping a folder's name in parenthesis: (folderName).

This convention indicates the folder is for organizational purposes and should not be included in the route's URL path.

---

## cacheTag

**URL:** https://nextjs.org/docs/app/api-reference/functions/cacheTag

**Contents:**
- cacheTag
- Usage
- Good to know
- Examples
  - Tagging components or functions
  - Creating tags from external data
  - Invalidating tagged cache
- Related
  - cacheComponents
  - use cache

The cacheTag function allows you to tag cached data for on-demand invalidation. By associating tags with cache entries, you can selectively purge or revalidate specific cache entries without affecting other cached data.

To use cacheTag, enable the cacheComponents flag in your next.config.js file:

The cacheTag function takes one or more string values.

You can then purge the cache on-demand using revalidateTag API in another function, for example, a route handler or Server Action:

Tag your cached data by calling cacheTag within a cached function or component:

You can use the data returned from an async function to tag the cache entry.

Using revalidateTag, you can invalidate the cache for a specific tag when needed:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  cacheComponents: true,
}
 
export default nextConfig
```

Example 2 (python):
```python
import { cacheTag } from 'next/cache'
 
export async function getData() {
  'use cache'
  cacheTag('my-data')
  const data = await fetch('/api/data')
  return data
}
```

Example 3 (python):
```python
'use server'
 
import { revalidateTag } from 'next/cache'
 
export default async function submit() {
  await addPost()
  revalidateTag('my-data')
}
```

Example 4 (unknown):
```unknown
cacheTag('tag-one', 'tag-two')
```

---

## Edge Runtime

**URL:** https://nextjs.org/docs/15/app/api-reference/edge

**Contents:**
- Edge Runtime
- Caveats
- Reference
  - Network APIs
  - Encoding APIs
  - Stream APIs
  - Crypto APIs
  - Web Standard APIs
  - Next.js Specific Polyfills
  - Environment Variables

Next.js has two server runtimes you can use in your application:

The Edge Runtime supports the following APIs:

You can use process.env to access Environment Variables for both next dev and next build.

The Edge Runtime has some restrictions including:

The following JavaScript language features are disabled, and will not work:

In rare cases, your code could contain (or import) some dynamic code evaluation statements which can not be reached at runtime and which can not be removed by treeshaking. You can relax the check to allow specific files with your Middleware configuration:

unstable_allowDynamic is a glob, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to your application root folder.

Be warned that if these statements are executed on the Edge, they will throw and cause a runtime error.

**Examples:**

Example 1 (javascript):
```javascript
export const config = {
  unstable_allowDynamic: [
    // allows a single file
    '/lib/utilities.js',
    // use a glob to allow anything in the function-bind 3rd party module
    '**/node_modules/function-bind/**',
  ],
}
```

---

## Codemods

**URL:** https://nextjs.org/docs/pages/guides/upgrading/codemods

**Contents:**
- Codemods
- Usage
- Codemods
  - 16.0
    - Remove experimental_ppr Route Segment Config from App Router pages and layouts
      - remove-experimental-ppr
    - Remove unstable_ prefix from stabilized API
      - remove-unstable-prefix
    - Migrate from deprecated middleware convention to proxy
      - middleware-to-proxy

Codemods are transformations that run on your codebase programmatically. This allows a large number of changes to be programmatically applied without having to manually go through every file.

Next.js provides Codemod transformations to help upgrade your Next.js codebase when an API is updated or deprecated.

In your terminal, navigate (cd) into your project's folder, then run:

Replacing <transform> and <path> with appropriate values.

This codemod removes the experimental_ppr Route Segment Config from App Router pages and layouts.

This codemod removes the unstable_ prefix from stabilized API.

This codemod migrates projects from using the deprecated middleware convention to using the proxy convention. It:

This codemod migrates projects from using next lint to using the ESLint CLI with your local ESLint config. It:

Note: This codemod is App Router specific.

This codemod transforms Route Segment Config runtime value experimental-edge to edge.

APIs that opted into dynamic rendering that previously supported synchronous access are now asynchronous. You can read more about this breaking change in the upgrade guide.

This codemod will transform dynamic APIs (cookies(), headers() and draftMode() from next/headers) that are now asynchronous to be properly awaited or wrapped with React.use() if applicable. When an automatic migration isn't possible, the codemod will either add a typecast (if a TypeScript file) or a comment to inform the user that it needs to be manually reviewed & updated.

When we detect property access on the params or searchParams props in the page / route entries (page.js, layout.js, route.js, or default.js) or the generateMetadata / generateViewport APIs, it will attempt to transform the callsite from a sync to an async function, and await the property access. If it can't be made async (such as with a Client Component), it will use React.use to unwrap the promise .

Good to know: When this codemod identifies a spot that might require manual intervention, but we aren't able to determine the exact fix, it will add a comment or typecast to the code to inform the user that it needs to be manually updated. These comments are prefixed with @next/codemod, and typecasts are prefixed with UnsafeUnwrapped. Your build will error until these comments are explicitly removed. Read more.

This codemod installs @vercel/functions and transforms geo and ip properties of NextRequest with corresponding @vercel/functions features.

This codemod moves transforms imports from next/server to next/og for usage of Dynamic OG Image Generation.

This codemod migrates certain viewport metadata to viewport export.

This codemod uninstalls the @next/font package and transforms @next/font imports into the built-in next/font.

Safely renames next/image imports in existing Next.js 10, 11, or 12 applications to next/legacy/image in Next.js 13. Also renames next/future/image to next/image.

Dangerously migrates from next/legacy/image to the new next/image by adding inline styles and removing unused props.

Remove <a> tags inside Link Components.

Migrates a Create React App project to Next.js; creating a Pages Router and necessary config to match behavior. Client-side only rendering is leveraged initially to prevent breaking compatibility due to window usage during SSR and can be enabled seamlessly to allow the gradual adoption of Next.js specific features.

Please share any feedback related to this transform in this discussion.

Transforms files that do not import React to include the import in order for the new React JSX transform to work.

Versions 9 and above.

Transforms anonymous components into named components to make sure they work with Fast Refresh.

The component will have a camel-cased name based on the name of the file, and it also works with arrow functions.

Note: Built-in AMP support and this codemod have been removed in Next.js 16.

Transforms the withAmp HOC into Next.js 9 page configuration.

Transforms the deprecated automatically injected url property on top level pages to using withRouter and the router property it injects. Read more here: https://nextjs.org/docs/messages/url-deprecated

This is one case. All the cases that are transformed (and tested) can be found in the __testfixtures__ directory.

**Examples:**

Example 1 (unknown):
```unknown
npx @next/codemod <transform> <path>
```

Example 2 (unknown):
```unknown
npx @next/codemod@latest remove-experimental-ppr .
```

Example 3 (javascript):
```javascript
- export const experimental_ppr = true;
```

Example 4 (unknown):
```unknown
npx @next/codemod@latest remove-unstable-prefix .
```

---

## Functions

**URL:** https://nextjs.org/docs/app/api-reference/functions

**Contents:**
- Functions
  - after
  - cacheLife
  - cacheTag
  - connection
  - cookies
  - draftMode
  - fetch
  - forbidden
  - generateImageMetadata

---

## typedRoutes

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/typedRoutes

**Contents:**
- typedRoutes

Note: This option has been marked as stable, so you should use typedRoutes instead of experimental.typedRoutes.

Support for statically typed links. This feature requires using TypeScript in your project.

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  typedRoutes: true,
}
 
module.exports = nextConfig
```

---

## next.config.js Options

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js

**Contents:**
- next.config.js Options
- ECMAScript Modules
- Configuration as a Function
  - Async Configuration
  - Phase
- TypeScript
- Unit Testing (experimental)
  - experimental.adapterPath
  - allowedDevOrigins
  - assetPrefix

Next.js can be configured through a next.config.js file in the root of your project directory (for example, by package.json) with a default export.

next.config.js is a regular Node.js module, not a JSON file. It gets used by the Next.js server and build phases, and it's not included in the browser build.

If you need ECMAScript modules, you can use next.config.mjs:

Good to know: next.config with the .cjs or .cts extensions are currently not supported.

You can also use a function:

Since Next.js 12.1.0, you can use an async function:

phase is the current context in which the configuration is loaded. You can see the available phases. Phases can be imported from next/constants:

If you are using TypeScript in your project, you can use next.config.ts to use TypeScript in your configuration:

The commented lines are the place where you can put the configs allowed by next.config.js, which are defined in this file.

However, none of the configs are required, and it's not necessary to understand what each config does. Instead, search for the features you need to enable or modify in this section and they will show you what to do.

Avoid using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel.

This page documents all the available configuration options:

Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files.

The unstable_getResponseFromNextConfig function runs the headers, redirects, and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing.

The response from unstable_getResponseFromNextConfig only considers next.config.js fields and does not consider proxy or filesystem routes, so the result in production may be different than the unit test.

**Examples:**

Example 1 (javascript):
```javascript
// @ts-check
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
}
 
module.exports = nextConfig
```

Example 2 (javascript):
```javascript
// @ts-check
 
/**
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  /* config options here */
}
 
export default nextConfig
```

Example 3 (javascript):
```javascript
// @ts-check
 
export default (phase, { defaultConfig }) => {
  /**
   * @type {import('next').NextConfig}
   */
  const nextConfig = {
    /* config options here */
  }
  return nextConfig
}
```

Example 4 (javascript):
```javascript
// @ts-check
 
module.exports = async (phase, { defaultConfig }) => {
  /**
   * @type {import('next').NextConfig}
   */
  const nextConfig = {
    /* config options here */
  }
  return nextConfig
}
```

---

## How to handle redirects in Next.js

**URL:** https://nextjs.org/docs/app/guides/redirecting

**Contents:**
- How to handle redirects in Next.js
- redirect function
- permanentRedirect function
- useRouter() hook
- redirects in next.config.js
- NextResponse.redirect in Proxy
- Managing redirects at scale (advanced)
  - 1. Creating and storing a redirect map
  - 2. Optimizing data lookup performance
- Next Steps

There are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects.

The redirect function allows you to redirect the user to another URL. You can call redirect in Server Components, Route Handlers, and Server Actions.

redirect is often used after a mutation or event. For example, creating a post:

See the redirect API reference for more information.

The permanentRedirect function allows you to permanently redirect the user to another URL. You can call permanentRedirect in Server Components, Route Handlers, and Server Actions.

permanentRedirect is often used after a mutation or event that changes an entity's canonical URL, such as updating a user's profile URL after they change their username:

See the permanentRedirect API reference for more information.

If you need to redirect inside an event handler in a Client Component, you can use the push method from the useRouter hook. For example:

See the useRouter API reference for more information.

The redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time.

redirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request.

To use redirects, add the option to your next.config.js file:

See the redirects API reference for more information.

Proxy allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects.

For example, to redirect the user to a /login page if they are not authenticated:

See the Proxy documentation for more information.

To manage a large number of redirects (1000+), you may consider creating a custom solution using Proxy. This allows you to handle redirects programmatically without having to redeploy your application.

To do this, you'll need to consider:

Next.js Example: See our Proxy with Bloom filter example for an implementation of the recommendations below.

A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file.

Consider the following data structure:

In Proxy, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request:

Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance:

Considering the previous example, you can import a generated bloom filter file into Proxy, then, check if the incoming request pathname exists in the bloom filter.

If it does, forward the request to a Route Handler which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Proxy, which can slow down every incoming request.

Then, in the Route Handler:

**Examples:**

Example 1 (python):
```python
'use server'
 
import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'
 
export async function createPost(id: string) {
  try {
    // Call database
  } catch (error) {
    // Handle errors
  }
 
  revalidatePath('/posts') // Update cached posts
  redirect(`/post/${id}`) // Navigate to the new post page
}
```

Example 2 (python):
```python
'use server'
 
import { permanentRedirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'
 
export async function updateUsername(username: string, formData: FormData) {
  try {
    // Call database
  } catch (error) {
    // Handle errors
  }
 
  revalidateTag('username') // Update all references to the username
  permanentRedirect(`/profile/${username}`) // Navigate to the new user profile
}
```

Example 3 (python):
```python
'use client'
 
import { useRouter } from 'next/navigation'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

Example 4 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  async redirects() {
    return [
      // Basic redirect
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
      // Wildcard path matching
      {
        source: '/blog/:slug',
        destination: '/news/:slug',
        permanent: true,
      },
    ]
  },
}
 
export default nextConfig
```

---

## Migrating

**URL:** https://nextjs.org/docs/15/app/guides/migrating

**Contents:**
- Migrating
  - App Router
  - Create React App
  - Vite

---

## How to set a Content Security Policy (CSP) for your Next.js application

**URL:** https://nextjs.org/docs/app/guides/content-security-policy

**Contents:**
- How to set a Content Security Policy (CSP) for your Next.js application
- Nonces
  - Why use a nonce?
  - Adding a nonce with Proxy
  - How nonces work in Next.js
  - Forcing dynamic rendering
  - Reading the nonce
- Static vs Dynamic Rendering with CSP
  - Dynamic Rendering Requirement
  - Performance Implications

Content Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks.

By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more.

A nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives.

CSP can block both inline and external scripts to prevent attacks. A nonce lets you safely allow specific scripts to runâ€”only if they include the matching nonce value.

If an attacker wanted to load a script into your page, they'd need to guess the nonce value. That's why the nonce must be unpredictable and unique for every request.

Proxy enables you to add headers and generate nonces before the page renders.

Every time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces.

By default, Proxy runs on all requests. You can filter Proxy to run on specific paths using a matcher.

We recommend ignoring matching prefetches (from next/link) and static assets that don't need the CSP header.

To use a nonce, your page must be dynamically rendered. This is because Next.js applies nonces during server-side rendering, based on the CSP header present in the request. Static pages are generated at build time, when no request or response headers existâ€”so no nonce can be injected.

Hereâ€™s how nonce support works in a dynamically rendered page:

Because of this automatic behavior, you donâ€™t need to manually add a nonce to each tag.

If you're using nonces, you may need to explicitly opt pages into dynamic rendering:

You can read the nonce from a Server Component using headers:

Using nonces has important implications for how your Next.js application renders:

When you use nonces in your CSP, all pages must be dynamically rendered. This means:

The shift from static to dynamic rendering affects performance:

Consider nonces when:

For applications that do not require nonces, you can set the CSP header directly in your next.config.js file:

As an alternative to nonces, Next.js offers experimental support for hash-based CSP using Subresource Integrity (SRI). This approach allows you to maintain static generation while still having a strict CSP.

Good to know: This feature is experimental and only available with webpack bundler in App Router applications.

Instead of using nonces, SRI generates cryptographic hashes of your JavaScript files at build time. These hashes are added as integrity attributes to script tags, allowing browsers to verify that files haven't been modified during transit.

Add the experimental SRI configuration to your next.config.js:

When SRI is enabled, you can continue using your existing CSP policies. SRI works independently by adding integrity attributes to your assets:

Good to know: For dynamic rendering scenarios, you can still generate nonces with proxy if needed, combining both SRI integrity attributes and nonce-based CSP approaches.

CSP implementation differs between development and production environments:

In development, you will need to enable 'unsafe-eval' to support APIs that provide additional debugging information:

Common issues in production:

When using third-party scripts with CSP:

Update your CSP to allow third-party domains:

**Examples:**

Example 1 (python):
```python
import { NextRequest, NextResponse } from 'next/server'
 
export function proxy(request: NextRequest) {
  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')
  const cspHeader = `
    default-src 'self';
    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';
    style-src 'self' 'nonce-${nonce}';
    img-src 'self' blob: data:;
    font-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
`
  // Replace newline characters and spaces
  const contentSecurityPolicyHeaderValue = cspHeader
    .replace(/\s{2,}/g, ' ')
    .trim()
 
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-nonce', nonce)
 
  requestHeaders.set(
    'Content-Security-Policy',
    contentSecurityPolicyHeaderValue
  )
 
  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })
  response.headers.set(
    'Content-Security-Policy',
    contentSecurityPolicyHeaderValue
  )
 
  return response
}
```

Example 2 (javascript):
```javascript
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    {
      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',
      missing: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },
  ],
}
```

Example 3 (python):
```python
import { connection } from 'next/server'
 
export default async function Page() {
  // wait for an incoming request to render this page
  await connection()
  // Your page content
}
```

Example 4 (python):
```python
import { headers } from 'next/headers'
import Script from 'next/script'
 
export default async function Page() {
  const nonce = (await headers()).get('x-nonce')
 
  return (
    <Script
      src="https://www.googletagmanager.com/gtag/js"
      strategy="afterInteractive"
      nonce={nonce}
    />
  )
}
```

---

## How to use environment variables in Next.js

**URL:** https://nextjs.org/docs/pages/guides/environment-variables

**Contents:**
- How to use environment variables in Next.js
- Loading Environment Variables
  - Loading Environment Variables with @next/env
  - Referencing Other Variables
- Bundling Environment Variables for the Browser
  - Runtime Environment Variables
- Test Environment Variables
- Environment Variable Load Order
- Good to know
- Version History

Next.js comes with built-in support for environment variables, which allows you to do the following:

Warning: The default create-next-app template ensures all .env files are added to your .gitignore. You almost never want to commit these files to your repository.

Next.js has built-in support for loading environment variables from .env* files into process.env.

This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods and API routes.

For example, using getStaticProps:

If you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the @next/env package.

This package is used internally by Next.js to load environment variables from .env* files.

To use it, install the package and use the loadEnvConfig function to load the environment variables:

Then, you can import the configuration where needed. For example:

Next.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This allows you to reference other secrets. For example:

In the above example, process.env.TWITTER_URL would be set to https://x.com/nextjs.

Good to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \$.

Non-NEXT_PUBLIC_ environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment).

In order to make the value of an environment variable accessible in the browser, Next.js can "inline" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXT_PUBLIC_. For example:

This will tell Next.js to replace all references to process.env.NEXT_PUBLIC_ANALYTICS_ID in the Node.js environment with the value from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.

Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all NEXT_PUBLIC_ variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).

Note that dynamic lookups will not be inlined, such as:

Next.js can support both build time and runtime environment variables.

By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.

To read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router.

This allows you to use a singular Docker image that can be promoted through multiple environments with different values.

Apart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Next.js will not load environment variables from .env.development or .env.production in the testing environment.

This one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don't need to do this manually as testing tools will address it for you.

There is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set).

Good to know: similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env*.local are intended to be ignored through .gitignore.

While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the loadEnvConfig function from the @next/env package.

Environment variables are looked up in the following places, in order, stopping once the variable is found.

For example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used.

Good to know: The allowed values for NODE_ENV are production, development and test.

**Examples:**

Example 1 (unknown):
```unknown
DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
```

Example 2 (javascript):
```javascript
export async function getStaticProps() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
  })
  // ...
}
```

Example 3 (unknown):
```unknown
npm install @next/env
```

Example 4 (python):
```python
import { loadEnvConfig } from '@next/env'
 
const projectDir = process.cwd()
loadEnvConfig(projectDir)
```

---

## Codemods

**URL:** https://nextjs.org/docs/app/guides/upgrading/codemods

**Contents:**
- Codemods
- Usage
- Codemods
  - 16.0
    - Remove experimental_ppr Route Segment Config from App Router pages and layouts
      - remove-experimental-ppr
    - Remove unstable_ prefix from stabilized API
      - remove-unstable-prefix
    - Migrate from deprecated middleware convention to proxy
      - middleware-to-proxy

Codemods are transformations that run on your codebase programmatically. This allows a large number of changes to be programmatically applied without having to manually go through every file.

Next.js provides Codemod transformations to help upgrade your Next.js codebase when an API is updated or deprecated.

In your terminal, navigate (cd) into your project's folder, then run:

Replacing <transform> and <path> with appropriate values.

This codemod removes the experimental_ppr Route Segment Config from App Router pages and layouts.

This codemod removes the unstable_ prefix from stabilized API.

This codemod migrates projects from using the deprecated middleware convention to using the proxy convention. It:

This codemod migrates projects from using next lint to using the ESLint CLI with your local ESLint config. It:

Note: This codemod is App Router specific.

This codemod transforms Route Segment Config runtime value experimental-edge to edge.

APIs that opted into dynamic rendering that previously supported synchronous access are now asynchronous. You can read more about this breaking change in the upgrade guide.

This codemod will transform dynamic APIs (cookies(), headers() and draftMode() from next/headers) that are now asynchronous to be properly awaited or wrapped with React.use() if applicable. When an automatic migration isn't possible, the codemod will either add a typecast (if a TypeScript file) or a comment to inform the user that it needs to be manually reviewed & updated.

When we detect property access on the params or searchParams props in the page / route entries (page.js, layout.js, route.js, or default.js) or the generateMetadata / generateViewport APIs, it will attempt to transform the callsite from a sync to an async function, and await the property access. If it can't be made async (such as with a Client Component), it will use React.use to unwrap the promise .

Good to know: When this codemod identifies a spot that might require manual intervention, but we aren't able to determine the exact fix, it will add a comment or typecast to the code to inform the user that it needs to be manually updated. These comments are prefixed with @next/codemod, and typecasts are prefixed with UnsafeUnwrapped. Your build will error until these comments are explicitly removed. Read more.

This codemod installs @vercel/functions and transforms geo and ip properties of NextRequest with corresponding @vercel/functions features.

This codemod moves transforms imports from next/server to next/og for usage of Dynamic OG Image Generation.

This codemod migrates certain viewport metadata to viewport export.

This codemod uninstalls the @next/font package and transforms @next/font imports into the built-in next/font.

Safely renames next/image imports in existing Next.js 10, 11, or 12 applications to next/legacy/image in Next.js 13. Also renames next/future/image to next/image.

Dangerously migrates from next/legacy/image to the new next/image by adding inline styles and removing unused props.

Remove <a> tags inside Link Components.

Migrates a Create React App project to Next.js; creating a Pages Router and necessary config to match behavior. Client-side only rendering is leveraged initially to prevent breaking compatibility due to window usage during SSR and can be enabled seamlessly to allow the gradual adoption of Next.js specific features.

Please share any feedback related to this transform in this discussion.

Transforms files that do not import React to include the import in order for the new React JSX transform to work.

Versions 9 and above.

Transforms anonymous components into named components to make sure they work with Fast Refresh.

The component will have a camel-cased name based on the name of the file, and it also works with arrow functions.

Note: Built-in AMP support and this codemod have been removed in Next.js 16.

Transforms the withAmp HOC into Next.js 9 page configuration.

Transforms the deprecated automatically injected url property on top level pages to using withRouter and the router property it injects. Read more here: https://nextjs.org/docs/messages/url-deprecated

This is one case. All the cases that are transformed (and tested) can be found in the __testfixtures__ directory.

**Examples:**

Example 1 (unknown):
```unknown
npx @next/codemod <transform> <path>
```

Example 2 (unknown):
```unknown
npx @next/codemod@latest remove-experimental-ppr .
```

Example 3 (javascript):
```javascript
- export const experimental_ppr = true;
```

Example 4 (unknown):
```unknown
npx @next/codemod@latest remove-unstable-prefix .
```

---

## output

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/output

**Contents:**
- output
- How it Works
- Automatically Copying Traced Files
- Caveats

During a build, Next.js will automatically trace each page and its dependencies to determine all of the files that are needed for deploying a production version of your application.

This feature helps reduce the size of deployments drastically. Previously, when deploying with Docker you would need to have all files from your package's dependencies installed to run next start. Starting with Next.js 12, you can leverage Output File Tracing in the .next/ directory to only include the necessary files.

Furthermore, this removes the need for the deprecated serverless target which can cause various issues and also creates unnecessary duplication.

During next build, Next.js will use @vercel/nft to statically analyze import, require, and fs usage to determine all files that a page might load.

Next.js' production server is also traced for its needed files and output at .next/next-server.js.nft.json which can be leveraged in production.

To leverage the .nft.json files emitted to the .next output directory, you can read the list of files in each trace that are relative to the .nft.json file and then copy them to your deployment location.

Next.js can automatically create a standalone folder that copies only the necessary files for a production deployment including select files in node_modules.

To leverage this automatic copying you can enable it in your next.config.js:

This will create a folder at .next/standalone which can then be deployed on its own without installing node_modules.

Additionally, a minimal server.js file is also output which can be used instead of next start. This minimal server does not copy the public or .next/static folders by default as these should ideally be handled by a CDN instead, although these folders can be copied to the standalone/public and standalone/.next/static folders manually, after which server.js file will serve these automatically.

To copy these manually, you can use the cp command-line tool after you next build:

To start your minimal server.js file locally, run the following command:

Good to know: In a monorepo, project root refers to the Next.js project root (the folder containing next.config.js, e.g., packages/web-app), not necessarily the monorepo root.

Using a src/ directory does not change how you write these options:

You can also target all routes using a global key like '/*':

These options are applied to server traces and do not affect routes that do not produce a server trace file:

In monorepos or when you need to include files outside the app folder, combine outputFileTracingRoot with includes:

Common include patterns for native/runtime assets:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  output: 'standalone',
}
```

Example 2 (unknown):
```unknown
cp -r public .next/standalone/ && cp -r .next/static .next/standalone/.next/
```

Example 3 (unknown):
```unknown
node .next/standalone/server.js
```

Example 4 (javascript):
```javascript
const path = require('path')
 
module.exports = {
  // this includes files from the monorepo base two directories up
  outputFileTracingRoot: path.join(__dirname, '../../'),
}
```

---

## cacheLife

**URL:** https://nextjs.org/docs/app/api-reference/functions/cacheLife

**Contents:**
- cacheLife
- Usage
  - Basic setup
  - Using preset profiles
- Reference
  - Cache profile properties
    - stale
    - revalidate
    - expire
  - Preset cache profiles

The cacheLife function is used to set the cache lifetime of a function or component. It should be used alongside the use cache directive, and within the scope of the function or component.

To use cacheLife, first enable the cacheComponents flag in your next.config.js file:

Next.js provides preset cache profiles that cover common caching needs. Each profile balances three factors:

Choose a profile based on how frequently your content changes:

Import cacheLife and pass a profile name:

The profile name tells Next.js how to cache the entire function's output. If you need more control over timing values, see the Reference section below.

Good to know: The use cache directive can be placed at the file level or at the top of a function or component, and cacheLife must be called within its scope.

Cache profiles control caching behavior through three timing properties:

Client-side: How long the client can use cached data without checking the server.

During this time, the client-side router displays cached content immediately without any network request. After this period expires, the router must check with the server on the next navigation or request. This provides instant page loads from the client cache, but data may be outdated.

How often the server regenerates cached content in the background.

Maximum time before the server must regenerate cached content.

If you don't specify a profile, Next.js uses the default profile. We recommend explicitly setting a profile to make caching behavior clear.

Define reusable cache profiles in your next.config.ts file:

The example above caches for 14 days, checks for updates daily, and expires the cache after 14 days. You can then reference this profile throughout your application by its name:

While the default cache profiles provide a useful way to think about how fresh or stale any given part of cacheable output can be, you may prefer different named profiles to better align with your applications caching strategies.

You can override the default named cache profiles by creating a new configuration with the same name as the defaults.

The example below shows how to override the default "days" cache profile:

You can also override the preset profiles by using the same name:

For one-off cases, pass a profile object directly to cacheLife:

Inline profiles apply only to the specific function or component. For reusable configurations, define custom profiles in next.config.ts.

Using cacheLife({}) with an empty object applies the default profile values.

The stale property controls the client-side router cache, not the Cache-Control header:

This 30-second minimum prevents prefetched data from expiring before users can click on links. It only applies to time-based expiration.

When you call revalidation functions from a Server Action (revalidateTag, revalidatePath, updateTag, or refresh), the entire client cache is immediately cleared, bypassing the stale time.

Good to know: The stale property in cacheLife differs from staleTimes. While staleTimes is a global setting affecting all routes, cacheLife allows per-function or per-route configuration. Updating staleTimes.static also updates the stale value of the default cache profile.

The simplest way to configure caching is using preset profiles. Choose one that matches your content's update pattern:

Define custom profiles when preset options don't match your requirements:

Then use these profiles throughout your application:

Use inline profiles when a specific function needs one-off caching behavior:

Apply caching to utility functions for granular control:

When components with different cache profiles are nested, Next.js respects the shortest duration among them:

In this example, the outer Dashboard component specifies the hours profile, but it contains RealtimeWidget which uses the seconds profile. The shortest duration from the nested profiles takes precedence, ensuring the widget gets fresh data while the rest of the dashboard can be cached longer.

Good to know: This shortest-duration behavior ensures that no part of your page serves stale data longer than its most frequently updated component requires.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  cacheComponents: true,
}
 
export default nextConfig
```

Example 2 (python):
```python
'use cache'
import { cacheLife } from 'next/cache'
 
export default async function BlogPage() {
  cacheLife('days') // Blog content updated daily
 
  const posts = await getBlogPosts()
  return <div>{/* render posts */}</div>
}
```

Example 3 (unknown):
```unknown
cacheLife({ stale: 300 }) // 5 minutes
```

Example 4 (unknown):
```unknown
cacheLife({ revalidate: 900 }) // 15 minutes
```

---

## Configuration

**URL:** https://nextjs.org/docs/pages/api-reference/config

**Contents:**
- Configuration
  - next.config.js Options
  - TypeScript
  - ESLint

---

## How to set up Vitest with Next.js

**URL:** https://nextjs.org/docs/app/guides/testing/vitest

**Contents:**
- How to set up Vitest with Next.js
- Quickstart
- Manual Setup
- Creating your first Vitest Unit Test
- Running your tests
- Additional Resources

Vitest and React Testing Library are frequently used together for Unit Testing. This guide will show you how to setup Vitest with Next.js and write your first tests.

Good to know: Since async Server Components are new to the React ecosystem, Vitest currently does not support them. While you can still run unit tests for synchronous Server and Client Components, we recommend using E2E tests for async components.

You can use create-next-app with the Next.js with-vitest example to quickly get started:

To manually set up Vitest, install vitest and the following packages as dev dependencies:

Create a vitest.config.mts|js file in the root of your project, and add the following options:

For more information on configuring Vitest, please refer to the Vitest Configuration docs.

Then, add a test script to your package.json:

When you run npm run test, Vitest will watch for changes in your project by default.

Check that everything is working by creating a test to check if the <Page /> component successfully renders a heading:

Good to know: The example above uses the common __tests__ convention, but test files can also be colocated inside the app router.

Then, run the following command to run your tests:

You may find these resources helpful:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --example with-vitest with-vitest-app
```

Example 2 (unknown):
```unknown
# Using TypeScript
npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths
# Using JavaScript
npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom
```

Example 3 (python):
```python
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import tsconfigPaths from 'vite-tsconfig-paths'
 
export default defineConfig({
  plugins: [tsconfigPaths(), react()],
  test: {
    environment: 'jsdom',
  },
})
```

Example 4 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "test": "vitest"
  }
}
```

---

## How to implement JSON-LD in your Next.js application

**URL:** https://nextjs.org/docs/app/guides/json-ld

**Contents:**
- How to implement JSON-LD in your Next.js application

JSON-LD is a format for structured data that can be used by search engines and AI to help them understand the structure of the page beyond pure content. For example, you can use it to describe a person, an event, an organization, a movie, a book, a recipe, and many other types of entities.

Our current recommendation for JSON-LD is to render structured data as a <script> tag in your layout.js or page.js components.

The following snippet uses JSON.stringify, which does not sanitize malicious strings used in XSS injection. To prevent this type of vulnerability, you can scrub HTML tags from the JSON-LD payload, for example, by replacing the character, <, with its unicode equivalent, \u003c.

Review your organization's recommended approach to sanitize potentially dangerous strings, or use community maintained alternatives for JSON.stringify such as, serialize-javascript.

You can validate and test your structured data with the Rich Results Test for Google or the generic Schema Markup Validator.

You can type your JSON-LD with TypeScript using community packages like schema-dts:

**Examples:**

Example 1 (javascript):
```javascript
export default async function Page({ params }) {
  const { id } = await params
  const product = await getProduct(id)
 
  const jsonLd = {
    '@context': 'https://schema.org',
    '@type': 'Product',
    name: product.name,
    image: product.image,
    description: product.description,
  }
 
  return (
    <section>
      {/* Add JSON-LD to your page */}
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify(jsonLd).replace(/</g, '\\u003c'),
        }}
      />
      {/* ... */}
    </section>
  )
}
```

Example 2 (python):
```python
import { Product, WithContext } from 'schema-dts'
 
const jsonLd: WithContext<Product> = {
  '@context': 'https://schema.org',
  '@type': 'Product',
  name: 'Next.js Sticker',
  image: 'https://nextjs.org/imgs/sticker.png',
  description: 'Dynamic at the speed of static.',
}
```

---

## rewrites

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/rewrites

**Contents:**
- rewrites
- Rewrite parameters
- Path Matching
  - Wildcard Path Matching
  - Regex Path Matching
- Header, Cookie, and Query Matching
- Rewriting to an external URL
  - Incremental adoption of Next.js
  - Rewrites with basePath support
- Version History

Rewrites allow you to map an incoming request path to a different destination path.

Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast, redirects will reroute to a new page and show the URL changes.

To use rewrites you can use the rewrites key in next.config.js:

Rewrites are applied to client-side routing. In the example above, navigating to <Link href="/about"> will serve content from / while keeping the URL as /about.

rewrites is an async function that expects to return either an array or an object of arrays (see below) holding objects with source and destination properties:

When the rewrites function returns an array, rewrites are applied after checking the filesystem (pages and /public files) and before dynamic routes. When the rewrites function returns an object of arrays with a specific shape, this behavior can be changed and more finely controlled, as of v10.1 of Next.js:

Good to know: rewrites in beforeFiles do not check the filesystem/dynamic routes immediately after matching a source, they continue until all beforeFiles have been checked.

The order Next.js routes are checked is:

When using parameters in a rewrite the parameters will be passed in the query by default when none of the parameters are used in the destination.

If a parameter is used in the destination none of the parameters will be automatically passed in the query.

You can still pass the parameters manually in the query if one is already used in the destination by specifying the query in the destination.

Good to know: Static pages from Automatic Static Optimization or prerendering params from rewrites will be parsed on the client after hydration and provided in the query.

Path matches are allowed, for example /blog/:slug will match /blog/first-post (no nested paths):

The pattern /blog/:slug matches /blog/first-post and /blog/post-1 but not /blog/a/b (no nested paths). Patterns are anchored to the start: /blog/:slug will not match /archive/blog/first-post.

You can use modifiers on parameters: * (zero or more), + (one or more), ? (zero or one). For example, /blog/:slug* matches /blog, /blog/a, and /blog/a/b/c.

Read more details on path-to-regexp documentation.

To match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:

To match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\d{1,}) will match /blog/123 but not /blog/abc:

The following characters (, ), {, }, [, ], |, \, ^, ., :, *, +, -, ?, $ are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\ before them:

To only match a rewrite when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the rewrite to be applied.

has and missing items can have the following fields:

Rewrites allow you to rewrite to an external URL. This is especially useful for incrementally adopting Next.js. The following is an example rewrite for redirecting the /blog route of your main app to an external site.

If you're using trailingSlash: true, you also need to insert a trailing slash in the source parameter. If the destination server is also expecting a trailing slash it should be included in the destination parameter as well.

You can also have Next.js fall back to proxying to an existing website after checking all Next.js routes.

This way you don't have to change the rewrites configuration when migrating more pages to Next.js

When leveraging basePath support with rewrites each source and destination is automatically prefixed with the basePath unless you add basePath: false to the rewrite:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  async rewrites() {
    return [
      {
        source: '/about',
        destination: '/',
      },
    ]
  },
}
```

Example 2 (unknown):
```unknown
module.exports = {
  async rewrites() {
    return {
      beforeFiles: [
        // These rewrites are checked after headers/redirects
        // and before all files including _next/public files which
        // allows overriding page files
        {
          source: '/some-page',
          destination: '/somewhere-else',
          has: [{ type: 'query', key: 'overrideMe' }],
        },
      ],
      afterFiles: [
        // These rewrites are checked after pages/public files
        // are checked but before dynamic routes
        {
          source: '/non-existent',
          destination: '/somewhere-else',
        },
      ],
      fallback: [
        // These rewrites are checked after both pages/public files
        // and dynamic routes are checked
        {
          source: '/:path*',
          destination: `https://my-old-site.com/:path*`,
        },
      ],
    }
  },
}
```

Example 3 (unknown):
```unknown
module.exports = {
  async rewrites() {
    return [
      {
        source: '/old-about/:path*',
        destination: '/about', // The :path parameter isn't used here so will be automatically passed in the query
      },
    ]
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  async rewrites() {
    return [
      {
        source: '/docs/:path*',
        destination: '/:path*', // The :path parameter is used here so will not be automatically passed in the query
      },
    ]
  },
}
```

---

## inlineCss

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/inlineCss

**Contents:**
- inlineCss
- Usage
- Trade-Offs
  - When to Use Inline CSS
  - When Not to Use Inline CSS

Experimental support for inlining CSS in the <head>. When this flag is enabled, all places where we normally generate a <link> tag will instead have a generated <style> tag.

Inlining CSS can be beneficial in several scenarios:

First-Time Visitors: Since CSS files are render-blocking resources, inlining eliminates the initial download delay that first-time visitors experience, improving page load performance.

Performance Metrics: By removing the additional network requests for CSS files, inlining can significantly improve key metrics like First Contentful Paint (FCP) and Largest Contentful Paint (LCP).

Slow Connections: For users on slower networks where each request adds considerable latency, inlining CSS can provide a noticeable performance boost by reducing network roundtrips.

Atomic CSS Bundles (e.g., Tailwind): With utility-first frameworks like Tailwind CSS, the size of the styles required for a page is often O(1) relative to the complexity of the design. This makes inlining a compelling choice because the entire set of styles for the current page is lightweight and doesnâ€™t grow with the page size. Inlining Tailwind styles ensures minimal payload and eliminates the need for additional network requests, which can further enhance performance.

While inlining CSS offers significant benefits for performance, there are scenarios where it may not be the best choice:

Large CSS Bundles: If your CSS bundle is too large, inlining it may significantly increase the size of the HTML, resulting in slower Time to First Byte (TTFB) and potentially worse performance for users with slow connections.

Dynamic or Page-Specific CSS: For applications with highly dynamic styles or pages that use different sets of CSS, inlining may lead to redundancy and bloat, as the full CSS for all pages may need to be inlined repeatedly.

Browser Caching: In cases where visitors frequently return to your site, external CSS files allow browsers to cache styles efficiently, reducing data transfer for subsequent visits. Inlining CSS eliminates this benefit.

Evaluate these trade-offs carefully, and consider combining inlining with other strategies, such as critical CSS extraction or a hybrid approach, for the best results tailored to your site's needs.

This feature is currently experimental and has some known limitations:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    inlineCss: true,
  },
}
 
export default nextConfig
```

---

## How to lazy load Client Components and libraries

**URL:** https://nextjs.org/docs/pages/guides/lazy-loading

**Contents:**
- How to lazy load Client Components and libraries
- next/dynamic
- Examples
  - With named exports
  - With no SSR
  - With external libraries

Lazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route.

next/dynamic is a composite of React.lazy() and Suspense. It behaves the same way in the app and pages directories to allow for incremental migration.

In the example below, by using next/dynamic, the header component will not be included in the page's initial JavaScript bundle. The page will render the Suspense fallback first, followed by the Header component when the Suspense boundary is resolved.

Good to know: In import('path/to/component'), the path must be explicitly written. It can't be a template string nor a variable. Furthermore the import() has to be inside the dynamic() call for Next.js to be able to match webpack bundles / module ids to the specific dynamic() call and preload them before rendering. dynamic() can't be used inside of React rendering as it needs to be marked in the top level of the module for preloading to work, similar to React.lazy.

To dynamically import a named export, you can return it from the Promise returned by import():

To dynamically load a component on the client side, you can use the ssr option to disable server-rendering. This is useful if an external dependency or component relies on browser APIs like window.

This example uses the external library fuse.js for fuzzy search. The module is only loaded in the browser after the user types in the search input.

**Examples:**

Example 1 (python):
```python
import dynamic from 'next/dynamic'
 
const DynamicHeader = dynamic(() => import('../components/header'), {
  loading: () => <p>Loading...</p>,
})
 
export default function Home() {
  return <DynamicHeader />
}
```

Example 2 (python):
```python
export function Hello() {
  return <p>Hello!</p>
}
 
// pages/index.js
import dynamic from 'next/dynamic'
 
const DynamicComponent = dynamic(() =>
  import('../components/hello').then((mod) => mod.Hello)
)
```

Example 3 (python):
```python
'use client'
 
import dynamic from 'next/dynamic'
 
const DynamicHeader = dynamic(() => import('../components/header'), {
  ssr: false,
})
```

Example 4 (python):
```python
import { useState } from 'react'
 
const names = ['Tim', 'Joe', 'Bel', 'Lee']
 
export default function Page() {
  const [results, setResults] = useState()
 
  return (
    <div>
      <input
        type="text"
        placeholder="Search"
        onChange={async (e) => {
          const { value } = e.currentTarget
          // Dynamically load fuse.js
          const Fuse = (await import('fuse.js')).default
          const fuse = new Fuse(names)
 
          setResults(fuse.search(value))
        }}
      />
      <pre>Results: {JSON.stringify(results, null, 2)}</pre>
    </div>
  )
}
```

---

## useRouter

**URL:** https://nextjs.org/docs/pages/api-reference/functions/use-router

**Contents:**
- useRouter
- router object
  - router.push
    - Resetting state after navigation
    - With URL object
  - router.replace
  - router.prefetch
  - router.beforePopState
  - router.back
  - router.reload

If you want to access the router object inside any function component in your app, you can use the useRouter hook, take a look at the following example:

useRouter is a React Hook, meaning it cannot be used with classes. You can either use withRouter or wrap your class in a function component.

The following is the definition of the router object returned by both useRouter and withRouter:

Using the asPath field may lead to a mismatch between client and server if the page is rendered using server-side rendering or automatic static optimization. Avoid using asPath until the isReady field is true.

The following methods are included inside router:

Handles client-side transitions, this method is useful for cases where next/link is not enough.

You don't need to use router.push for external URLs. window.location is better suited for those cases.

Navigating to pages/about.js, which is a predefined route:

Navigating pages/post/[pid].js, which is a dynamic route:

Redirecting the user to pages/login.js, useful for pages behind authentication:

When navigating to the same page in Next.js, the page's state will not be reset by default as React does not unmount unless the parent component has changed.

In the above example, navigating between /one and /two will not reset the count . The useState is maintained between renders because the top-level React component, Page, is the same.

If you do not want this behavior, you have a couple of options:

Manually ensure each state is updated using useEffect. In the above example, that could look like:

Use a React key to tell React to remount the component. To do this for all pages, you can use a custom app:

You can use a URL object in the same way you can use it for next/link. Works for both the url and as parameters:

Similar to the replace prop in next/link, router.replace will prevent adding a new URL entry into the history stack.

Take a look at the following example:

Prefetch pages for faster client-side transitions. This method is only useful for navigations without next/link, as next/link takes care of prefetching pages automatically.

This is a production only feature. Next.js doesn't prefetch pages in development.

Let's say you have a login page, and after a login, you redirect the user to the dashboard. For that case, we can prefetch the dashboard to make a faster transition, like in the following example:

In some cases (for example, if using a Custom Server), you may wish to listen to popstate and do something before the router acts on it.

If cb returns false, the Next.js router will not handle popstate, and you'll be responsible for handling it in that case. See Disabling file-system routing.

You could use beforePopState to manipulate the request, or force a SSR refresh, as in the following example:

Navigate back in history. Equivalent to clicking the browserâ€™s back button. It executes window.history.back().

Reload the current URL. Equivalent to clicking the browserâ€™s refresh button. It executes window.location.reload().

You can listen to different events happening inside the Next.js Router. Here's a list of supported events:

Good to know: Here url is the URL shown in the browser, including the basePath.

For example, to listen to the router event routeChangeStart, open or create pages/_app.js and subscribe to the event, like so:

We use a Custom App (pages/_app.js) for this example to subscribe to the event because it's not unmounted on page navigations, but you can subscribe to router events on any component in your application.

Router events should be registered when a component mounts (useEffect or componentDidMount / componentWillUnmount) or imperatively when an event happens.

If a route load is cancelled (for example, by clicking two links rapidly in succession), routeChangeError will fire. And the passed err will contain a cancelled property set to true, as in the following example:

This is the same useRouter hook, but can be used in both app and pages directories.

It differs from next/router in that it does not throw an error when the pages router is not mounted, and instead has a return type of NextRouter | null. This allows developers to convert components to support running in both app and pages as they transition to the app router.

A component that previously looked like this:

Will error when converted over to next/compat/router, as null can not be destructured. Instead, developers will be able to take advantage of new hooks:

This component will now work in both pages and app directories. When the component is no longer used in pages, you can remove the references to the compat router:

Another specific use case is when rendering components outside of a Next.js application context, such as inside getServerSideProps on the pages directory. In this case, the compat router can be used to avoid errors:

Certain methods accessible on the router object return a Promise. If you have the ESLint rule, no-floating-promises enabled, consider disabling it either globally, or for the affected line.

If your application needs this rule, you should either void the promise â€“ or use an async function, await the Promise, then void the function call. This is not applicable when the method is called from inside an onClick handler.

The affected methods are:

If useRouter is not the best fit for you, withRouter can also add the same router object to any component.

To use class components with withRouter, the component needs to accept a router prop:

**Examples:**

Example 1 (python):
```python
import { useRouter } from 'next/router'
 
function ActiveLink({ children, href }) {
  const router = useRouter()
  const style = {
    marginRight: 10,
    color: router.asPath === href ? 'red' : 'black',
  }
 
  const handleClick = (e) => {
    e.preventDefault()
    router.push(href)
  }
 
  return (
    <a href={href} onClick={handleClick} style={style}>
      {children}
    </a>
  )
}
 
export default ActiveLink
```

Example 2 (unknown):
```unknown
router.push(url, as, options)
```

Example 3 (python):
```python
import { useRouter } from 'next/router'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/about')}>
      Click me
    </button>
  )
}
```

Example 4 (python):
```python
import { useRouter } from 'next/router'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/post/abc')}>
      Click me
    </button>
  )
}
```

---

## How to set up a custom server in Next.js

**URL:** https://nextjs.org/docs/app/guides/custom-server

**Contents:**
- How to set up a custom server in Next.js

Next.js includes its own server with next start by default. If you have an existing backend, you can still use it with Next.js (this is not a custom server). A custom Next.js server allows you to programmatically start a server for custom patterns. The majority of the time, you will not need this approach. However, it's available if you need to eject.

Take a look at the following example of a custom server:

server.js does not run through the Next.js Compiler or bundling process. Make sure the syntax and source code this file requires are compatible with the current Node.js version you are using. View an example.

To run the custom server, you'll need to update the scripts in package.json like so:

Alternatively, you can set up nodemon (example). The custom server uses the following import to connect the server with the Next.js application:

The above next import is a function that receives an object with the following options:

The returned app can then be used to let Next.js handle requests as required.

**Examples:**

Example 1 (python):
```python
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'
 
const port = parseInt(process.env.PORT || '3000', 10)
const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()
 
app.prepare().then(() => {
  createServer((req, res) => {
    const parsedUrl = parse(req.url!, true)
    handle(req, res, parsedUrl)
  }).listen(port)
 
  console.log(
    `> Server listening at http://localhost:${port} as ${
      dev ? 'development' : process.env.NODE_ENV
    }`
  )
})
```

Example 2 (unknown):
```unknown
{
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "NODE_ENV=production node server.js"
  }
}
```

Example 3 (python):
```python
import next from 'next'
 
const app = next({})
```

---

## No Before Interactive Script Outside Document

**URL:** https://nextjs.org/docs/messages/no-before-interactive-script-outside-document

**Contents:**
- No Before Interactive Script Outside Document
- Why This Error Occurred
- Possible Ways to Fix It
  - App Router
  - Pages Router
- Useful Links

Prevent usage of next/script's beforeInteractive strategy outside of app/layout.jsx or pages/_document.js.

You cannot use the next/script component with the beforeInteractive strategy outside app/layout.jsx or pages/_document.js. That's because beforeInteractive strategy only works inside app/layout.jsx or pages/_document.js and is designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side).

If you want a global script, and you are using the App Router, move the script inside app/layout.jsx.

If you want a global script, and you are using the Pages Router, move the script inside pages/_document.js.

**Examples:**

Example 1 (python):
```python
import Script from 'next/script'
 
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
      <Script
        src="https://example.com/script.js"
        strategy="beforeInteractive"
      />
    </html>
  )
}
```

Example 2 (python):
```python
import { Html, Head, Main, NextScript } from 'next/document'
import Script from 'next/script'
 
export default function Document() {
  return (
    <Html>
      <Head />
      <body>
        <Main />
        <NextScript />
        <Script
          src="https://example.com/script.js"
          strategy="beforeInteractive"
        ></Script>
      </body>
    </Html>
  )
}
```

---

## How to preview content with Draft Mode in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/draft-mode

**Contents:**
- How to preview content with Draft Mode in Next.js
- Step 1: Create a Route Handler
- Step 2: Access the Route Handler from your Headless CMS
- Step 3: Preview the Draft Content
- Next Steps
  - draftMode

Draft Mode allows you to preview draft content from your headless CMS in your Next.js application. This is useful for static pages that are generated at build time as it allows you to switch to dynamic rendering and see the draft changes without having to rebuild your entire site.

This page walks through how to enable and use Draft Mode.

Create a Route Handler. It can have any name, for example, app/api/draft/route.ts.

Then, import the draftMode function and call the enable() method.

This will set a cookie to enable draft mode. Subsequent requests containing this cookie will trigger draft mode and change the behavior of statically generated pages.

You can test this manually by visiting /api/draft and looking at your browserâ€™s developer tools. Notice the Set-Cookie response header with a cookie named __prerender_bypass.

These steps assume that the headless CMS youâ€™re using supports setting custom draft URLs. If it doesnâ€™t, you can still use this method to secure your draft URLs, but youâ€™ll need to construct and access the draft URL manually. The specific steps will vary depending on which headless CMS youâ€™re using.

To securely access the Route Handler from your headless CMS:

Your headless CMS might allow you to include a variable in the draft URL so that <path> can be set dynamically based on the CMSâ€™s data like so: &slug=/posts/{entry.fields.slug}

If it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie.

The next step is to update your page to check the value of draftMode().isEnabled.

If you request a page which has the cookie set, then data will be fetched at request time (instead of at build time).

Furthermore, the value of isEnabled will be true.

If you access the draft Route Handler (with secret and slug) from your headless CMS or manually using the URL, you should now be able to see the draft content. And, if you update your draft without publishing, you should be able to view the draft.

**Examples:**

Example 1 (unknown):
```unknown
export async function GET(request: Request) {
  return new Response('')
}
```

Example 2 (python):
```python
import { draftMode } from 'next/headers'
 
export async function GET(request: Request) {
  const draft = await draftMode()
  draft.enable()
  return new Response('Draft mode is enabled')
}
```

Example 3 (unknown):
```unknown
https://<your-site>/api/draft?secret=<token>&slug=<path>
```

Example 4 (python):
```python
import { draftMode } from 'next/headers'
import { redirect } from 'next/navigation'
 
export async function GET(request: Request) {
  // Parse query string parameters
  const { searchParams } = new URL(request.url)
  const secret = searchParams.get('secret')
  const slug = searchParams.get('slug')
 
  // Check the secret and next parameters
  // This secret should only be known to this Route Handler and the CMS
  if (secret !== 'MY_SECRET_TOKEN' || !slug) {
    return new Response('Invalid token', { status: 401 })
  }
 
  // Fetch the headless CMS to check if the provided `slug` exists
  // getPostBySlug would implement the required fetching logic to the headless CMS
  const post = await getPostBySlug(slug)
 
  // If the slug doesn't exist prevent draft mode from being enabled
  if (!post) {
    return new Response('Invalid slug', { status: 401 })
  }
 
  // Enable Draft Mode by setting the cookie
  const draft = await draftMode()
  draft.enable()
 
  // Redirect to the path from the fetched post
  // We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilities
  redirect(post.slug)
}
```

---

## How to configure Continuous Integration (CI) build caching

**URL:** https://nextjs.org/docs/15/app/guides/ci-build-caching

**Contents:**
- How to configure Continuous Integration (CI) build caching
- Vercel
- CircleCI
- Travis CI
- GitLab CI
- Netlify CI
- AWS CodeBuild
- GitHub Actions
- Bitbucket Pipelines
- Heroku

To improve build performance, Next.js saves a cache to .next/cache that is shared between builds.

To take advantage of this cache in Continuous Integration (CI) environments, your CI workflow will need to be configured to correctly persist the cache between builds.

If your CI is not configured to persist .next/cache between builds, you may see a No Cache Detected error.

Here are some example cache configurations for common CI providers:

Next.js caching is automatically configured for you. There's no action required on your part. If you are using Turborepo on Vercel, learn more here.

Edit your save_cache step in .circleci/config.yml to include .next/cache:

If you do not have a save_cache key, please follow CircleCI's documentation on setting up build caching.

Add or merge the following into your .travis.yml:

Add or merge the following into your .gitlab-ci.yml:

Use Netlify Plugins with @netlify/plugin-nextjs.

Add (or merge in) the following to your buildspec.yml:

Using GitHub's actions/cache, add the following step in your workflow file:

Add or merge the following into your bitbucket-pipelines.yml at the top level (same level as pipelines):

Then reference it in the caches section of your pipeline's step:

Using Heroku's custom cache, add a cacheDirectories array in your top-level package.json:

Using Azure Pipelines' Cache task, add the following task to your pipeline yaml file somewhere prior to the task that executes next build:

Using Jenkins' Job Cacher plugin, add the following build step to your Jenkinsfile where you would normally run next build or npm install:

**Examples:**

Example 1 (unknown):
```unknown
steps:
  - save_cache:
      key: dependency-cache-{{ checksum "yarn.lock" }}
      paths:
        - ./node_modules
        - ./.next/cache
```

Example 2 (unknown):
```unknown
cache:
  directories:
    - $HOME/.cache/yarn
    - node_modules
    - .next/cache
```

Example 3 (unknown):
```unknown
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .next/cache/
```

Example 4 (unknown):
```unknown
cache:
  paths:
    - 'node_modules/**/*' # Cache `node_modules` for faster `yarn` or `npm i`
    - '.next/cache/**/*' # Cache Next.js for faster application rebuilds
```

---

## default.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/default

**Contents:**
- default.js
- Reference
  - params (optional)
- Learn more about Parallel Routes
  - Parallel Routes

The default.js file is used to render a fallback within Parallel Routes when Next.js cannot recover a slot's active state after a full-page load.

During soft navigation, Next.js keeps track of the active state (subpage) for each slot. However, for hard navigations (full-page load), Next.js cannot recover the active state. In this case, a default.js file can be rendered for subpages that don't match the current URL.

Consider the following folder structure. The @team slot has a settings page, but @analytics does not.

When navigating to /settings, the @team slot will render the settings page while maintaining the currently active page for the @analytics slot.

On refresh, Next.js will render a default.js for @analytics. If default.js doesn't exist, an error is returned for named slots (@team, @analytics, etc) and requires you to define a default.js in order to continue. If you want to preserve the old behavior of returning a 404 in these situations, you can create a default.js that contains:

Additionally, since children is an implicit slot, you also need to create a default.js file to render a fallback for children when Next.js cannot recover the active state of the parent page. If you don't create a default.js for the children slot, it will return a 404 page for the route.

A promise that resolves to an object containing the dynamic route parameters from the root segment down to the slot's subpages. For example:

**Examples:**

Example 1 (python):
```python
import { notFound } from 'next/navigation'
 
export default function Default() {
  notFound()
}
```

Example 2 (javascript):
```javascript
export default async function Default({
  params,
}: {
  params: Promise<{ artist: string }>
}) {
  const { artist } = await params
}
```

---

## How to think about data security in Next.js

**URL:** https://nextjs.org/docs/app/guides/data-security

**Contents:**
- How to think about data security in Next.js
- Data fetching approaches
  - External HTTP APIs
  - Data Access Layer
  - Component-level data access
- Reading data
  - Passing data from server to client
  - Tainting
  - Preventing client-side execution of server-only code
- Mutating Data

React Server Components improve performance and simplify data fetching, but also shift where and how data is accessed, changing some of the traditional security assumptions for handling data in frontend apps.

This guide will help you understand how to think about data security in Next.js and how to implement best practices.

There are three main approaches we recommend for fetching data in Next.js, depending on the size and age of your project:

We recommend choosing one data fetching approach and avoiding mixing them. This makes it clear for both developers working in your code base and security auditors what to expect.

You should follow a Zero Trust model when adopting Server Components in an existing project. You can continue calling your existing API endpoints such as REST or GraphQL from Server Components using fetch, just as you would in Client Components.

This approach works well when:

For new projects, we recommend creating a dedicated Data Access Layer (DAL). This is a internal library that controls how and when data is fetched, and what gets passed to your render context.

A Data Access Layer should:

This approach centralizes all data access logic, making it easier to enforce consistent data access and reduces the risk of authorization bugs. You also get the benefit of sharing an in-memory cache across different parts of a request.

Good to know: Secret keys should be stored in environment variables, but only the Data Access Layer should access process.env. This keeps secrets from being exposed to other parts of the application.

For quick prototypes and iteration, database queries can be placed directly in Server Components.

This approach, however, makes it easier to accidentally expose private data to the client, for example:

You should sanitize the data before passing it to the Client Component:

On the initial load, both Server and Client Components run on the server to generate HTML. However, they execute in isolated module systems. This ensures that Server Components can access private data and APIs, while Client Components cannot.

This ensures the app is secure by default, but it's possible to accidentally expose private data through how data is fetched or passed to components.

To prevent accidental exposure of private data to the client, you can use React Taint APIs:

You can enable usage in your Next.js app with the experimental.taint option in next.config.js:

This prevents the tainted objects or values from being passed to the client. However, it's an additional layer of protection, you should still filter and sanitize the data in your DAL before passing it to React's render context.

To prevent server-only code from being executed on the client, you can mark a module with the server-only package:

This ensures that proprietary code or internal business logic stays on the server by causing a build error if the module is imported in the client environment.

Next.js handles mutations with Server Actions.

By default, when a Server Action is created and exported, it creates a public HTTP endpoint and should be treated with the same security assumptions and authorization checks. This means, even if a Server Action or utility function is not imported elsewhere in your code, it's still publicly accessible.

To improve security, Next.js has the following built-in features:

The IDs are created during compilation and are cached for a maximum of 14 days. They will be regenerated when a new build is initiated or when the build cache is invalidated. This security improvement reduces the risk in cases where an authentication layer is missing. However, you should still treat Server Actions like public HTTP endpoints.

You should always validate input from client, as they can be easily modified. For example, form data, URL parameters, headers, and searchParams:

You should always ensure that a user is authorized to perform an action. For example:

Learn more about Authentication in Next.js.

Defining a Server Action inside a component creates a closure where the action has access to the outer function's scope. For example, the publish action has access to the publishVersion variable:

Closures are useful when you need to capture a snapshot of data (e.g. publishVersion) at the time of rendering so that it can be used later when the action is invoked.

However, for this to happen, the captured variables are sent to the client and back to the server when the action is invoked. To prevent sensitive data from being exposed to the client, Next.js automatically encrypts the closed-over variables. A new private key is generated for each action every time a Next.js application is built. This means actions can only be invoked for a specific build.

Good to know: We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client.

When self-hosting your Next.js application across multiple servers, each server instance may end up with a different encryption key, leading to potential inconsistencies.

To mitigate this, you can overwrite the encryption key using the process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY environment variable. Specifying this variable ensures that your encryption keys are persistent across builds, and all server instances use the same key. This variable must be AES-GCM encrypted.

This is an advanced use case where consistent encryption behavior across multiple deployments is critical for your application. You should consider standard security practices such key rotation and signing.

Good to know: Next.js applications deployed to Vercel automatically handle this.

Since Server Actions can be invoked in a <form> element, this opens them up to CSRF attacks.

Behind the scenes, Server Actions use the POST method, and only this HTTP method is allowed to invoke them. This prevents most CSRF vulnerabilities in modern browsers, particularly with SameSite cookies being the default.

As an additional protection, Server Actions in Next.js also compare the Origin header to the Host header (or X-Forwarded-Host). If these don't match, the request will be aborted. In other words, Server Actions can only be invoked on the same host as the page that hosts it.

For large applications that use reverse proxies or multi-layered backend architectures (where the server API differs from the production domain), it's recommended to use the configuration option serverActions.allowedOrigins option to specify a list of safe origins. The option accepts an array of strings.

Learn more about Security and Server Actions.

Mutations (e.g. logging out users, updating databases, invalidating caches) should never be a side-effect, either in Server or Client Components. Next.js explicitly prevents setting cookies or triggering cache revalidation within render methods to avoid unintended side effects.

Instead, you should use Server Actions to handle mutations.

Good to know: Next.js uses POST requests to handle mutations. This prevents accidental side-effects from GET requests, reducing Cross-Site Request Forgery (CSRF) risks.

If you're doing an audit of a Next.js project, here are a few things we recommend looking extra at:

**Examples:**

Example 1 (python):
```python
import { cookies } from 'next/headers'
 
export default async function Page() {
  const cookieStore = cookies()
  const token = cookieStore.get('AUTH_TOKEN')?.value
 
  const res = await fetch('https://api.example.com/profile', {
    headers: {
      Cookie: `AUTH_TOKEN=${token}`,
      // Other headers
    },
  })
 
  // ....
}
```

Example 2 (python):
```python
import { cache } from 'react'
import { cookies } from 'next/headers'
 
// Cached helper methods makes it easy to get the same value in many places
// without manually passing it around. This discourages passing it from Server
// Component to Server Component which minimizes risk of passing it to a Client
// Component.
export const getCurrentUser = cache(async () => {
  const token = cookies().get('AUTH_TOKEN')
  const decodedToken = await decryptAndValidate(token)
  // Don't include secret tokens or private information as public fields.
  // Use classes to avoid accidentally passing the whole object to the client.
  return new User(decodedToken.id)
})
```

Example 3 (python):
```python
import 'server-only'
import { getCurrentUser } from './auth'
 
function canSeeUsername(viewer: User) {
  // Public info for now, but can change
  return true
}
 
function canSeePhoneNumber(viewer: User, team: string) {
  // Privacy rules
  return viewer.isAdmin || team === viewer.team
}
 
export async function getProfileDTO(slug: string) {
  // Don't pass values, read back cached values, also solves context and easier to make it lazy
 
  // use a database API that supports safe templating of queries
  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`
  const userData = rows[0]
 
  const currentUser = await getCurrentUser()
 
  // only return the data relevant for this query and not everything
  // <https://www.w3.org/2001/tag/doc/APIMinimization>
  return {
    username: canSeeUsername(currentUser) ? userData.username : null,
    phonenumber: canSeePhoneNumber(currentUser, userData.team)
      ? userData.phonenumber
      : null,
  }
}
```

Example 4 (python):
```python
import { getProfile } from '../../data/user'
 
export async function Page({ params: { slug } }) {
  // This page can now safely pass around this profile knowing
  // that it shouldn't contain anything sensitive.
  const profile = await getProfile(slug);
  ...
}
```

---

## How to use and optimize videos

**URL:** https://nextjs.org/docs/15/app/guides/videos

**Contents:**
- How to use and optimize videos
- Using <video> and <iframe>
  - <video>
  - Common <video> tag attributes
  - Video best practices
  - <iframe>
  - Common <iframe> tag attributes
  - Choosing a video embedding method
  - Embedding externally hosted videos
- Self-hosted videos

This page outlines how to use videos with Next.js applications, showing how to store and display video files without affecting performance.

Videos can be embedded on the page using the HTML <video> tag for direct video files and <iframe> for external platform-hosted videos.

The HTML <video> tag can embed self-hosted or directly served video content, allowing full control over the playback and appearance.

Good to know: When using the autoPlay attribute, it is important to also include the muted attribute to ensure the video plays automatically in most browsers and the playsInline attribute for compatibility with iOS devices.

For a comprehensive list of video attributes, refer to the MDN documentation.

The HTML <iframe> tag allows you to embed videos from external platforms like YouTube or Vimeo.

For a comprehensive list of iframe attributes, refer to the MDN documentation.

There are two ways you can embed videos in your Next.js application:

Choose the embedding method that aligns with your application's requirements and the user experience you aim to deliver.

To embed videos from external platforms, you can use Next.js to fetch the video information and React Suspense to handle the fallback state while loading.

1. Create a Server Component for video embedding

The first step is to create a Server Component that generates the appropriate iframe for embedding the video. This component will fetch the source URL for the video and render the iframe.

2. Stream the video component using React Suspense

After creating the Server Component to embed the video, the next step is to stream the component using React Suspense.

Good to know: When embedding videos from external platforms, consider the following best practices:

This approach results in a better user experience as it prevents the page from blocking, meaning the user can interact with the page while the video component streams in.

For a more engaging and informative loading experience, consider using a loading skeleton as the fallback UI. So instead of showing a simple loading message, you can show a skeleton that resembles the video player like this:

Self-hosting videos may be preferable for several reasons:

Vercel Blob offers an efficient way to host videos, providing a scalable cloud storage solution that works well with Next.js. Here's how you can host a video using Vercel Blob:

1. Uploading a video to Vercel Blob

In your Vercel dashboard, navigate to the "Storage" tab and select your Vercel Blob store. In the Blob table's upper-right corner, find and click the "Upload" button. Then, choose the video file you wish to upload. After the upload completes, the video file will appear in the Blob table.

Alternatively, you can upload your video using a server action. For detailed instructions, refer to the Vercel documentation on server-side uploads. Vercel also supports client-side uploads. This method may be preferable for certain use cases.

2. Displaying the video in Next.js

Once the video is uploaded and stored, you can display it in your Next.js application. Here's an example of how to do this using the <video> tag and React Suspense:

In this approach, the page uses the video's @vercel/blob URL to display the video using the VideoComponent. React Suspense is used to show a fallback until the video URL is fetched and the video is ready to be displayed.

If you have subtitles for your video, you can easily add them using the <track> element inside your <video> tag. You can fetch the subtitle file from Vercel Blob in a similar way as the video file. Here's how you can update the <VideoComponent> to include subtitles.

By following this approach, you can effectively self-host and integrate videos into your Next.js applications.

To continue learning more about video optimization and best practices, please refer to the following resources:

Explore these video streaming platforms for integrating video into your Next.js projects:

**Examples:**

Example 1 (unknown):
```unknown
export function Video() {
  return (
    <video width="320" height="240" controls preload="none">
      <source src="/path/to/video.mp4" type="video/mp4" />
      <track
        src="/path/to/captions.vtt"
        kind="subtitles"
        srcLang="en"
        label="English"
      />
      Your browser does not support the video tag.
    </video>
  )
}
```

Example 2 (unknown):
```unknown
export default function Page() {
  return (
    <iframe src="https://www.youtube.com/embed/19g66ezsKAg" allowFullScreen />
  )
}
```

Example 3 (javascript):
```javascript
export default async function VideoComponent() {
  const src = await getVideoSrc()
 
  return <iframe src={src} allowFullScreen />
}
```

Example 4 (python):
```python
import { Suspense } from 'react'
import VideoComponent from '../ui/VideoComponent.jsx'
 
export default function Page() {
  return (
    <section>
      <Suspense fallback={<p>Loading video...</p>}>
        <VideoComponent />
      </Suspense>
      {/* Other content of the page */}
    </section>
  )
}
```

---

## Migrating

**URL:** https://nextjs.org/docs/pages/guides/migrating

**Contents:**
- Migrating
  - App Router
  - Create React App
  - Vite

---

## Prefetching

**URL:** https://nextjs.org/docs/app/guides/prefetching

**Contents:**
- Prefetching
- How does prefetching work?
- Prefetching static vs. dynamic routes
- Automatic prefetch
- Manual prefetch
- Hover-triggered prefetch
- Extending or ejecting link
- Disabled prefetch
- Prefetching optimizations
  - Client cache

Prefetching makes navigating between different routes in your application feel instant. Next.js tries to intelligently prefetch by default, based on the links used in your application code.

This guide will explain how prefetching works and show common implementation patterns:

When navigating between routes, the browser requests assets for the page like HTML and JavaScript files. Prefetching is the process of fetching these resources ahead of time, before you navigate to a new route.

Next.js automatically splits your application into smaller JavaScript chunks based on routes. Instead of loading all the code upfront like traditional SPAs, only the code needed for the current route is loaded. This reduces the initial load time while other parts of the app are loaded in the background. By the time you click the link, the resources for the new route have already been loaded into the browser cache.

When navigating to the new page, there's no full page reload or browser loading spinner. Instead, Next.js performs a client-side transition, making the page navigation feel instant.

Good to know: During the initial navigation, the browser fetches the HTML, JavaScript, and React Server Components (RSC) Payload. For subsequent navigations, the browser will fetch the RSC Payload for Server Components and JS bundle for Client Components.

Automatic prefetching runs only in production. Disable with prefetch={false} or use the wrapper in Disabled Prefetch.

To do manual prefetching, import the useRouter hook from next/navigation, and call router.prefetch() to warm routes outside the viewport or in response to analytics, hover, scroll, etc.

If the intent is to prefetch a URL when a component loads, see the extending or rejecting a link [example].

Proceed with caution: Extending Link opts you into maintaining prefetching, cache invalidation, and accessibility concerns. Proceed only if defaults are insufficient.

Next.js tries to do the right prefetching by default, but power users can eject and modify based on their needs. You have the control between performance and resource consumption.

For example, you might have to only trigger prefetches on hover, instead of when entering the viewport (the default behavior):

prefetch={null} restores default (static) prefetching once the user shows intent.

You can extend the <Link> component to create your own custom prefetching strategy. For example, using the ForesightJS library which prefetches links by predicting the direction of the user's cursor.

Alternatively, you can use useRouter to recreate some of the native <Link> behavior. However, be aware this opts you into maintaining prefetching and cache invalidation.

onInvalidate is invoked when Next.js suspects cached data is stale, allowing you to refresh the prefetch.

Good to know: Using an a tag will cause a full page navigation to the destination route, you can use onClick to prevent the full page navigation, and then invoke router.push to navigate to the destination.

You can fully disable prefetching for certain routes for more fine-grained control over resource consumption.

For example, you may still want to have consistent usage of <Link> in your application, but links in your footer might not need to be prefetched when entering the viewport.

Next.js stores prefetched React Server Component payloads in memory, keyed by route segments. When navigating between sibling routes (e.g. /dashboard/settings â†’ /dashboard/analytics), it reuses the parent layout and only fetches the updated leaf page. This reduces network traffic and improves navigation speed.

Next.js maintains a small task queue, which prefetches in the following order:

The scheduler prioritizes likely navigations while minimizing unused downloads.

When PPR is enabled, a page is divided into a static shell and a streamed dynamic section:

If your layouts or pages are not pure and have side-effects (e.g. tracking analytics), these might be triggered when the route is prefetched, not when the user visits the page.

To avoid this, you should move side-effects to a useEffect hook or a Server Action triggered from a Client Component.

Next.js automatically prefetches links in the viewport when using the <Link> component.

There may be cases where you want to prevent this to avoid unnecessary usage of resources, such as when rendering a large list of links (e.g. an infinite scroll table).

You can disable prefetching by setting the prefetch prop of the <Link> component to false.

However, this means static routes will only be fetched on click, and dynamic routes will wait for the server to render before navigating.

To reduce resource usage without disabling prefetch entirely, you can defer prefetching until the user hovers over a link. This targets only links the user is likely to visit.

**Examples:**

Example 1 (python):
```python
import Link from 'next/link'
 
export default function NavLink() {
  return <Link href="/about">About</Link>
}
```

Example 2 (python):
```python
'use client'
 
import { useRouter } from 'next/navigation'
import { CustomLink } from '@components/link'
 
export function PricingCard() {
  const router = useRouter()
 
  return (
    <div onMouseEnter={() => router.prefetch('/pricing')}>
      {/* other UI elements */}
      <CustomLink href="/pricing">View Pricing</CustomLink>
    </div>
  )
}
```

Example 3 (python):
```python
'use client'
 
import Link from 'next/link'
import { useState } from 'react'
 
export function HoverPrefetchLink({
  href,
  children,
}: {
  href: string
  children: React.ReactNode
}) {
  const [active, setActive] = useState(false)
 
  return (
    <Link
      href={href}
      prefetch={active ? null : false}
      onMouseEnter={() => setActive(true)}
    >
      {children}
    </Link>
  )
}
```

Example 4 (python):
```python
'use client'
 
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
 
function ManualPrefetchLink({
  href,
  children,
}: {
  href: string
  children: React.ReactNode
}) {
  const router = useRouter()
 
  useEffect(() => {
    let cancelled = false
    const poll = () => {
      if (!cancelled) router.prefetch(href, { onInvalidate: poll })
    }
    poll()
    return () => {
      cancelled = true
    }
  }, [href, router])
 
  return (
    <a
      href={href}
      onClick={(event) => {
        event.preventDefault()
        router.push(href)
      }}
    >
      {children}
    </a>
  )
}
```

---

## How to migrate from Create React App to Next.js

**URL:** https://nextjs.org/docs/app/guides/migrating/from-create-react-app

**Contents:**
- How to migrate from Create React App to Next.js
- Why Switch?
  - Slow initial page loading time
  - No automatic code splitting
  - Network waterfalls
  - Fast and intentional loading states
  - Choose the data fetching strategy
  - Proxy
  - Built-in Optimizations
- Migration Steps

This guide will help you migrate an existing Create React App (CRA) site to Next.js.

There are several reasons why you might want to switch from Create React App to Next.js:

Create React App uses purely client-side rendering. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:

The previous issue of slow loading times can be somewhat mitigated with code splitting. However, if you try to do code splitting manually, you can inadvertently introduce network waterfalls. Next.js provides automatic code splitting and tree-shaking built into its router and build pipeline.

A common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One pattern for data fetching in a SPA is to render a placeholder, and then fetch data after the component has mounted. Unfortunately, a child component can only begin fetching data after its parent has finished loading its own data, resulting in a â€œwaterfallâ€ of requests.

While client-side data fetching is supported in Next.js, Next.js also lets you move data fetching to the server. This often eliminates client-server waterfalls altogether.

With built-in support for streaming through React Suspense, you can define which parts of your UI load first and in what order, without creating network waterfalls.

This enables you to build pages that are faster to load and eliminate layout shifts.

Depending on your needs, Next.js allows you to choose your data fetching strategy on a page or component-level basis. For example, you could fetch data from your CMS and render blog posts at build time (SSG) for quick load speeds, or fetch data at request time (SSR) when necessary.

Next.js Proxy allows you to run code on the server before a request is completed. For instance, you can avoid a flash of unauthenticated content by redirecting a user to a login page in the proxy for authenticated-only pages. You can also use it for features like A/B testing, experimentation, and internationalization.

Images, fonts, and third-party scripts often have a large impact on an applicationâ€™s performance. Next.js includes specialized components and APIs that automatically optimize them for you.

Our goal is to get a working Next.js application as quickly as possible so that you can then adopt Next.js features incrementally. To begin with, weâ€™ll treat your application as a purely client-side application (SPA) without immediately replacing your existing router. This reduces complexity and merge conflicts.

Note: If you are using advanced CRA configurations such as a custom homepage field in your package.json, a custom service worker, or specific Babel/webpack tweaks, please see the Additional Considerations section at the end of this guide for tips on replicating or adapting these features in Next.js.

Install Next.js in your existing project:

Create a next.config.ts at the root of your project (same level as your package.json). This file holds your Next.js configuration options.

Note: Using output: 'export' means youâ€™re doing a static export. You will not have access to server-side features like SSR or APIs. You can remove this line to leverage Next.js server features.

A Next.js App Router application must include a root layout file, which is a React Server Component that will wrap all your pages.

The closest equivalent of the root layout file in a CRA application is public/index.html, which includes your <html>, <head>, and <body> tags.

Now copy the content of your old index.html into this <RootLayout> component. Replace body div#root (and body noscript) with <div id="root">{children}</div>.

Good to know: Next.js ignores CRAâ€™s public/manifest.json, additional iconography, and testing configuration by default. If you need these, Next.js has support with its Metadata API and Testing setup.

Next.js automatically includes the <meta charset="UTF-8" /> and <meta name="viewport" content="width=device-width, initial-scale=1" /> tags, so you can remove them from <head>:

Any metadata files such as favicon.ico, icon.png, robots.txt are automatically added to the application <head> tag as long as you have them placed into the top level of the app directory. After moving all supported files into the app directory you can safely delete their <link> tags:

Finally, Next.js can manage your last <head> tags with the Metadata API. Move your final metadata info into an exported metadata object:

With the above changes, you shifted from declaring everything in your index.html to using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages.

Like CRA, Next.js supports CSS Modules out of the box. It also supports global CSS imports.

If you have a global CSS file, import it into your app/layout.tsx:

If you're using Tailwind CSS, see our installation docs.

Create React App uses src/index.tsx (or index.js) as the entry point. In Next.js (App Router), each folder inside the app directory corresponds to a route, and each folder should have a page.tsx.

Since we want to keep the app as an SPA for now and intercept all routes, weâ€™ll use an optional catch-all route.

This tells Next.js to generate a single route for the empty slug (/), effectively mapping all routes to the same page. This page is a Server Component, prerendered into static HTML.

Next, weâ€™ll embed your CRAâ€™s root App component inside a Client Component so that all logic remains client-side. If this is your first time using Next.js, it's worth knowing that clients components (by default) are still prerendered on the server. You can think about them as having the additional capability of running client-side JavaScript.

Create a client.tsx (or client.js) in app/[[...slug]]/:

Now update your page.tsx (or page.js) to use your new component:

In CRA, importing an image file returns its public URL as a string:

With Next.js, static image imports return an object. The object can then be used directly with the Next.js <Image> component, or you can use the object's src property with your existing <img> tag.

The <Image> component has the added benefits of automatic image optimization. The <Image> component automatically sets the width and height attributes of the resulting <img> based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled to auto. When not styled to auto, the dimension will default to the <img> dimension attribute's value, which can cause the image to appear distorted.

Keeping the <img> tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the <Image> component to take advantage of optimizing images by configuring a loader, or moving to the default Next.js server which has automatic image optimization.

Convert absolute import paths for images imported from /public into relative imports:

Pass the image src property instead of the whole image object to your <img> tag:

Alternatively, you can reference the public URL for the image asset based on the filename. For example, public/logo.png will serve the image at /logo.png for your application, which would be the src value.

Warning: If you're using TypeScript, you might encounter type errors when accessing the src property. To fix them, you need to add next-env.d.ts to the include array of your tsconfig.json file. Next.js will automatically generate this file when you run your application on step 9.

Next.js supports environment variables similarly to CRA but requires a NEXT_PUBLIC_ prefix for any variable you want to expose in the browser.

The main difference is the prefix used to expose environment variables on the client-side. Change all environment variables with the REACT_APP_ prefix to NEXT_PUBLIC_.

Update your package.json scripts to use Next.js commands. Also, add .next and next-env.d.ts to your .gitignore:

Open http://localhost:3000. You should see your application now running on Next.js (in SPA mode).

You can now remove artifacts that are specific to Create React App:

If you used the homepage field in your CRA package.json to serve the app under a specific subpath, you can replicate that in Next.js using the basePath configuration in next.config.ts:

If you used CRAâ€™s service worker (e.g., serviceWorker.js from create-react-app), you can learn how to create Progressive Web Applications (PWAs) with Next.js.

If your CRA app used the proxy field in package.json to forward requests to a backend server, you can replicate this with Next.js rewrites in next.config.ts:

If you had a custom webpack or Babel configuration in CRA, you can extend Next.jsâ€™s config in next.config.ts:

Note: This will require using Webpack by adding --webpack to your dev script.

Next.js automatically sets up TypeScript if you have a tsconfig.json. Make sure next-env.d.ts is listed in your tsconfig.json include array:

Create React App uses webpack for bundling. Next.js now defaults to Turbopack for faster local development:

To use Webpack instead (similar to CRA):

You can still provide a custom webpack configuration if you need to migrate advanced webpack settings from CRA.

If everything worked, you now have a functioning Next.js application running as a single-page application. You arenâ€™t yet leveraging Next.js features like server-side rendering or file-based routing, but you can now do so incrementally:

Note: Using a static export (output: 'export') does not currently support the useParams hook or other server features. To use all Next.js features, remove output: 'export' from your next.config.ts.

**Examples:**

Example 1 (unknown):
```unknown
npm install next@latest
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  output: 'export', // Outputs a Single-Page Application (SPA)
  distDir: 'build', // Changes the build output directory to `build`
}
 
export default nextConfig
```

Example 3 (unknown):
```unknown
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return '...'
}
```

Example 4 (unknown):
```unknown
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <meta charSet="UTF-8" />
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

---

## Static Site Generation (SSG)

**URL:** https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation

**Contents:**
- Static Site Generation (SSG)
  - Static Generation without data
  - Static Generation with data
    - Scenario 1: Your page content depends on external data
    - Scenario 2: Your page paths depend on external data
  - When should I use Static Generation?

If a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated when you run next build. This HTML will then be reused on each request. It can be cached by a CDN.

In Next.js, you can statically generate pages with or without data. Let's take a look at each case.

By default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example:

Note that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time.

Some pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use these functions that Next.js provides:

Example: Your blog page might need to fetch the list of blog posts from a CMS (content management system).

To fetch this data on pre-render, Next.js allows you to export an async function called getStaticProps from the same file. This function gets called at build time and lets you pass fetched data to the page's props on pre-render.

To learn more about how getStaticProps works, check out the Data Fetching documentation.

Next.js allows you to create pages with dynamic routes. For example, you can create a file called pages/posts/[id].js to show a single blog post based on id. This will allow you to show a blog post with id: 1 when you access posts/1.

To learn more about dynamic routing, check the Dynamic Routing documentation.

However, which id you want to pre-render at build time might depend on external data.

Example: suppose that you've only added one blog post (with id: 1) to the database. In this case, you'd only want to pre-render posts/1 at build time.

Later, you might add the second post with id: 2. Then you'd want to pre-render posts/2 as well.

So your page paths that are pre-rendered depend on external data. To handle this, Next.js lets you export an async function called getStaticPaths from a dynamic page (pages/posts/[id].js in this case). This function gets called at build time and lets you specify which paths you want to pre-render.

Also in pages/posts/[id].js, you need to export getStaticProps so that you can fetch the data about the post with this id and use it to pre-render the page:

To learn more about how getStaticPaths works, check out the Data Fetching documentation.

We recommend using Static Generation (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.

You can use Static Generation for many types of pages, including:

You should ask yourself: "Can I pre-render this page ahead of a user's request?" If the answer is yes, then you should choose Static Generation.

On the other hand, Static Generation is not a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.

In cases like this, you can do one of the following:

**Examples:**

Example 1 (unknown):
```unknown
function About() {
  return <div>About</div>
}
 
export default About
```

Example 2 (javascript):
```javascript
// TODO: Need to fetch `posts` (by calling some API endpoint)
//       before this page can be pre-rendered.
export default function Blog({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li>{post.title}</li>
      ))}
    </ul>
  )
}
```

Example 3 (javascript):
```javascript
export default function Blog({ posts }) {
  // Render posts...
}
 
// This function gets called at build time
export async function getStaticProps() {
  // Call an external API endpoint to get posts
  const res = await fetch('https://.../posts')
  const posts = await res.json()
 
  // By returning { props: { posts } }, the Blog component
  // will receive `posts` as a prop at build time
  return {
    props: {
      posts,
    },
  }
}
```

Example 4 (javascript):
```javascript
// This function gets called at build time
export async function getStaticPaths() {
  // Call an external API endpoint to get posts
  const res = await fetch('https://.../posts')
  const posts = await res.json()
 
  // Get the paths we want to pre-render based on posts
  const paths = posts.map((post) => ({
    params: { id: post.id },
  }))
 
  // We'll pre-render only these paths at build time.
  // { fallback: false } means other routes should 404.
  return { paths, fallback: false }
}
```

---

## pageExtensions

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js/pageExtensions

**Contents:**
- pageExtensions
- Including non-page files in the pages directory

You can extend the default Page extensions (.tsx, .ts, .jsx, .js) used by Next.js. Inside next.config.js, add the pageExtensions config:

Changing these values affects all Next.js pages, including the following:

For example, if you reconfigure .ts page extensions to .page.ts, you would need to rename pages like proxy.page.ts, instrumentation.page.ts, _app.page.ts.

You can colocate test files or other files used by components in the pages directory. Inside next.config.js, add the pageExtensions config:

Then, rename your pages to have a file extension that includes .page (e.g. rename MyPage.tsx to MyPage.page.tsx). Ensure you rename all Next.js pages, including the files mentioned above.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  pageExtensions: ['mdx', 'md', 'jsx', 'js', 'tsx', 'ts'],
}
```

Example 2 (unknown):
```unknown
module.exports = {
  pageExtensions: ['page.tsx', 'page.ts', 'page.jsx', 'page.js'],
}
```

---

## How to self-host your Next.js application

**URL:** https://nextjs.org/docs/pages/guides/self-hosting

**Contents:**
- How to self-host your Next.js application
- Reverse Proxy
- Image Optimization
- Proxy
- Environment Variables
- Caching and ISR
  - Automatic Caching
  - Static Assets
  - Configuring Caching
- Build Cache

When deploying your Next.js app, you may want to configure how different features are handled based on your infrastructure.

ðŸŽ¥ Watch: Learn more about self-hosting Next.js â†’ YouTube (45 minutes).

When self-hosting, it's recommended to use a reverse proxy (like nginx) in front of your Next.js server rather than exposing it directly to the internet. A reverse proxy can handle malformed requests, slow connection attacks, payload size limits, rate limiting, and other security concerns, offloading these tasks from the Next.js server. This allows the server to dedicate its resources to rendering rather than request validation.

Image Optimization through next/image works self-hosted with zero configuration when deploying using next start. If you would prefer to have a separate service to optimize images, you can configure an image loader.

Image Optimization can be used with a static export by defining a custom image loader in next.config.js. Note that images are optimized at runtime, not during the build.

Proxy works self-hosted with zero configuration when deploying using next start. Since it requires access to the incoming request, it is not supported when using a static export.

Proxy uses the Edge runtime, a subset of all available Node.js APIs to help ensure low latency, since it may run in front of every route or asset in your application. If you do not want this, you can use the full Node.js runtime to run Proxy.

If you are looking to add logic (or use an external package) that requires all Node.js APIs, you might be able to move this logic to a layout as a Server Component. For example, checking headers and redirecting. You can also use headers, cookies, or query parameters to redirect or rewrite through next.config.js. If that does not work, you can also use a custom server.

Next.js can support both build time and runtime environment variables.

By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.

To read runtime environment variables, we recommend using getServerSideProps or incrementally adopting the App Router.

This allows you to use a singular Docker image that can be promoted through multiple environments with different values.

Next.js can cache responses, generated static pages, build outputs, and other static assets like images, fonts, and scripts.

Caching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. By default, this cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-hosting using both the Pages and App Router.

You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.

If you want to host static assets on a different domain or CDN, you can use the assetPrefix configuration in next.config.js. Next.js will use this asset prefix when retrieving JavaScript or CSS files. Separating your assets to a different domain does come with the downside of extra time spent on DNS and TLS resolution.

Learn more about assetPrefix.

By default, generated cache assets will be stored in memory (defaults to 50mb) and on disk. If you are hosting Next.js using a container orchestration platform like Kubernetes, each pod will have a copy of the cache. To prevent stale data from being shown since the cache is not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching.

To configure the ISR/Data Cache location when self-hosting, you can configure a custom handler in your next.config.js file:

Then, create cache-handler.js in the root of your project, for example:

Using a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application. For instance, you can save the cached values anywhere, like Redis or AWS S3.

Next.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers.

If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use the generateBuildId command in next.config.js:

Next.js will automatically mitigate most instances of version skew and automatically reload the application to retrieve new assets when detected. For example, if there is a mismatch in the deploymentId, transitions between pages will perform a hard navigation versus using a prefetched value.

When the application is reloaded, there may be a loss of application state if it's not designed to persist between page navigations. For example, using URL state or local storage would persist state after a page refresh. However, component state like useState would be lost in such navigations.

When self-hosting, you might want to run code when the server shuts down on SIGTERM or SIGINT signals.

You can set the env variable NEXT_MANUAL_SIG_HANDLE to true and then register a handler for that signal inside your _document.js file. You will need to register the environment variable directly in the package.json script, and not in the .env file.

Good to know: Manual signal handling is not available in next dev.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // disable default in-memory caching
}
```

Example 2 (javascript):
```javascript
const cache = new Map()
 
module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }
 
  async get(key) {
    // This could be stored anywhere, like durable storage
    return cache.get(key)
  }
 
  async set(key, data, ctx) {
    // This could be stored anywhere, like durable storage
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }
 
  async revalidateTag(tags) {
    // tags is either a string or an array of strings
    tags = [tags].flat()
    // Iterate over all entries in the cache
    for (let [key, value] of cache) {
      // If the value's tags include the specified tag, delete this entry
      if (value.tags.some((tag) => tags.includes(tag))) {
        cache.delete(key)
      }
    }
  }
 
  // If you want to have temporary in memory cache for a single request that is reset
  // before the next request you can leverage this method
  resetRequestCache() {}
}
```

Example 3 (javascript):
```javascript
module.exports = {
  generateBuildId: async () => {
    // This could be anything, using the latest git hash
    return process.env.GIT_HASH
  },
}
```

Example 4 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "NEXT_MANUAL_SIG_HANDLE=true next start"
  }
}
```

---

## How to implement internationalization in Next.js

**URL:** https://nextjs.org/docs/pages/guides/internationalization

**Contents:**
- How to implement internationalization in Next.js
- Getting started
- Locale Strategies
  - Sub-path Routing
  - Domain Routing
- Automatic Locale Detection
  - Prefixing the Default Locale
  - Disabling Automatic Locale Detection
- Accessing the locale information
- Transition between locales

Next.js has built-in support for internationalized (i18n) routing since v10.0.0. You can provide a list of locales, the default locale, and domain-specific locales and Next.js will automatically handle the routing.

The i18n routing support is currently meant to complement existing i18n library solutions like react-intl, react-i18next, lingui, rosetta, next-intl, next-translate, next-multilingual, tolgee, paraglide-next, next-intlayer, gt-react and others by streamlining the routes and locale parsing.

To get started, add the i18n config to your next.config.js file.

Locales are UTS Locale Identifiers, a standardized format for defining locales.

Generally a Locale Identifier is made up of a language, region, and script separated by a dash: language-region-script. The region and script are optional. An example:

If user locale is nl-BE and it is not listed in your configuration, they will be redirected to nl if available, or to the default locale otherwise. If you don't plan to support all regions of a country, it is therefore a good practice to include country locales that will act as fallbacks.

There are two locale handling strategies: Sub-path Routing and Domain Routing.

Sub-path Routing puts the locale in the url path.

With the above configuration en-US, fr, and nl-NL will be available to be routed to, and en-US is the default locale. If you have a pages/blog.js the following urls would be available:

The default locale does not have a prefix.

By using domain routing you can configure locales to be served from different domains:

For example if you have pages/blog.js the following urls will be available:

When a user visits the application root (generally /), Next.js will try to automatically detect which locale the user prefers based on the Accept-Language header and the current domain.

If a locale other than the default locale is detected, the user will be redirected to either:

When using Domain Routing, if a user with the Accept-Language header fr;q=0.9 visits example.com, they will be redirected to example.fr since that domain handles the fr locale by default.

When using Sub-path Routing, the user would be redirected to /fr.

With Next.js 12 and Proxy, we can add a prefix to the default locale with a workaround.

For example, here's a next.config.js file with support for a few languages. Note the "default" locale has been added intentionally.

Next, we can use Proxy to add custom routing rules:

This Proxy skips adding the default prefix to API Routes and public files like fonts or images. If a request is made to the default locale, we redirect to our prefix /en.

The automatic locale detection can be disabled with:

When localeDetection is set to false Next.js will no longer automatically redirect based on the user's preferred locale and will only provide locale information detected from either the locale based domain or locale path as described above.

You can access the locale information via the Next.js router. For example, using the useRouter() hook the following properties are available:

When pre-rendering pages with getStaticProps or getServerSideProps, the locale information is provided in the context provided to the function.

When leveraging getStaticPaths, the configured locales are provided in the context parameter of the function under locales and the configured defaultLocale under defaultLocale.

You can use next/link or next/router to transition between locales.

For next/link, a locale prop can be provided to transition to a different locale from the currently active one. If no locale prop is provided, the currently active locale is used during client-transitions. For example:

When using the next/router methods directly, you can specify the locale that should be used via the transition options. For example:

Note that to handle switching only the locale while preserving all routing information such as dynamic route query values or hidden href query values, you can provide the href parameter as an object:

See here for more information on the object structure for router.push.

If you have a href that already includes the locale you can opt-out of automatically handling the locale prefixing:

Next.js allows setting a NEXT_LOCALE=the-locale cookie, which takes priority over the accept-language header. This cookie can be set using a language switcher and then when a user comes back to the site it will leverage the locale specified in the cookie when redirecting from / to the correct locale location.

For example, if a user prefers the locale fr in their accept-language header but a NEXT_LOCALE=en cookie is set the en locale when visiting / the user will be redirected to the en locale location until the cookie is removed or expired.

Since Next.js knows what language the user is visiting it will automatically add the lang attribute to the <html> tag.

Next.js doesn't know about variants of a page so it's up to you to add the hreflang meta tags using next/head. You can learn more about hreflang in the Google Webmasters documentation.

Note that Internationalized Routing does not integrate with output: 'export' as it does not leverage the Next.js routing layer. Hybrid Next.js applications that do not use output: 'export' are fully supported.

For pages using getStaticProps with Dynamic Routes, all locale variants of the page desired to be prerendered need to be returned from getStaticPaths. Along with the params object returned for paths, you can also return a locale field specifying which locale you want to render. For example:

For Automatically Statically Optimized and non-dynamic getStaticProps pages, a version of the page will be generated for each locale. This is important to consider because it can increase build times depending on how many locales are configured inside getStaticProps.

For example, if you have 50 locales configured with 10 non-dynamic pages using getStaticProps, this means getStaticProps will be called 500 times. 50 versions of the 10 pages will be generated during each build.

To decrease the build time of dynamic pages with getStaticProps, use a fallback mode. This allows you to return only the most popular paths and locales from getStaticPaths for prerendering during the build. Then, Next.js will build the remaining pages at runtime as they are requested.

For pages that are automatically statically optimized, a version of the page will be generated for each locale.

For non-dynamic getStaticProps pages, a version is generated for each locale like above. getStaticProps is called with each locale that is being rendered. If you would like to opt-out of a certain locale from being pre-rendered, you can return notFound: true from getStaticProps and this variant of the page will not be generated.

Good to know: These limits have been added initially to prevent potential performance issues at build time. You can workaround these limits with custom routing using Proxy in Next.js 12.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  i18n: {
    // These are all the locales you want to support in
    // your application
    locales: ['en-US', 'fr', 'nl-NL'],
    // This is the default locale you want to be used when visiting
    // a non-locale prefixed path e.g. `/hello`
    defaultLocale: 'en-US',
    // This is a list of locale domains and the default locale they
    // should handle (these are only required when setting up domain routing)
    // Note: subdomains must be included in the domain value to be matched e.g. "fr.example.com".
    domains: [
      {
        domain: 'example.com',
        defaultLocale: 'en-US',
      },
      {
        domain: 'example.nl',
        defaultLocale: 'nl-NL',
      },
      {
        domain: 'example.fr',
        defaultLocale: 'fr',
        // an optional http field can also be used to test
        // locale domains locally with http instead of https
        http: true,
      },
    ],
  },
}
```

Example 2 (unknown):
```unknown
module.exports = {
  i18n: {
    locales: ['en-US', 'fr', 'nl-NL'],
    defaultLocale: 'en-US',
  },
}
```

Example 3 (unknown):
```unknown
module.exports = {
  i18n: {
    locales: ['en-US', 'fr', 'nl-NL', 'nl-BE'],
    defaultLocale: 'en-US',
 
    domains: [
      {
        // Note: subdomains must be included in the domain value to be matched
        // e.g. www.example.com should be used if that is the expected hostname
        domain: 'example.com',
        defaultLocale: 'en-US',
      },
      {
        domain: 'example.fr',
        defaultLocale: 'fr',
      },
      {
        domain: 'example.nl',
        defaultLocale: 'nl-NL',
        // specify other locales that should be redirected
        // to this domain
        locales: ['nl-BE'],
      },
    ],
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  i18n: {
    locales: ['default', 'en', 'de', 'fr'],
    defaultLocale: 'default',
    localeDetection: false,
  },
  trailingSlash: true,
}
```

---

## useLinkStatus

**URL:** https://nextjs.org/docs/app/api-reference/functions/use-link-status

**Contents:**
- useLinkStatus
- You might not need useLinkStatus
- Parameters
- Returns
- Example
  - Inline link hint
- Gracefully handling fast navigation
- Version History
- Next Steps
  - Link Component

The useLinkStatus hook lets you track the pending state of a <Link>. Use it for subtle, inline feedback, for example a shimmer effect over the clicked link, while navigation completes. Prefer route-level fallbacks with loading.js, and prefetching for instant transitions.

useLinkStatus is useful when:

Before adding inline feedback, consider if:

Navigation is typically fast. Use useLinkStatus as a quick patch when you identify a slow transition, then iterate to fix the root cause with prefetching or a loading.js fallback.

useLinkStatus does not take any parameters.

useLinkStatus returns an object with a single property:

Add a subtle, fixed-size hint that doesnâ€™t affect layout to confirm a click when prefetching hasnâ€™t completed.

If the navigation to a new route is fast, users may see an unnecessary flash of the hint. One way to improve the user experience and only show the hint when the navigation takes time to complete is to add an initial animation delay (e.g. 100ms) and start the animation as invisible (e.g. opacity: 0).

**Examples:**

Example 1 (python):
```python
'use client'
 
import Link from 'next/link'
import { useLinkStatus } from 'next/link'
 
function Hint() {
  const { pending } = useLinkStatus()
  return (
    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />
  )
}
 
export default function Header() {
  return (
    <header>
      <Link href="/dashboard" prefetch={false}>
        <span className="label">Dashboard</span> <Hint />
      </Link>
    </header>
  )
}
```

Example 2 (javascript):
```javascript
const { pending } = useLinkStatus()
```

Example 3 (python):
```python
'use client'
 
import { useLinkStatus } from 'next/link'
 
export default function LoadingIndicator() {
  const { pending } = useLinkStatus()
  return (
    <span aria-hidden className={`link-hint ${pending ? 'is-pending' : ''}`} />
  )
}
```

Example 4 (python):
```python
import Link from 'next/link'
import LoadingIndicator from './components/loading-indicator'
 
const links = [
  { href: '/shop/electronics', label: 'Electronics' },
  { href: '/shop/clothing', label: 'Clothing' },
  { href: '/shop/books', label: 'Books' },
]
 
function Menubar() {
  return (
    <div>
      {links.map((link) => (
        <Link key={link.label} href={link.href}>
          <span className="label">{link.label}</span> <LoadingIndicator />
        </Link>
      ))}
    </div>
  )
}
 
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div>
      <Menubar />
      {children}
    </div>
  )
}
```

---

## turbopack

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopack

**Contents:**
- turbopack
- Reference
  - Options
  - Supported loaders
    - Missing Webpack loader features
- Examples
  - Root directory
  - Configuring webpack loaders
  - Advanced webpack loader conditions
  - Resolving aliases

The turbopack option lets you customize Turbopack to transform different files and change how modules are resolved.

Good to know: The turbopack option was previously named experimental.turbo in Next.js versions 13.0.0 to 15.2.x. The experimental.turbo option will be removed in Next.js 16.

If you are using an older version of Next.js, run npx @next/codemod@latest next-experimental-turbo-to-turbopack . to automatically migrate your configuration.

The following options are available for the turbopack configuration:

The following loaders have been tested to work with Turbopack's webpack loader implementation, but many other webpack loaders should work as well even if not listed here:

Turbopack uses the loader-runner library to execute webpack loaders, which provides most of the standard loader API. However, some features are not supported:

File system and output:

If you have a loader that is critically dependent upon one of these features please file an issue.

Turbopack uses the root directory to resolve modules. Files outside of the project root are not resolved.

Next.js automatically detects the root directory of your project. It does so by looking for one of these files:

If you have a different project structure, for example if you don't use workspaces, you can manually set the root option:

If you need loader support beyond what's built in, many webpack loaders already work with Turbopack. There are currently some limitations:

To configure loaders, add the names of the loaders you've installed and any options in next.config.js, mapping file extensions to a list of loaders. Rules are evaluated in order.

Here is an example below using the @svgr/webpack loader, which enables importing .svg files and rendering them as React components.

Good to know: Globs used in the rules object match based on file name, unless the glob contains a / character, which will cause it to match based on the full project-relative file path. Windows file paths are normalized to use unix-style / path separators.

Turbopack uses a modified version of the Rust globset library.

For loaders that require configuration options, you can use an object format instead of a string:

Good to know: Prior to Next.js version 13.4.4, turbopack.rules was named turbo.loaders and only accepted file extensions like .mdx instead of *.mdx.

You can further restrict where a loader runs using the advanced condition syntax:

In addition, a number of built-in conditions are supported:

Rules can be an object or an array of objects. An array is often useful for modeling disjoint conditions:

Good to know: All matching rules are executed in order.

Turbopack can be configured to modify module resolution through aliases, similar to webpack's resolve.alias configuration.

To configure resolve aliases, map imported patterns to their new destination in next.config.js:

This aliases imports of the underscore package to the lodash package. In other words, import underscore from 'underscore' will load the lodash module instead of underscore.

Turbopack also supports conditional aliasing through this field, similar to Node.js' conditional exports. At the moment only the browser condition is supported. In the case above, imports of the mocha module will be aliased to mocha/browser-entry.js when Turbopack targets browser environments.

Turbopack can be configured to resolve modules with custom extensions, similar to webpack's resolve.extensions configuration.

To configure resolve extensions, use the resolveExtensions field in next.config.js:

This overwrites the original resolve extensions with the provided list. Make sure to include the default extensions.

For more information and guidance for how to migrate your app to Turbopack from webpack, see Turbopack's documentation on webpack compatibility.

Turbopack can be configured to generate debug IDs in JavaScript bundles and source maps.

To configure debug IDs, use the debugIds field in next.config.js:

The option automatically adds a polyfill for debug IDs to the JavaScript bundle to ensure compatibility. The debug IDs are available in the globalThis._debugIds global variable.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  turbopack: {
    // ...
  },
}
 
export default nextConfig
```

Example 2 (javascript):
```javascript
const path = require('path')
module.exports = {
  turbopack: {
    root: path.join(__dirname, '..'),
  },
}
```

Example 3 (unknown):
```unknown
module.exports = {
  turbopack: {
    rules: {
      '*.svg': {
        loaders: ['@svgr/webpack'],
        as: '*.js',
      },
    },
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  turbopack: {
    rules: {
      '*.svg': {
        loaders: [
          {
            loader: '@svgr/webpack',
            options: {
              icon: true,
            },
          },
        ],
        as: '*.js',
      },
    },
  },
}
```

---

## NextResponse

**URL:** https://nextjs.org/docs/pages/api-reference/functions/next-response

**Contents:**
- NextResponse
- cookies
  - set(name, value)
  - get(name)
  - getAll()
  - delete(name)
- json()
- redirect()
- rewrite()
- next()

NextResponse extends the Web Response API with additional convenience methods.

Read or mutate the Set-Cookie header of the response.

Given a name, set a cookie with the given value on the response.

Given a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found, the first one is returned.

Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the response.

Given a cookie name, delete the cookie from the response.

Produce a response with the given JSON body.

Produce a response that redirects to a URL.

The URL can be created and modified before being used in the NextResponse.redirect() method. For example, you can use the request.nextUrl property to get the current URL, and then modify it to redirect to a different URL.

Produce a response that rewrites (proxies) the given URL while preserving the original URL.

The next() method is useful for Proxy, as it allows you to return early and continue routing.

You can also forward headers upstream when producing the response, using NextResponse.next({ request: { headers } }):

This forwards newHeaders upstream to the target page, route, or server action, and does not expose them to the client. While this pattern is useful for passing data upstream, it should be used with caution because the headers containing this data may be forwarded to external services.

In contrast, NextResponse.next({ headers }) is a shorthand for sending headers from proxy to the client. This is NOT good practice and should be avoided. Among other reasons because setting response headers like Content-Type, can override framework expectations (for example, the Content-Type used by Server Actions), leading to failed submissions or broken streaming responses.

In general, avoid copying all incoming request headers because doing so can leak sensitive data to clients or upstream services.

Prefer a defensive approach by creating a subset of incoming request headers using an allow-list. For example, you might discard custom x-* headers and only forward known-safe headers:

**Examples:**

Example 1 (javascript):
```javascript
// Given incoming request /home
let response = NextResponse.next()
// Set a cookie to hide the banner
response.cookies.set('show-banner', 'false')
// Response will have a `Set-Cookie:show-banner=false;path=/home` header
return response
```

Example 2 (javascript):
```javascript
// Given incoming request /home
let response = NextResponse.next()
// { name: 'show-banner', value: 'false', Path: '/home' }
response.cookies.get('show-banner')
```

Example 3 (javascript):
```javascript
// Given incoming request /home
let response = NextResponse.next()
// [
//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },
//   { name: 'experiments', value: 'winter-launch', Path: '/home' },
// ]
response.cookies.getAll('experiments')
// Alternatively, get all cookies for the response
response.cookies.getAll()
```

Example 4 (javascript):
```javascript
// Given incoming request /home
let response = NextResponse.next()
// Returns true for deleted, false if nothing is deleted
response.cookies.delete('experiments')
```

---

## cookies

**URL:** https://nextjs.org/docs/app/api-reference/functions/cookies

**Contents:**
- cookies
- Reference
  - Methods
  - Options
- Good to know
- Understanding Cookie Behavior in Server Components
- Understanding Cookie Behavior in Server Actions
- Examples
  - Getting a cookie
  - Getting all cookies

cookies is an async function that allows you to read the HTTP incoming request cookies in Server Components, and read/write outgoing request cookies in Server Actions or Route Handlers.

The following methods are available:

When setting a cookie, the following properties from the options object are supported:

The only option with a default value is path.

To learn more about these options, see the MDN docs.

When working with cookies in Server Components, it's important to understand that cookies are fundamentally a client-side storage mechanism:

The server can only send instructions (via Set-Cookie headers) to tell the browser to store cookies - the actual storage happens on the client side. This is why cookie operations that modify state (.set, .delete, .clear) must be performed in a Route Handler or Server Action where the response headers can be properly set.

After you set or delete a cookie in a Server Action, Next.js re-renders the current page and its layouts on the server so the UI reflects the new cookie value. See the Caching guide.

The UI is not unmounted, but effects that depend on data coming from the server will re-run.

To refresh cached data too, call revalidatePath or revalidateTag inside the action.

You can use the (await cookies()).get('name') method to get a single cookie:

You can use the (await cookies()).getAll() method to get all cookies with a matching name. If name is unspecified, it returns all the available cookies.

You can use the (await cookies()).set(name, value, options) method in a Server Action or Route Handler to set a cookie. The options object is optional.

You can use the (await cookies()).has(name) method to check if a cookie exists:

There are three ways you can delete a cookie.

Using the delete() method:

Setting a new cookie with the same name and an empty value:

Setting the maxAge to 0 will immediately expire a cookie. maxAge accepts a value in seconds.

**Examples:**

Example 1 (python):
```python
import { cookies } from 'next/headers'
 
export default async function Page() {
  const cookieStore = await cookies()
  const theme = cookieStore.get('theme')
  return '...'
}
```

Example 2 (python):
```python
import { cookies } from 'next/headers'
 
export default async function Page() {
  const cookieStore = await cookies()
  const theme = cookieStore.get('theme')
  return '...'
}
```

Example 3 (python):
```python
import { cookies } from 'next/headers'
 
export default async function Page() {
  const cookieStore = await cookies()
  return cookieStore.getAll().map((cookie) => (
    <div key={cookie.name}>
      <p>Name: {cookie.name}</p>
      <p>Value: {cookie.value}</p>
    </div>
  ))
}
```

Example 4 (python):
```python
'use server'
 
import { cookies } from 'next/headers'
 
export async function create(data) {
  const cookieStore = await cookies()
 
  cookieStore.set('name', 'lee')
  // or
  cookieStore.set('name', 'lee', { secure: true })
  // or
  cookieStore.set({
    name: 'name',
    value: 'lee',
    httpOnly: true,
    path: '/',
  })
}
```

---

## redirects

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/redirects

**Contents:**
- redirects
- Path Matching
  - Wildcard Path Matching
  - Regex Path Matching
- Header, Cookie, and Query Matching
  - Redirects with basePath support
  - Redirects with i18n support
- Other Redirects
- Version History

Redirects allow you to redirect an incoming request path to a different destination path.

To use redirects you can use the redirects key in next.config.js:

redirects is an async function that expects an array to be returned holding objects with source, destination, and permanent properties:

Why does Next.js use 307 and 308? Traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, but many browsers changed the request method of the redirect to GET, regardless of the original method. For example, if the browser made a request to POST /v1/users which returned status code 302 with location /v2/users, the subsequent request might be GET /v2/users instead of the expected POST /v2/users. Next.js uses the 307 temporary redirect, and 308 permanent redirect status codes to explicitly preserve the request method used.

Redirects are checked before the filesystem which includes pages and /public files.

When using the Pages Router, redirects are not applied to client-side routing (Link, router.push) unless Proxy is present and matches the path.

When a redirect is applied, any query values provided in the request will be passed through to the redirect destination. For example, see the following redirect configuration:

Good to know: Remember to include the forward slash / before the colon : in path parameters of the source and destination paths, otherwise the path will be treated as a literal string and you run the risk of causing infinite redirects.

When /old-blog/post-1?hello=world is requested, the client will be redirected to /blog/post-1?hello=world.

Path matches are allowed, for example /old-blog/:slug will match /old-blog/first-post (no nested paths):

The pattern /old-blog/:slug matches /old-blog/first-post and /old-blog/post-1 but not /old-blog/a/b (no nested paths). Patterns are anchored to the start: /old-blog/:slug will not match /archive/old-blog/first-post.

You can use modifiers on parameters: * (zero or more), + (one or more), ? (zero or one). For example, /blog/:slug* matches /blog, /blog/a, and /blog/a/b/c.

Read more details on path-to-regexp documentation.

To match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:

To match a regex path you can wrap the regex in parentheses after a parameter, for example /post/:slug(\\d{1,}) will match /post/123 but not /post/abc:

The following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\ before them:

To only match a redirect when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the redirect to be applied.

has and missing items can have the following fields:

When leveraging basePath support with redirects each source and destination is automatically prefixed with the basePath unless you add basePath: false to the redirect:

When implementing redirects with internationalization in the App Router, you can include locales in next.config.js redirects, but only as hardcoded paths.

For dynamic or per-request locale handling, use dynamic route segments and proxy, which can redirect based on the user's preferred language.

In some rare cases, you might need to assign a custom status code for older HTTP Clients to properly redirect. In these cases, you can use the statusCode property instead of the permanent property, but not both. To ensure IE11 compatibility, a Refresh header is automatically added for the 308 status code.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  async redirects() {
    return [
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
    ]
  },
}
```

Example 2 (unknown):
```unknown
{
  source: '/old-blog/:path*',
  destination: '/blog/:path*',
  permanent: false
}
```

Example 3 (unknown):
```unknown
module.exports = {
  async redirects() {
    return [
      {
        source: '/old-blog/:slug',
        destination: '/news/:slug', // Matched parameters can be used in the destination
        permanent: true,
      },
    ]
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  async redirects() {
    return [
      {
        source: '/blog/:slug*',
        destination: '/news/:slug*', // Matched parameters can be used in the destination
        permanent: true,
      },
    ]
  },
}
```

---

## How to set a Content Security Policy (CSP) for your Next.js application

**URL:** https://nextjs.org/docs/15/app/guides/content-security-policy

**Contents:**
- How to set a Content Security Policy (CSP) for your Next.js application
- Nonces
  - Why use a nonce?
  - Adding a nonce with Middleware
  - How nonces work in Next.js
  - Forcing dynamic rendering
  - Reading the nonce
- Static vs Dynamic Rendering with CSP
  - Dynamic Rendering Requirement
  - Performance Implications

Content Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks.

By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more.

A nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives.

CSP can block both inline and external scripts to prevent attacks. A nonce lets you safely allow specific scripts to runâ€”only if they include the matching nonce value.

If an attacker wanted to load a script into your page, they'd need to guess the nonce value. That's why the nonce must be unpredictable and unique for every request.

Middleware enables you to add headers and generate nonces before the page renders.

Every time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces.

By default, Middleware runs on all requests. You can filter Middleware to run on specific paths using a matcher.

We recommend ignoring matching prefetches (from next/link) and static assets that don't need the CSP header.

To use a nonce, your page must be dynamically rendered. This is because Next.js applies nonces during server-side rendering, based on the CSP header present in the request. Static pages are generated at build time, when no request or response headers existâ€”so no nonce can be injected.

Hereâ€™s how nonce support works in a dynamically rendered page:

Because of this automatic behavior, you donâ€™t need to manually add a nonce to each tag.

If you're using nonces, you may need to explicitly opt pages into dynamic rendering:

You can read the nonce from a Server Component using headers:

Using nonces has important implications for how your Next.js application renders:

When you use nonces in your CSP, all pages must be dynamically rendered. This means:

The shift from static to dynamic rendering affects performance:

Consider nonces when:

For applications that do not require nonces, you can set the CSP header directly in your next.config.js file:

As an alternative to nonces, Next.js offers experimental support for hash-based CSP using Subresource Integrity (SRI). This approach allows you to maintain static generation while still having a strict CSP.

Good to know: This feature is experimental and only available with webpack bundler in App Router applications.

Instead of using nonces, SRI generates cryptographic hashes of your JavaScript files at build time. These hashes are added as integrity attributes to script tags, allowing browsers to verify that files haven't been modified during transit.

Add the experimental SRI configuration to your next.config.js:

When SRI is enabled, you can continue using your existing CSP policies. SRI works independently by adding integrity attributes to your assets:

Good to know: For dynamic rendering scenarios, you can still generate nonces with middleware if needed, combining both SRI integrity attributes and nonce-based CSP approaches.

CSP implementation differs between development and production environments:

In development, you will need to enable 'unsafe-eval' to support APIs that provide additional debugging information:

Common issues in production:

When using third-party scripts with CSP:

Update your CSP to allow third-party domains:

**Examples:**

Example 1 (python):
```python
import { NextRequest, NextResponse } from 'next/server'
 
export function middleware(request: NextRequest) {
  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')
  const cspHeader = `
    default-src 'self';
    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';
    style-src 'self' 'nonce-${nonce}';
    img-src 'self' blob: data:;
    font-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
`
  // Replace newline characters and spaces
  const contentSecurityPolicyHeaderValue = cspHeader
    .replace(/\s{2,}/g, ' ')
    .trim()
 
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-nonce', nonce)
 
  requestHeaders.set(
    'Content-Security-Policy',
    contentSecurityPolicyHeaderValue
  )
 
  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })
  response.headers.set(
    'Content-Security-Policy',
    contentSecurityPolicyHeaderValue
  )
 
  return response
}
```

Example 2 (javascript):
```javascript
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    {
      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',
      missing: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },
  ],
}
```

Example 3 (python):
```python
import { connection } from 'next/server'
 
export default async function Page() {
  // wait for an incoming request to render this page
  await connection()
  // Your page content
}
```

Example 4 (python):
```python
import { headers } from 'next/headers'
import Script from 'next/script'
 
export default async function Page() {
  const nonce = (await headers()).get('x-nonce')
 
  return (
    <Script
      src="https://www.googletagmanager.com/gtag/js"
      strategy="afterInteractive"
      nonce={nonce}
    />
  )
}
```

---

## getStaticPaths

**URL:** https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-paths

**Contents:**
- getStaticPaths
- When should I use getStaticPaths?
- When does getStaticPaths run
  - How does getStaticProps run with regards to getStaticPaths
- Where can I use getStaticPaths
- Runs on every request in development
- Generating paths on-demand

If a page has Dynamic Routes and uses getStaticProps, it needs to define a list of paths to be statically generated.

When you export a function called getStaticPaths (Static Site Generation) from a page that uses dynamic routes, Next.js will statically pre-render all the paths specified by getStaticPaths.

The getStaticPaths API reference covers all parameters and props that can be used with getStaticPaths.

You should use getStaticPaths if youâ€™re statically pre-rendering pages that use dynamic routes and:

getStaticPaths will only run during build in production, it will not be called during runtime. You can validate code written inside getStaticPaths is removed from the client-side bundle with this tool.

In development (next dev), getStaticPaths will be called on every request.

getStaticPaths allows you to control which pages are generated during the build instead of on-demand with fallback. Generating more pages during a build will cause slower builds.

You can defer generating all pages on-demand by returning an empty array for paths. This can be especially helpful when deploying your Next.js application to multiple environments. For example, you can have faster builds by generating all pages on-demand for previews (but not production builds). This is helpful for sites with hundreds/thousands of static pages.

**Examples:**

Example 1 (python):
```python
import type {
  InferGetStaticPropsType,
  GetStaticProps,
  GetStaticPaths,
} from 'next'
 
type Repo = {
  name: string
  stargazers_count: number
}
 
export const getStaticPaths = (async () => {
  return {
    paths: [
      {
        params: {
          name: 'next.js',
        },
      }, // See the "paths" section below
    ],
    fallback: true, // false or "blocking"
  }
}) satisfies GetStaticPaths
 
export const getStaticProps = (async (context) => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo = await res.json()
  return { props: { repo } }
}) satisfies GetStaticProps<{
  repo: Repo
}>
 
export default function Page({
  repo,
}: InferGetStaticPropsType<typeof getStaticProps>) {
  return repo.stargazers_count
}
```

Example 2 (javascript):
```javascript
export async function getStaticPaths() {
  // When this is true (in preview environments) don't
  // prerender any static pages
  // (faster builds, but slower initial page load)
  if (process.env.SKIP_BUILD_STATIC_GENERATION) {
    return {
      paths: [],
      fallback: 'blocking',
    }
  }
 
  // Call an external API endpoint to get posts
  const res = await fetch('https://.../posts')
  const posts = await res.json()
 
  // Get the paths we want to prerender based on posts
  // In production environments, prerender all pages
  // (slower builds, but faster initial page load)
  const paths = posts.map((post) => ({
    params: { id: post.id },
  }))
 
  // { fallback: false } means other routes should 404
  return { paths, fallback: false }
}
```

---

## How to build a Progressive Web Application (PWA) with Next.js

**URL:** https://nextjs.org/docs/app/guides/progressive-web-apps

**Contents:**
- How to build a Progressive Web Application (PWA) with Next.js
- Creating a PWA with Next.js
  - 1. Creating the Web App Manifest
  - 2. Implementing Web Push Notifications
  - 3. Implementing Server Actions
  - 4. Generating VAPID Keys
  - 5. Creating a Service Worker
  - 6. Adding to Home Screen
  - 7. Testing Locally
  - 8. Securing your application

Progressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that provide a seamless, app-like experience across all platforms without the need for multiple codebases or app store approvals.

Next.js provides built-in support for creating a web app manifest using the App Router. You can create either a static or dynamic manifest file:

For example, create a app/manifest.ts or app/manifest.json file:

This file should contain information about the name, icons, and how it should be displayed as an icon on the user's device. This will allow users to install your PWA on their home screen, providing a native app-like experience.

You can use tools like favicon generators to create the different icon sets and place the generated files in your public/ folder.

Web Push Notifications are supported with all modern browsers, including:

This makes PWAs a viable alternative to native apps. Notably, you can trigger install prompts without needing offline support.

Web Push Notifications allow you to re-engage users even when they're not actively using your app. Here's how to implement them in a Next.js application:

First, let's create the main page component in app/page.tsx. We'll break it down into smaller parts for better understanding. First, weâ€™ll add some of the imports and utilities weâ€™ll need. Itâ€™s okay that the referenced Server Actions do not yet exist:

Letâ€™s now add a component to manage subscribing, unsubscribing, and sending push notifications.

Finally, letâ€™s create a component to show a message for iOS devices to instruct them to install to their home screen, and only show this if the app is not already installed.

Now, letâ€™s create the Server Actions which this file calls.

Create a new file to contain your actions at app/actions.ts. This file will handle creating subscriptions, deleting subscriptions, and sending notifications.

Sending a notification will be handled by our service worker, created in step 5.

In a production environment, you would want to store the subscription in a database for persistence across server restarts and to manage multiple users' subscriptions.

To use the Web Push API, you need to generate VAPID keys. The simplest way is to use the web-push CLI directly:

First, install web-push globally:

Generate the VAPID keys by running:

Copy the output and paste the keys into your .env file:

Create a public/sw.js file for your service worker:

This service worker supports custom images and notifications. It handles incoming push events and notification clicks.

Remember to test your service worker thoroughly to ensure it behaves as expected across different devices and browsers. Also, make sure to update the 'https://your-website.com' link in the notificationclick event listener to the appropriate URL for your application.

The InstallPrompt component defined in step 2 shows a message for iOS devices to instruct them to install to their home screen.

To ensure your application can be installed to a mobile home screen, you must have:

Modern browsers will automatically show an installation prompt to users when these criteria are met. You can provide a custom installation button with beforeinstallprompt, however, we do not recommend this as it is not cross browser and platform (does not work on Safari iOS).

To ensure you can view notifications locally, ensure that:

Security is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using the next.config.js file. For example:

Letâ€™s go over each of these options:

Learn more about defining Content Security Policies with Next.js.

**Examples:**

Example 1 (python):
```python
import type { MetadataRoute } from 'next'
 
export default function manifest(): MetadataRoute.Manifest {
  return {
    name: 'Next.js PWA',
    short_name: 'NextPWA',
    description: 'A Progressive Web App built with Next.js',
    start_url: '/',
    display: 'standalone',
    background_color: '#ffffff',
    theme_color: '#000000',
    icons: [
      {
        src: '/icon-192x192.png',
        sizes: '192x192',
        type: 'image/png',
      },
      {
        src: '/icon-512x512.png',
        sizes: '512x512',
        type: 'image/png',
      },
    ],
  }
}
```

Example 2 (python):
```python
'use client'
 
import { useState, useEffect } from 'react'
import { subscribeUser, unsubscribeUser, sendNotification } from './actions'
 
function urlBase64ToUint8Array(base64String: string) {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/')
 
  const rawData = window.atob(base64)
  const outputArray = new Uint8Array(rawData.length)
 
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i)
  }
  return outputArray
}
```

Example 3 (javascript):
```javascript
function PushNotificationManager() {
  const [isSupported, setIsSupported] = useState(false)
  const [subscription, setSubscription] = useState<PushSubscription | null>(
    null
  )
  const [message, setMessage] = useState('')
 
  useEffect(() => {
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      setIsSupported(true)
      registerServiceWorker()
    }
  }, [])
 
  async function registerServiceWorker() {
    const registration = await navigator.serviceWorker.register('/sw.js', {
      scope: '/',
      updateViaCache: 'none',
    })
    const sub = await registration.pushManager.getSubscription()
    setSubscription(sub)
  }
 
  async function subscribeToPush() {
    const registration = await navigator.serviceWorker.ready
    const sub = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(
        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!
      ),
    })
    setSubscription(sub)
    const serializedSub = JSON.parse(JSON.stringify(sub))
    await subscribeUser(serializedSub)
  }
 
  async function unsubscribeFromPush() {
    await subscription?.unsubscribe()
    setSubscription(null)
    await unsubscribeUser()
  }
 
  async function sendTestNotification() {
    if (subscription) {
      await sendNotification(message)
      setMessage('')
    }
  }
 
  if (!isSupported) {
    return <p>Push notifications are not supported in this browser.</p>
  }
 
  return (
    <div>
      <h3>Push Notifications</h3>
      {subscription ? (
        <>
          <p>You are subscribed to push notifications.</p>
          <button onClick={unsubscribeFromPush}>Unsubscribe</button>
          <input
            type="text"
            placeholder="Enter notification message"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
          />
          <button onClick={sendTestNotification}>Send Test</button>
        </>
      ) : (
        <>
          <p>You are not subscribed to push notifications.</p>
          <button onClick={subscribeToPush}>Subscribe</button>
        </>
      )}
    </div>
  )
}
```

Example 4 (javascript):
```javascript
function InstallPrompt() {
  const [isIOS, setIsIOS] = useState(false)
  const [isStandalone, setIsStandalone] = useState(false)
 
  useEffect(() => {
    setIsIOS(
      /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream
    )
 
    setIsStandalone(window.matchMedia('(display-mode: standalone)').matches)
  }, [])
 
  if (isStandalone) {
    return null // Don't show install button if already installed
  }
 
  return (
    <div>
      <h3>Install App</h3>
      <button>Add to Home Screen</button>
      {isIOS && (
        <p>
          To install this app on your iOS device, tap the share button
          <span role="img" aria-label="share icon">
            {' '}
            âŽ‹{' '}
          </span>
          and then "Add to Home Screen"
          <span role="img" aria-label="plus icon">
            {' '}
            âž•{' '}
          </span>
          .
        </p>
      )}
    </div>
  )
}
 
export default function Page() {
  return (
    <div>
      <PushNotificationManager />
      <InstallPrompt />
    </div>
  )
}
```

---

## Script

**URL:** https://nextjs.org/docs/pages/api-reference/components/script

**Contents:**
- Script
- Props
- Required Props
  - src
- Optional Props
  - strategy
  - beforeInteractive
  - afterInteractive
  - lazyOnload
  - worker

This API reference will help you understand how to use props available for the Script Component. For features and usage, please see the Optimizing Scripts page.

Here's a summary of the props available for the Script Component:

The <Script /> component requires the following properties.

A path string specifying the URL of an external script. This can be either an absolute external URL or an internal path. The src property is required unless an inline script is used.

The <Script /> component accepts a number of additional properties beyond those which are required.

The loading strategy of the script. There are four different strategies that can be used:

Scripts that load with the beforeInteractive strategy are injected into the initial HTML from the server, downloaded before any Next.js module, and executed in the order they are placed.

Scripts denoted with this strategy are preloaded and fetched before any first-party code, but their execution does not block page hydration from occurring.

beforeInteractive scripts must be placed inside the Document Component (pages/_document.js) and are designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side).

This strategy should only be used for critical scripts that need to be fetched as soon as possible.

Good to know: Scripts with beforeInteractive will always be injected inside the head of the HTML document regardless of where it's placed in the component.

Some examples of scripts that should be fetched as soon as possible with beforeInteractive include:

Scripts that use the afterInteractive strategy are injected into the HTML client-side and will load after some (or all) hydration occurs on the page. This is the default strategy of the Script component and should be used for any script that needs to load as soon as possible but not before any first-party Next.js code.

afterInteractive scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.

Some examples of scripts that are good candidates for afterInteractive include:

Scripts that use the lazyOnload strategy are injected into the HTML client-side during browser idle time and will load after all resources on the page have been fetched. This strategy should be used for any background or low priority scripts that do not need to load early.

lazyOnload scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.

Examples of scripts that do not need to load immediately and can be fetched with lazyOnload include:

Warning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution.

Scripts that use the worker strategy are off-loaded to a web worker in order to free up the main thread and ensure that only critical, first-party resources are processed on it. While this strategy can be used for any script, it is an advanced use case that is not guaranteed to support all third-party scripts.

To use worker as a strategy, the nextScriptWorkers flag must be enabled in next.config.js:

worker scripts can only currently be used in the pages/ directory:

Warning: onLoad does not yet work with Server Components and can only be used in Client Components. Further, onLoad can't be used with beforeInteractive â€“ consider using onReady instead.

Some third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or call a function. If you are loading a script with either afterInteractive or lazyOnload as a loading strategy, you can execute code after it has loaded using the onLoad property.

Here's an example of executing a lodash method only after the library has been loaded.

Warning: onReady does not yet work with Server Components and can only be used in Client Components.

Some third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is mounted (after a route navigation for example). You can execute code after the script's load event when it first loads and then after every subsequent component re-mount using the onReady property.

Here's an example of how to re-instantiate a Google Maps JS embed every time the component is mounted:

Warning: onError does not yet work with Server Components and can only be used in Client Components. onError cannot be used with the beforeInteractive loading strategy.

Sometimes it is helpful to catch when a script fails to load. These errors can be handled with the onError property:

**Examples:**

Example 1 (python):
```python
import Script from 'next/script'
 
export default function Dashboard() {
  return (
    <>
      <Script src="https://example.com/script.js" />
    </>
  )
}
```

Example 2 (python):
```python
import { Html, Head, Main, NextScript } from 'next/document'
import Script from 'next/script'
 
export default function Document() {
  return (
    <Html>
      <Head />
      <body>
        <Main />
        <NextScript />
        <Script
          src="https://example.com/script.js"
          strategy="beforeInteractive"
        />
      </body>
    </Html>
  )
}
```

Example 3 (python):
```python
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="afterInteractive" />
    </>
  )
}
```

Example 4 (python):
```python
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="lazyOnload" />
    </>
  )
}
```

---

## Proxy

**URL:** https://nextjs.org/docs/pages/api-reference/file-conventions/proxy

**Contents:**
- Proxy
- Exports
  - Proxy function
  - Config object (optional)
  - Matcher
- Params
  - request
- NextResponse
- Execution order
- Runtime

Note: The middleware file convention is deprecated and has been renamed to proxy. See Migration to Proxy for more details.

The proxy.js|ts file is used to write Proxy and run code on the server before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.

Proxy executes before routes are rendered. It's particularly useful for implementing custom server-side logic like authentication, logging, or handling redirects.

Proxy is meant to be invoked separately of your render code and in optimized cases deployed to your CDN for fast redirect/rewrite handling, you should not attempt relying on shared modules or globals.

To pass information from Proxy to your application, use headers, cookies, rewrites, redirects, or the URL.

Create a proxy.ts (or .js) file in the project root, or inside src if applicable, so that it is located at the same level as pages or app.

If youâ€™ve customized pageExtensions, for example to .page.ts or .page.js, name your file proxy.page.ts or proxy.page.js accordingly.

The file must export a single function, either as a default export or named proxy. Note that multiple proxy from the same file are not supported.

Optionally, a config object can be exported alongside the Proxy function. This object includes the matcher to specify paths where the Proxy applies.

The matcher option allows you to target specific paths for the Proxy to run on. You can specify these paths in several ways:

Additionally, the matcher option supports complex path specifications using regular expressions. For example, you can exclude certain paths with a regular expression matcher:

This enables precise control over which paths to include or exclude.

The matcher option accepts an array of objects with the following keys:

Read more details on path-to-regexp documentation.

When defining Proxy, the default export function accepts a single parameter, request. This parameter is an instance of NextRequest, which represents the incoming HTTP request.

The NextResponse API allows you to:

To produce a response from Proxy, you can:

Proxy will be invoked for every route in your project. Given this, it's crucial to use matchers to precisely target or exclude specific routes. The following is the execution order:

Proxy defaults to using the Node.js runtime. The runtime config option is not available in Proxy files. Setting the runtime config option in Proxy will throw an error.

In v13.1 of Next.js two additional flags were introduced for proxy, skipMiddlewareUrlNormalize and skipTrailingSlashRedirect to handle advanced use cases.

skipTrailingSlashRedirect disables Next.js redirects for adding or removing trailing slashes. This allows custom handling inside proxy to maintain the trailing slash for some paths but not others, which can make incremental migrations easier.

skipMiddlewareUrlNormalize allows for disabling the URL normalization in Next.js to make handling direct visits and client-transitions the same. In some advanced cases, this option provides full control by using the original URL.

Cookies are regular headers. On a Request, they are stored in the Cookie header. On a Response they are in the Set-Cookie header. Next.js provides a convenient way to access and manipulate these cookies through the cookies extension on NextRequest and NextResponse.

You can set request and response headers using the NextResponse API (setting request headers is available since Next.js v13.0.0).

Note that the snippet uses:

Learn more in NextResponse headers in Proxy.

Good to know: Avoid setting large headers as it might cause 431 Request Header Fields Too Large error depending on your backend web server configuration.

You can set CORS headers in Proxy to allow cross-origin requests, including simple and preflighted requests.

You can respond from Proxy directly by returning a Response or NextResponse instance. (This is available since Next.js v13.1.0)

The matcher config allows full regex so matching like negative lookaheads or character matching is supported. An example of a negative lookahead to match all except specific paths can be seen here:

You can also bypass Proxy for certain requests by using the missing or has arrays, or a combination of both:

Even when _next/data is excluded in a negative matcher pattern, proxy will still be invoked for _next/data routes. This is intentional behavior to prevent accidental security issues where you might protect a page but forget to protect the corresponding data route.

The NextFetchEvent object extends the native FetchEvent object, and includes the waitUntil() method.

The waitUntil() method takes a promise as an argument, and extends the lifetime of the Proxy until the promise settles. This is useful for performing work in the background.

Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test proxy files. Unit testing proxy can help ensure that it's only run on desired paths and that custom routing logic works as intended before code reaches production.

The unstable_doesProxyMatch function can be used to assert whether proxy will run for the provided URL, headers, and cookies.

The entire proxy function can also be tested.

Learn how to configure Proxy when self-hosting Next.js.

The reason behind the renaming of middleware is that the term "middleware" can often be confused with Express.js middleware, leading to a misinterpretation of its purpose. Also, Middleware is highly capable, so it may encourage the usage; however, this feature is recommended to be used as a last resort.

Next.js is moving forward to provide better APIs with better ergonomics so that developers can achieve their goals without Middleware. This is the reason behind the renaming of middleware.

The name Proxy clarifies what Middleware is capable of. The term "proxy" implies that it has a network boundary in front of the app, which is the behavior of Middleware. Also, Middleware defaults to run at the Edge Runtime, which can run closer to the client, separated from the app's region. These behaviors align better with the term "proxy" and provide a clearer purpose of the feature.

We recommend users avoid relying on Middleware unless no other options exist. Our goal is to give them APIs with better ergonomics so they can achieve their goals without Middleware.

The term â€œmiddlewareâ€ often confuses users with Express.js middleware, which can encourage misuse. To clarify our direction, we are renaming the file convention to â€œproxy.â€ This highlights that we are moving away from Middleware, breaking down its overloaded features, and making the Proxy clear in its purpose.

Next.js provides a codemod to migrate from middleware.ts to proxy.ts. You can run the following command to migrate:

The codemod will rename the file and the function name from middleware to proxy.

**Examples:**

Example 1 (python):
```python
import { NextResponse, NextRequest } from 'next/server'
 
// This function can be marked `async` if using `await` inside
export function proxy(request: NextRequest) {
  return NextResponse.redirect(new URL('/home', request.url))
}
 
export const config = {
  matcher: '/about/:path*',
}
```

Example 2 (unknown):
```unknown
// Example of default export
export default function proxy(request) {
  // Proxy logic
}
```

Example 3 (javascript):
```javascript
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
}
```

Example 4 (javascript):
```javascript
export const config = {
  matcher: [
    // Exclude API routes, static files, image optimizations, and .png files
    '/((?!api|_next/static|_next/image|.*\\.png$).*)',
  ],
}
```

---

## NextResponse

**URL:** https://nextjs.org/docs/app/api-reference/functions/next-response

**Contents:**
- NextResponse
- cookies
  - set(name, value)
  - get(name)
  - getAll()
  - delete(name)
- json()
- redirect()
- rewrite()
- next()

NextResponse extends the Web Response API with additional convenience methods.

Read or mutate the Set-Cookie header of the response.

Given a name, set a cookie with the given value on the response.

Given a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found, the first one is returned.

Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the response.

Given a cookie name, delete the cookie from the response.

Produce a response with the given JSON body.

Produce a response that redirects to a URL.

The URL can be created and modified before being used in the NextResponse.redirect() method. For example, you can use the request.nextUrl property to get the current URL, and then modify it to redirect to a different URL.

Produce a response that rewrites (proxies) the given URL while preserving the original URL.

The next() method is useful for Proxy, as it allows you to return early and continue routing.

You can also forward headers upstream when producing the response, using NextResponse.next({ request: { headers } }):

This forwards newHeaders upstream to the target page, route, or server action, and does not expose them to the client. While this pattern is useful for passing data upstream, it should be used with caution because the headers containing this data may be forwarded to external services.

In contrast, NextResponse.next({ headers }) is a shorthand for sending headers from proxy to the client. This is NOT good practice and should be avoided. Among other reasons because setting response headers like Content-Type, can override framework expectations (for example, the Content-Type used by Server Actions), leading to failed submissions or broken streaming responses.

In general, avoid copying all incoming request headers because doing so can leak sensitive data to clients or upstream services.

Prefer a defensive approach by creating a subset of incoming request headers using an allow-list. For example, you might discard custom x-* headers and only forward known-safe headers:

**Examples:**

Example 1 (javascript):
```javascript
// Given incoming request /home
let response = NextResponse.next()
// Set a cookie to hide the banner
response.cookies.set('show-banner', 'false')
// Response will have a `Set-Cookie:show-banner=false;path=/home` header
return response
```

Example 2 (javascript):
```javascript
// Given incoming request /home
let response = NextResponse.next()
// { name: 'show-banner', value: 'false', Path: '/home' }
response.cookies.get('show-banner')
```

Example 3 (javascript):
```javascript
// Given incoming request /home
let response = NextResponse.next()
// [
//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },
//   { name: 'experiments', value: 'winter-launch', Path: '/home' },
// ]
response.cookies.getAll('experiments')
// Alternatively, get all cookies for the response
response.cookies.getAll()
```

Example 4 (javascript):
```javascript
// Given incoming request /home
let response = NextResponse.next()
// Returns true for deleted, false if nothing is deleted
response.cookies.delete('experiments')
```

---

## mdxRs

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/mdxRs

**Contents:**
- mdxRs

For experimental use with @next/mdx. Compiles MDX files using the new Rust compiler.

**Examples:**

Example 1 (javascript):
```javascript
const withMDX = require('@next/mdx')()
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['ts', 'tsx', 'mdx'],
  experimental: {
    mdxRs: true,
  },
}
 
module.exports = withMDX(nextConfig)
```

---

## Image

**URL:** https://nextjs.org/docs/pages/api-reference/components/image

**Contents:**
- Image
- Reference
  - Props
    - src
    - alt
    - width and height
    - fill
    - loader
    - sizes
    - quality

The Next.js Image component extends the HTML <img> element for automatic image optimization.

Good to know: If you are using a version of Next.js prior to 13, you'll want to use the next/legacy/image documentation since the component was renamed.

The following props are available:

The source of the image. Can be one of the following:

An internal path string.

An absolute external URL (must be configured with remotePatterns).

Good to know: For security reasons, the Image Optimization API using the default loader will not forward headers when fetching the src image. If the src image requires authentication, consider using the unoptimized property to disable Image Optimization.

The alt property is used to describe the image for screen readers and search engines. It is also the fallback text if images have been disabled or an error occurs while loading the image.

It should contain text that could replace the image without changing the meaning of the page. It is not meant to supplement the image and should not repeat information that is already provided in the captions above or below the image.

If the image is purely decorative or not intended for the user, the alt property should be an empty string (alt="").

Learn more about image accessibility guidelines.

The width and height properties represent the intrinsic image size in pixels. This property is used to infer the correct aspect ratio used by browsers to reserve space for the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS.

You must set both width and height properties unless:

If the height and width are unknown, we recommend using the fill property.

A boolean that causes the image to expand to the size of the parent element.

If no styles are applied to the image, the image will stretch to fit the container. You can use objectFit to control cropping and scaling.

Learn more about position and object-fit.

A custom function used to generate the image URL. The function receives the following parameters, and returns a URL string for the image:

Alternatively, you can use the loaderFile configuration in next.config.js to configure every instance of next/image in your application, without passing a prop.

Define the sizes of the image at different breakpoints. Used by the browser to choose the most appropriate size from the generated srcset.

sizes should be used when:

If sizes is missing, the browser assumes the image will be as wide as the viewport (100vw). This can cause unnecessarily large images to be downloaded.

In addition, sizes affects how srcset is generated:

Learn more about srcset and sizes on web.dev and mdn.

An integer between 1 and 100 that sets the quality of the optimized image. Higher values increase file size and visual fidelity. Lower values reduce file size but may affect sharpness.

If youâ€™ve configured qualities in next.config.js, the value must match one of the allowed entries.

Good to know: If the original image is already low quality, setting a high quality value will increase the file size without improving appearance.

Allows passing CSS styles to the underlying image element.

Good to know: If youâ€™re using the style prop to set a custom width, be sure to also set height: 'auto' to preserve the imageâ€™s aspect ratio.

A boolean that indicates if the image should be preloaded.

In most cases, you should use loading="eager" or fetchPriority="high" instead of preload.

Starting with Next.js 16, the priority property has been deprecated in favor of the preload property in order to make the behavior clear.

Controls when the image should start loading.

Use eager only when you want to ensure the image is loaded immediately.

Learn more about the loading attribute.

Specifies a placeholder to use while the image is loading, improving the perceived loading performance.

Learn more about the placeholder attribute.

A Data URL to be used as a placeholder image before the image successfully loads. Can be automatically set or used with the placeholder="blur" property.

The image is automatically enlarged and blurred, so a very small image (10px or less) is recommended.

If src is a static import of a jpg, png, webp, or avif file, blurDataURL is added automaticallyâ€”unless the image is animated.

If the image is dynamic or remote, you must provide blurDataURL yourself. To generate one, you can use:

A large blurDataURL may hurt performance. Keep it small and simple.

A callback function that is invoked once the image is completely loaded and the placeholder has been removed.

The callback function will be called with one argument, the event which has a target that references the underlying <img> element.

A callback function that is invoked if the image fails to load.

A boolean that indicates if the image should be optimized. This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).

Since Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration:

When providing the src prop to the <Image> component, both the srcset and src attributes are generated automatically for the resulting <img>.

In some cases, it is not desirable to have the src attribute generated and you may wish to override it using the overrideSrc prop.

For example, when upgrading an existing website from <img> to <Image>, you may wish to maintain the same src attribute for SEO purposes such as image ranking or avoiding recrawl.

A hint to the browser indicating if it should wait for the image to be decoded before presenting other content updates or not.

Learn more about the decoding attribute.

Other properties on the <Image /> component will be passed to the underlying img element with the exception of the following:

Warning: Deprecated in Next.js 14, use onLoad instead.

A callback function that is invoked once the image is completely loaded and the placeholder has been removed.

The callback function will be called with one argument, a reference to the underlying <img> element.

You can configure the Image Component in next.config.js. The following options are available:

Use localPatterns in your next.config.js file to allow images from specific local paths to be optimized and block all others.

The example above will ensure the src property of next/image must start with /assets/images/ and must not have a query string. Attempting to optimize any other path will respond with 400 Bad Request error.

Good to know: Omitting the search property allows all search parameters which could allow malicious actors to optimize URLs you did not intend. Try using a specific value like search: '?v=2' to ensure an exact match.

Use remotePatterns in your next.config.js file to allow images from specific external paths and block all others. This ensures that only external images from your account can be served.

You can also configure remotePatterns using the object:

The example above will ensure the src property of next/image must start with https://example.com/account123/ and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.

Wildcard patterns can be used for both pathname and hostname and have the following syntax:

This allows subdomains like image.example.com. Query strings and custom ports are still blocked.

Good to know: When omitting protocol, port, pathname, or search then the wildcard ** is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.

You can also restrict query strings using the search property:

The example above will ensure the src property of next/image must start with https://assets.example.com and must have the exact query string ?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request.

loaderFiles allows you to use a custom image optimization service instead of Next.js.

The path must be relative to the project root. The file must export a default function that returns a URL string:

Alternatively, you can use the loader prop to configure each instance of next/image.

If you want to change or prefix the default path for the Image Optimization API, you can do so with the path property. The default value for path is /_next/image.

deviceSizes allows you to specify a list of device width breakpoints. These widths are used when the next/image component uses sizes prop to ensure the correct image is served for the user's device.

If no configuration is provided, the default below is used:

imageSizes allows you to specify a list of image widths. These widths are concatenated with the array of device sizes to form the full array of sizes used to generate image srcset.

If no configuration is provided, the default below is used:

imageSizes is only used for images which provide a sizes prop, which indicates that the image is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.

qualities allows you to specify a list of image quality values.

If not configuration is provided, the default below is used:

Good to know: This field is required starting with Next.js 16 because unrestricted access could allow malicious actors to optimize more qualities than you intended.

You can add more image qualities to the allowlist, such as the following:

In the example above, only four qualities are allowed: 25, 50, 75, and 100.

If the quality prop does not match a value in this array, the closest allowed value will be used.

If the REST API is visited directly with a quality that does not match a value in this array, the server will return a 400 Bad Request response.

formats allows you to specify a list of image formats to be used.

Next.js automatically detects the browser's supported image formats via the request's Accept header in order to determine the best output format.

If the Accept header matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image is animated), it will use the original image's format.

You can enable AVIF support, which will fallback to the original format of the src image if the browser does not support AVIF:

minimumCacheTTL allows you to configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use a Static Image Import which will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable.

If no configuration is provided, the default below is used.

You can increase the TTL to reduce the number of revalidations and potentially lower cost:

The expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-Control header, whichever is larger.

If you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream image (e.g. /some-asset.jpg, not /_next/image itself).

There is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to manually change the src prop or delete the cached file <distDir>/cache/images.

disableStaticImages allows you to disable static image imports.

The default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src property. In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.

You can disable static image imports inside your next.config.js:

The default image optimization loader will follow HTTP redirects when fetching remote images up to 3 times.

You can configure the number of redirects to follow when fetching remote images. Setting the value to 0 will disable following redirects.

In rare cases when self-hosting Next.js on a private network, you may want to allow optimizing images from local IP addresses on the same network. This is not recommended for most users because it could allow malicious users to access content on your internal network.

By default, the value is false.

If you need to optimize remote images hosted elsewhere in your local network, you can set the value to true.

dangerouslyAllowSVG allows you to serve SVG images.

By default, Next.js does not optimize SVG images for a few reasons:

We recommend using the unoptimized prop when the src prop is known to be SVG. This happens automatically when src ends with ".svg".

In addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as contentSecurityPolicy to prevent scripts embedded in the image from executing.

contentDispositionType allows you to configure the Content-Disposition header.

contentSecurityPolicy allows you to configure the Content-Security-Policy header for images. This is particularly important when using dangerouslyAllowSVG to prevent scripts embedded in the image from executing.

By default, the loader sets the Content-Disposition header to attachment for added protection since the API can serve arbitrary remote images.

The default value is attachment which forces the browser to download the image when visiting directly. This is particularly important when dangerouslyAllowSVG is true.

You can optionally configure inline to allow the browser to render the image when visiting directly, without downloading it.

Warning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious users.

Similar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images. However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.

Since most remote image servers are shared between multiple tenants, it's safer to use remotePatterns to ensure only the intended images are optimized.

Below is an example of the domains property in the next.config.js file:

The getImageProps function can be used to get the props that would be passed to the underlying <img> element, and instead pass them to another component, style, canvas, etc.

This also avoid calling React useState() so it can lead to better performance, but it cannot be used with the placeholder prop because the placeholder will never be removed.

This next/image component uses browser native lazy loading, which may fallback to eager loading for older browsers before Safari 15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles with width/height of auto, it is possible to cause Layout Shift on older browsers before Safari 15 that don't preserve the aspect ratio. For more details, see this MDN video.

Styling the Image component is similar to styling a normal <img> element, but there are a few guidelines to keep in mind:

Use className or style, not styled-jsx. In most cases, we recommend using the className prop. This can be an imported CSS Module, a global stylesheet, etc.

You can also use the style prop to assign inline styles.

When using fill, the parent element must have position: relative or display: block. This is necessary for the proper rendering of the image element in that layout mode.

You cannot use styled-jsx because it's scoped to the current component (unless you mark the style as global).

When you import a static image, Next.js automatically sets its width and height based on the file. You can make the image responsive by setting the style:

If the source image is a dynamic or a remote URL, you must provide the width and height props so Next.js can calculate the aspect ratio:

If you don't know the aspect ratio of the image, you can add the fill prop with the objectFit prop set to cover. This will make the image fill the full width of its parent container.

Use the fill prop to make the image cover the entire screen area:

For examples of the Image component used with the various styles, see the Image Component Demo.

To use a remote image, the src property should be a URL string.

Since Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually.

The width and height attributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. The width and height do not determine the rendered size of the image file.

To safely allow optimizing images, define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:

If you want to display a different image for light and dark mode, you can create a new component that wraps two <Image> components and reveals the correct one based on a CSS media query.

Good to know: The default behavior of loading="lazy" ensures that only the correct image is loaded. You cannot use preload or loading="eager" because that would cause both images to load. Instead, you can use fetchPriority="high".

If you want to display a different image for mobile and desktop, sometimes called Art Direction, you can provide different src, width, height, and quality props to getImageProps().

You can even convert the srcSet string to the image-set() CSS function to optimize a background image.

**Examples:**

Example 1 (python):
```python
import Image from 'next/image'
 
export default function Page() {
  return (
    <Image
      src="/profile.png"
      width={500}
      height={500}
      alt="Picture of the author"
    />
  )
}
```

Example 2 (unknown):
```unknown
<Image src="/profile.png" />
```

Example 3 (unknown):
```unknown
<Image src="https://example.com/profile.png" />
```

Example 4 (python):
```python
import profile from './profile.png'
 
export default function Page() {
  return <Image src={profile} />
}
```

---

## CLI

**URL:** https://nextjs.org/docs/pages/api-reference/cli

**Contents:**
- CLI
  - create-next-app CLI
  - next CLI

Next.js comes with two Command Line Interface (CLI) tools:

---

## How to migrate from Vite to Next.js

**URL:** https://nextjs.org/docs/pages/guides/migrating/from-vite

**Contents:**
- How to migrate from Vite to Next.js
- Why Switch?
  - Slow initial page loading time
  - No automatic code splitting
  - Network waterfalls
  - Fast and intentional loading states
  - Choose the data fetching strategy
  - Proxy
  - Built-in Optimizations
- Migration Steps

This guide will help you migrate an existing Vite application to Next.js.

There are several reasons why you might want to switch from Vite to Next.js:

If you have built your application with the default Vite plugin for React, your application is a purely client-side application. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:

The previous issue of slow loading times can be somewhat managed with code splitting. However, if you try to do code splitting manually, you'll often make performance worse. It's easy to inadvertently introduce network waterfalls when code-splitting manually. Next.js provides automatic code splitting built into its router.

A common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One common pattern for data fetching in an SPA is to initially render a placeholder, and then fetch data after the component has mounted. Unfortunately, this means that a child component that fetches data can't start fetching until the parent component has finished loading its own data.

While fetching data on the client is supported with Next.js, it also gives you the option to shift data fetching to the server, which can eliminate client-server waterfalls.

With built-in support for streaming through React Suspense, you can be more intentional about which parts of your UI you want to load first and in what order without introducing network waterfalls.

This enables you to build pages that are faster to load and eliminate layout shifts.

Depending on your needs, Next.js allows you to choose your data fetching strategy on a page and component basis. You can decide to fetch at build time, at request time on the server, or on the client. For example, you can fetch data from your CMS and render your blog posts at build time, which can then be efficiently cached on a CDN.

Next.js Proxy allows you to run code on the server before a request is completed. This is especially useful to avoid having a flash of unauthenticated content when the user visits an authenticated-only page by redirecting the user to a login page. The proxy is also useful for experimentation and internationalization.

Images, fonts, and third-party scripts often have significant impact on an application's performance. Next.js comes with built-in components that automatically optimize those for you.

Our goal with this migration is to get a working Next.js application as quickly as possible, so that you can then adopt Next.js features incrementally. To begin with, we'll keep it as a purely client-side application (SPA) without migrating your existing router. This helps minimize the chances of encountering issues during the migration process and reduces merge conflicts.

The first thing you need to do is to install next as a dependency:

Create a next.config.mjs at the root of your project. This file will hold your Next.js configuration options.

Good to know: You can use either .js or .mjs for your Next.js configuration file.

If you're using TypeScript, you need to update your tsconfig.json file with the following changes to make it compatible with Next.js. If you're not using TypeScript, you can skip this step.

Here's an example of a working tsconfig.json with those changes:

You can find more information about configuring TypeScript on the Next.js docs.

A Next.js App Router application must include a root layout file, which is a React Server Component that will wrap all pages in your application. This file is defined at the top level of the app directory.

The closest equivalent to the root layout file in a Vite application is the index.html file, which contains your <html>, <head>, and <body> tags.

In this step, you'll convert your index.html file into a root layout file:

Good to know: .js, .jsx, or .tsx extensions can be used for Layout files.

With the above changes, you shifted from declaring everything in your index.html to using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages.

On Next.js you declare an entrypoint for your application by creating a page.tsx file. The closest equivalent of this file on Vite is your main.tsx file. In this step, youâ€™ll set up the entrypoint of your application.

Since in this guide we're aiming first to set up our Next.js as an SPA (Single Page Application), you need your page entrypoint to catch all possible routes of your application. For that, create a new [[...slug]] directory in your app directory.

This directory is what is called an optional catch-all route segment. Next.js uses a file-system based router where folders are used to define routes. This special directory will make sure that all routes of your application will be directed to its containing page.tsx file.

Good to know: .js, .jsx, or .tsx extensions can be used for Page files.

This file is a Server Component. When you run next build, the file is prerendered into a static asset. It does not require any dynamic code.

This file imports our global CSS and tells generateStaticParams we are only going to generate one route, the index route at /.

Now, let's move the rest of our Vite application which will run client-only.

This file is a Client Component, defined by the 'use client' directive. Client Components are still prerendered to HTML on the server before being sent to the client.

Since we want a client-only application to start, we can configure Next.js to disable prerendering from the App component down.

Now, update your entrypoint page to use the new component:

Next.js handles static image imports slightly different from Vite. With Vite, importing an image file will return its public URL as a string:

With Next.js, static image imports return an object. The object can then be used directly with the Next.js <Image> component, or you can use the object's src property with your existing <img> tag.

The <Image> component has the added benefits of automatic image optimization. The <Image> component automatically sets the width and height attributes of the resulting <img> based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled to auto. When not styled to auto, the dimension will default to the <img> dimension attribute's value, which can cause the image to appear distorted.

Keeping the <img> tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the <Image> component to take advantage of optimizing images by configuring a loader, or moving to the default Next.js server which has automatic image optimization.

Alternatively, you can reference the public URL for the image asset based on the filename. For example, public/logo.png will serve the image at /logo.png for your application, which would be the src value.

Warning: If you're using TypeScript, you might encounter type errors when accessing the src property. You can safely ignore those for now. They will be fixed by the end of this guide.

Next.js has support for .env environment variables similar to Vite. The main difference is the prefix used to expose environment variables on the client-side.

Vite exposes a few built-in environment variables on the special import.meta.env object which arenâ€™t supported by Next.js. You need to update their usage as follows:

Next.js also doesn't provide a built-in BASE_URL environment variable. However, you can still configure one, if you need it:

You should now be able to run your application to test if you successfully migrated to Next.js. But before that, you need to update your scripts in your package.json with Next.js related commands, and add .next and next-env.d.ts to your .gitignore:

Now run npm run dev, and open http://localhost:3000. You should see your application now running on Next.js.

Example: Check out this pull request for a working example of a Vite application migrated to Next.js.

You can now clean up your codebase from Vite related artifacts:

If everything went according to plan, you now have a functioning Next.js application running as a single-page application. However, you aren't yet taking advantage of most of Next.js' benefits, but you can now start making incremental changes to reap all the benefits. Here's what you might want to do next:

**Examples:**

Example 1 (unknown):
```unknown
npm install next@latest
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export', // Outputs a Single-Page Application (SPA).
  distDir: './dist', // Changes the build output directory to `./dist/`.
}
 
export default nextConfig
```

Example 3 (unknown):
```unknown
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "allowJs": true,
    "forceConsistentCasingInFileNames": true,
    "incremental": true,
    "plugins": [{ "name": "next" }]
  },
  "include": ["./src", "./dist/types/**/*.ts", "./next-env.d.ts"],
  "exclude": ["./node_modules"]
}
```

Example 4 (unknown):
```unknown
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return '...'
}
```

---

## Image Component

**URL:** https://nextjs.org/docs/app/api-reference/components/image

**Contents:**
- Image Component
- Reference
  - Props
    - src
    - alt
    - width and height
    - fill
    - loader
    - sizes
    - quality

The Next.js Image component extends the HTML <img> element for automatic image optimization.

The following props are available:

The source of the image. Can be one of the following:

An internal path string.

An absolute external URL (must be configured with remotePatterns).

Good to know: For security reasons, the Image Optimization API using the default loader will not forward headers when fetching the src image. If the src image requires authentication, consider using the unoptimized property to disable Image Optimization.

The alt property is used to describe the image for screen readers and search engines. It is also the fallback text if images have been disabled or an error occurs while loading the image.

It should contain text that could replace the image without changing the meaning of the page. It is not meant to supplement the image and should not repeat information that is already provided in the captions above or below the image.

If the image is purely decorative or not intended for the user, the alt property should be an empty string (alt="").

Learn more about image accessibility guidelines.

The width and height properties represent the intrinsic image size in pixels. This property is used to infer the correct aspect ratio used by browsers to reserve space for the image and avoid layout shift during loading. It does not determine the rendered size of the image, which is controlled by CSS.

You must set both width and height properties unless:

If the height and width are unknown, we recommend using the fill property.

A boolean that causes the image to expand to the size of the parent element.

If no styles are applied to the image, the image will stretch to fit the container. You can use objectFit to control cropping and scaling.

Learn more about position and object-fit.

A custom function used to generate the image URL. The function receives the following parameters, and returns a URL string for the image:

Good to know: Using props like onLoad, which accept a function, requires using Client Components to serialize the provided function.

Alternatively, you can use the loaderFile configuration in next.config.js to configure every instance of next/image in your application, without passing a prop.

Define the sizes of the image at different breakpoints. Used by the browser to choose the most appropriate size from the generated srcset.

sizes should be used when:

If sizes is missing, the browser assumes the image will be as wide as the viewport (100vw). This can cause unnecessarily large images to be downloaded.

In addition, sizes affects how srcset is generated:

Learn more about srcset and sizes on web.dev and mdn.

An integer between 1 and 100 that sets the quality of the optimized image. Higher values increase file size and visual fidelity. Lower values reduce file size but may affect sharpness.

If youâ€™ve configured qualities in next.config.js, the value must match one of the allowed entries.

Good to know: If the original image is already low quality, setting a high quality value will increase the file size without improving appearance.

Allows passing CSS styles to the underlying image element.

Good to know: If youâ€™re using the style prop to set a custom width, be sure to also set height: 'auto' to preserve the imageâ€™s aspect ratio.

A boolean that indicates if the image should be preloaded.

In most cases, you should use loading="eager" or fetchPriority="high" instead of preload.

Starting with Next.js 16, the priority property has been deprecated in favor of the preload property in order to make the behavior clear.

Controls when the image should start loading.

Use eager only when you want to ensure the image is loaded immediately.

Learn more about the loading attribute.

Specifies a placeholder to use while the image is loading, improving the perceived loading performance.

Learn more about the placeholder attribute.

A Data URL to be used as a placeholder image before the image successfully loads. Can be automatically set or used with the placeholder="blur" property.

The image is automatically enlarged and blurred, so a very small image (10px or less) is recommended.

If src is a static import of a jpg, png, webp, or avif file, blurDataURL is added automaticallyâ€”unless the image is animated.

If the image is dynamic or remote, you must provide blurDataURL yourself. To generate one, you can use:

A large blurDataURL may hurt performance. Keep it small and simple.

A callback function that is invoked once the image is completely loaded and the placeholder has been removed.

The callback function will be called with one argument, the event which has a target that references the underlying <img> element.

Good to know: Using props like onLoad, which accept a function, requires using Client Components to serialize the provided function.

A callback function that is invoked if the image fails to load.

Good to know: Using props like onError, which accept a function, requires using Client Components to serialize the provided function.

A boolean that indicates if the image should be optimized. This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).

Since Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration:

When providing the src prop to the <Image> component, both the srcset and src attributes are generated automatically for the resulting <img>.

In some cases, it is not desirable to have the src attribute generated and you may wish to override it using the overrideSrc prop.

For example, when upgrading an existing website from <img> to <Image>, you may wish to maintain the same src attribute for SEO purposes such as image ranking or avoiding recrawl.

A hint to the browser indicating if it should wait for the image to be decoded before presenting other content updates or not.

Learn more about the decoding attribute.

Other properties on the <Image /> component will be passed to the underlying img element with the exception of the following:

Warning: Deprecated in Next.js 14, use onLoad instead.

A callback function that is invoked once the image is completely loaded and the placeholder has been removed.

The callback function will be called with one argument, a reference to the underlying <img> element.

Good to know: Using props like onLoadingComplete, which accept a function, requires using Client Components to serialize the provided function.

You can configure the Image Component in next.config.js. The following options are available:

Use localPatterns in your next.config.js file to allow images from specific local paths to be optimized and block all others.

The example above will ensure the src property of next/image must start with /assets/images/ and must not have a query string. Attempting to optimize any other path will respond with 400 Bad Request error.

Good to know: Omitting the search property allows all search parameters which could allow malicious actors to optimize URLs you did not intend. Try using a specific value like search: '?v=2' to ensure an exact match.

Use remotePatterns in your next.config.js file to allow images from specific external paths and block all others. This ensures that only external images from your account can be served.

You can also configure remotePatterns using the object:

The example above will ensure the src property of next/image must start with https://example.com/account123/ and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.

Wildcard patterns can be used for both pathname and hostname and have the following syntax:

This allows subdomains like image.example.com. Query strings and custom ports are still blocked.

Good to know: When omitting protocol, port, pathname, or search then the wildcard ** is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.

You can also restrict query strings using the search property:

The example above will ensure the src property of next/image must start with https://assets.example.com and must have the exact query string ?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request.

loaderFiles allows you to use a custom image optimization service instead of Next.js.

The path must be relative to the project root. The file must export a default function that returns a URL string:

Alternatively, you can use the loader prop to configure each instance of next/image.

If you want to change or prefix the default path for the Image Optimization API, you can do so with the path property. The default value for path is /_next/image.

deviceSizes allows you to specify a list of device width breakpoints. These widths are used when the next/image component uses sizes prop to ensure the correct image is served for the user's device.

If no configuration is provided, the default below is used:

imageSizes allows you to specify a list of image widths. These widths are concatenated with the array of device sizes to form the full array of sizes used to generate image srcset.

If no configuration is provided, the default below is used:

imageSizes is only used for images which provide a sizes prop, which indicates that the image is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.

qualities allows you to specify a list of image quality values.

If not configuration is provided, the default below is used:

Good to know: This field is required starting with Next.js 16 because unrestricted access could allow malicious actors to optimize more qualities than you intended.

You can add more image qualities to the allowlist, such as the following:

In the example above, only four qualities are allowed: 25, 50, 75, and 100.

If the quality prop does not match a value in this array, the closest allowed value will be used.

If the REST API is visited directly with a quality that does not match a value in this array, the server will return a 400 Bad Request response.

formats allows you to specify a list of image formats to be used.

Next.js automatically detects the browser's supported image formats via the request's Accept header in order to determine the best output format.

If the Accept header matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image is animated), it will use the original image's format.

You can enable AVIF support, which will fallback to the original format of the src image if the browser does not support AVIF:

minimumCacheTTL allows you to configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use a Static Image Import which will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable.

If no configuration is provided, the default below is used.

You can increase the TTL to reduce the number of revalidations and potentially lower cost:

The expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-Control header, whichever is larger.

If you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream image (e.g. /some-asset.jpg, not /_next/image itself).

There is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to manually change the src prop or delete the cached file <distDir>/cache/images.

disableStaticImages allows you to disable static image imports.

The default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src property. In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.

You can disable static image imports inside your next.config.js:

The default image optimization loader will follow HTTP redirects when fetching remote images up to 3 times.

You can configure the number of redirects to follow when fetching remote images. Setting the value to 0 will disable following redirects.

In rare cases when self-hosting Next.js on a private network, you may want to allow optimizing images from local IP addresses on the same network. This is not recommended for most users because it could allow malicious users to access content on your internal network.

By default, the value is false.

If you need to optimize remote images hosted elsewhere in your local network, you can set the value to true.

dangerouslyAllowSVG allows you to serve SVG images.

By default, Next.js does not optimize SVG images for a few reasons:

We recommend using the unoptimized prop when the src prop is known to be SVG. This happens automatically when src ends with ".svg".

In addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as contentSecurityPolicy to prevent scripts embedded in the image from executing.

contentDispositionType allows you to configure the Content-Disposition header.

contentSecurityPolicy allows you to configure the Content-Security-Policy header for images. This is particularly important when using dangerouslyAllowSVG to prevent scripts embedded in the image from executing.

By default, the loader sets the Content-Disposition header to attachment for added protection since the API can serve arbitrary remote images.

The default value is attachment which forces the browser to download the image when visiting directly. This is particularly important when dangerouslyAllowSVG is true.

You can optionally configure inline to allow the browser to render the image when visiting directly, without downloading it.

Warning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious users.

Similar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images. However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.

Since most remote image servers are shared between multiple tenants, it's safer to use remotePatterns to ensure only the intended images are optimized.

Below is an example of the domains property in the next.config.js file:

The getImageProps function can be used to get the props that would be passed to the underlying <img> element, and instead pass them to another component, style, canvas, etc.

This also avoid calling React useState() so it can lead to better performance, but it cannot be used with the placeholder prop because the placeholder will never be removed.

This next/image component uses browser native lazy loading, which may fallback to eager loading for older browsers before Safari 15.4. When using the blur-up placeholder, older browsers before Safari 12 will fallback to empty placeholder. When using styles with width/height of auto, it is possible to cause Layout Shift on older browsers before Safari 15 that don't preserve the aspect ratio. For more details, see this MDN video.

Styling the Image component is similar to styling a normal <img> element, but there are a few guidelines to keep in mind:

Use className or style, not styled-jsx. In most cases, we recommend using the className prop. This can be an imported CSS Module, a global stylesheet, etc.

You can also use the style prop to assign inline styles.

When using fill, the parent element must have position: relative or display: block. This is necessary for the proper rendering of the image element in that layout mode.

You cannot use styled-jsx because it's scoped to the current component (unless you mark the style as global).

When you import a static image, Next.js automatically sets its width and height based on the file. You can make the image responsive by setting the style:

If the source image is a dynamic or a remote URL, you must provide the width and height props so Next.js can calculate the aspect ratio:

If you don't know the aspect ratio of the image, you can add the fill prop with the objectFit prop set to cover. This will make the image fill the full width of its parent container.

Use the fill prop to make the image cover the entire screen area:

For examples of the Image component used with the various styles, see the Image Component Demo.

To use a remote image, the src property should be a URL string.

Since Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually.

The width and height attributes are used to infer the correct aspect ratio of image and avoid layout shift from the image loading in. The width and height do not determine the rendered size of the image file.

To safely allow optimizing images, define a list of supported URL patterns in next.config.js. Be as specific as possible to prevent malicious usage. For example, the following configuration will only allow images from a specific AWS S3 bucket:

If you want to display a different image for light and dark mode, you can create a new component that wraps two <Image> components and reveals the correct one based on a CSS media query.

Good to know: The default behavior of loading="lazy" ensures that only the correct image is loaded. You cannot use preload or loading="eager" because that would cause both images to load. Instead, you can use fetchPriority="high".

If you want to display a different image for mobile and desktop, sometimes called Art Direction, you can provide different src, width, height, and quality props to getImageProps().

You can even convert the srcSet string to the image-set() CSS function to optimize a background image.

**Examples:**

Example 1 (python):
```python
import Image from 'next/image'
 
export default function Page() {
  return (
    <Image
      src="/profile.png"
      width={500}
      height={500}
      alt="Picture of the author"
    />
  )
}
```

Example 2 (unknown):
```unknown
<Image src="/profile.png" />
```

Example 3 (unknown):
```unknown
<Image src="https://example.com/profile.png" />
```

Example 4 (python):
```python
import profile from './profile.png'
 
export default function Page() {
  return <Image src={profile} />
}
```

---

## TypeScript

**URL:** https://nextjs.org/docs/pages/api-reference/config/typescript

**Contents:**
- TypeScript
- Examples
  - Type Checking Next.js Configuration Files
  - Using Node.js Native TypeScript Resolver for next.config.ts
    - For CommonJS Projects (Default)
    - For ESM Projects
  - Statically Typed Links
  - Type IntelliSense for Environment Variables
  - Static Generation and Server-side Rendering
  - With API Routes

Next.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app.

To add TypeScript to an existing project, rename a file to .ts / .tsx. Run next dev and next build to automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options.

Good to know: If you already have a jsconfig.json file, copy the paths compiler option from the old jsconfig.json into the new tsconfig.json file, and delete the old jsconfig.json file.

You can use TypeScript and import types in your Next.js configuration by using next.config.ts.

Module resolution in next.config.ts is currently limited to CommonJS. However, ECMAScript Modules (ESM) syntax is available when using Node.js native TypeScript resolver for Node.js v22.10.0 and higher.

When using the next.config.js file, you can add some type checking in your IDE using JSDoc as below:

Note: Available on Node.js v22.10.0+ and only when the feature is enabled. Next.js does not enable it.

Next.js detects the Node.js native TypeScript resolver via process.features.typescript, added in v22.10.0. When present, next.config.ts can use native ESM, including topâ€‘level await and dynamic import(). This mechanism inherits the capabilities and limitations of Node's resolver.

In Node.js versions v22.18.0+, process.features.typescript is enabled by default. For versions between v22.10.0 and 22.17.x, opt in with NODE_OPTIONS=--experimental-transform-types:

Although next.config.ts supports native ESM syntax on CommonJS projects, Node.js will still assume next.config.ts is a CommonJS file by default, resulting in Node.js reparsing the file as ESM when module syntax is detected. Therefore, we recommend using the next.config.mts file for CommonJS projects to explicitly indicate it's an ESM module:

When "type" is set to "module" in package.json, your project uses ESM. Learn more about this setting in the Node.js docs. In this case, you can write next.config.ts directly with ESM syntax.

Good to know: When using "type": "module" in your package.json, all .js and .ts files in your project are treated as ESM modules by default. You may need to rename files with CommonJS syntax to .cjs or .cts extensions if needed.

Next.js can statically type links to prevent typos and other errors when using next/link, improving type safety when navigating between pages.

Works in both the Pages and App Router for the href prop in next/link. In the App Router, it also types next/navigation methods like push, replace, and prefetch. It does not type next/router methods in Pages Router.

Literal href strings are validated, while non-literal hrefs may require a cast with as Route.

To opt-into this feature, typedRoutes need to be enabled and the project needs to be using TypeScript.

Next.js will generate a link definition in .next/types that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links.

Good to know: If you set up your project without create-next-app, ensure the generated Next.js types are included by adding .next/types/**/*.ts to the include array in your tsconfig.json:

Currently, support includes any string literal, including dynamic segments. For non-literal strings, you need to manually cast with as Route. The example below shows both next/link and next/navigation usage:

The same applies for redirecting routes defined by proxy:

To accept href in a custom component wrapping next/link, use a generic:

You can also type a simple data structure and iterate to render links:

Then, map over the items to render Links:

When running next dev or next build, Next.js generates a hidden .d.ts file inside .next that contains information about all existing routes in your application (all valid routes as the href type of Link). This .d.ts file is included in tsconfig.json and the TypeScript compiler will check that .d.ts and provide feedback in your editor about invalid links.

During development, Next.js generates a .d.ts file in .next/types that contains information about the loaded environment variables for your editor's IntelliSense. If the same environment variable key is defined in multiple files, it is deduplicated according to the Environment Variable Load Order.

To opt-into this feature, experimental.typedEnv needs to be enabled and the project needs to be using TypeScript.

Good to know: Types are generated based on the environment variables loaded at development runtime, which excludes variables from .env.production* files by default. To include production-specific variables, run next dev with NODE_ENV=production.

For getStaticProps, getStaticPaths, and getServerSideProps, you can use the GetStaticProps, GetStaticPaths, and GetServerSideProps types respectively:

Good to know: satisfies was added to TypeScript in 4.9. We recommend upgrading to the latest version of TypeScript.

The following is an example of how to use the built-in types for API routes:

You can also type the response data:

If you have a custom App, you can use the built-in type AppProps and change file name to ./pages/_app.tsx like so:

Since v10.2.1 Next.js supports incremental type checking when enabled in your tsconfig.json, this can help speed up type checking in larger applications.

In some cases, you might want to use a different TypeScript configuration for builds or tooling. To do that, set typescript.tsconfigPath in next.config.ts to point Next.js to another tsconfig file.

For example, switch to a different config for production builds:

You might need to relax checks in scenarios like monorepos, where the build also validates shared dependencies that don't match your project's standards, or when loosening checks in CI to continue delivering while migrating locally to stricter TypeScript settings (and still wanting your IDE to highlight misuse).

For example, if your project uses useUnknownInCatchVariables but some monorepo dependencies still assume any:

This keeps your editor strict via tsconfig.json while allowing the production build to use relaxed settings.

Next.js fails your production build (next build) when TypeScript errors are present in your project.

If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.

Open next.config.ts and enable the ignoreBuildErrors option in the typescript config:

Good to know: You can run tsc --noEmit to check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying.

When you need to declare custom types, you might be tempted to modify next-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call it new-types.d.ts, and reference it in your tsconfig.json:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  /* config options here */
}
 
export default nextConfig
```

Example 2 (javascript):
```javascript
// @ts-check
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
}
 
module.exports = nextConfig
```

Example 3 (unknown):
```unknown
NODE_OPTIONS=--experimental-transform-types next <command>
```

Example 4 (python):
```python
import type { NextConfig } from 'next'
 
// Top-level await and dynamic import are supported
const flags = await import('./flags.js').then((m) => m.default ?? m)
 
const nextConfig: NextConfig = {
  /* config options here */
  typedRoutes: Boolean(flags?.typedRoutes),
}
 
export default nextConfig
```

---

## loading.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/loading

**Contents:**
- loading.js
- Reference
  - Parameters
- Behavior
  - Navigation
  - Instant Loading States
  - SEO
  - Status Codes
  - Browser limits
- Platform Support

The special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment streams in. The new content is automatically swapped in once complete.

Inside the loading.js file, you can add any light-weight loading UI. You may find it helpful to use the React Developer Tools to manually toggle Suspense boundaries.

By default, this file is a Server Component - but can also be used as a Client Component through the "use client" directive.

Loading UI components do not accept any parameters.

An instant loading state is fallback UI that is shown immediately upon navigation. You can pre-render loading indicators such as skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. This helps users understand the app is responding and provides a better user experience.

Create a loading state by adding a loading.js file inside a folder.

In the same folder, loading.js will be nested inside layout.js. It will automatically wrap the page.js file and any children below in a <Suspense> boundary.

When streaming, a 200 status code will be returned to signal that the request was successful.

The server can still communicate errors or issues to the client within the streamed content itself, for example, when using redirect or notFound. Because the response headers have already been sent to the client, the status code of the response cannot be updated.

For example, when a 404 page is streamed to the client, Next.js includes a <meta name="robots" content="noindex"> tag in the streamed HTML. This prevents search engines from indexing that URL even if the HTTP status is 200. See Googleâ€™s guidance on the robots meta tag.

Some crawlers may label these responses as â€œsoft 404sâ€. In the streaming case, this does not lead to indexation because the page is explicitly marked noindex in the HTML.

If you need a 404 status, for compliance or analytics, ensure the resource exists before the response body is streamed, so that the server can set the HTTP status code.

You can run this check in proxy to rewrite missing slugs to a not-found route, or produce a 404 response. Keep proxy checks fast, and avoid fetching full content there.

The response body starts streaming when a Suspense fallback renders (for example, a loading.tsx) or when a Server Component suspends under a Suspense boundary. Place notFound() before those boundaries and before any await that may suspend.

To start streaming, the response headers must be set. This is why it is not possible to change the status code after streaming started.

Some browsers buffer a streaming response. You may not see the streamed response until the response exceeds 1024 bytes. This typically only affects â€œhello worldâ€ applications, but not real applications.

Learn how to configure streaming when self-hosting Next.js.

In addition to loading.js, you can also manually create Suspense Boundaries for your own UI components. The App Router supports streaming with Suspense.

<Suspense> works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton, spinner) while it's happening, and then swapping in your component once the action completes.

By using Suspense, you get the benefits of:

For more Suspense examples and use cases, please see the React Documentation.

**Examples:**

Example 1 (unknown):
```unknown
export default function Loading() {
  // Or a custom loading skeleton component
  return <p>Loading...</p>
}
```

Example 2 (unknown):
```unknown
export default function Loading() {
  // You can add any UI inside Loading, including a Skeleton.
  return <LoadingSkeleton />
}
```

Example 3 (python):
```python
import { Suspense } from 'react'
import { PostFeed, Weather } from './Components'
 
export default function Posts() {
  return (
    <section>
      <Suspense fallback={<p>Loading feed...</p>}>
        <PostFeed />
      </Suspense>
      <Suspense fallback={<p>Loading weather...</p>}>
        <Weather />
      </Suspense>
    </section>
  )
}
```

---

## How to upgrade to version 14

**URL:** https://nextjs.org/docs/pages/guides/upgrading/version-14

**Contents:**
- How to upgrade to version 14
- Upgrading from 13 to 14
  - v14 Summary

To update to Next.js version 14, run the following command using your preferred package manager:

Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions.

**Examples:**

Example 1 (unknown):
```unknown
npm i next@next-14 react@18 react-dom@18 && npm i eslint-config-next@next-14 -D
```

Example 2 (unknown):
```unknown
yarn add next@next-14 react@18 react-dom@18 && yarn add eslint-config-next@next-14 -D
```

Example 3 (unknown):
```unknown
pnpm i next@next-14 react@18 react-dom@18 && pnpm i eslint-config-next@next-14 -D
```

Example 4 (unknown):
```unknown
bun add next@next-14 react@18 react-dom@18 && bun add eslint-config-next@next-14 -D
```

---

## serverExternalPackages

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/serverExternalPackages

**Contents:**
- serverExternalPackages

Dependencies used inside Server Components and Route Handlers will automatically be bundled by Next.js.

If a dependency is using Node.js specific features, you can choose to opt-out specific dependencies from the Server Components bundling and use native Node.js require.

Next.js includes a short list of popular packages that currently are working on compatibility and automatically opt-ed out:

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  serverExternalPackages: ['@acme/ui'],
}
 
module.exports = nextConfig
```

---

## NextRequest

**URL:** https://nextjs.org/docs/pages/api-reference/functions/next-request

**Contents:**
- NextRequest
- cookies
  - set(name, value)
  - get(name)
  - getAll()
  - delete(name)
  - has(name)
  - clear()
- nextUrl
- Version History

NextRequest extends the Web Request API with additional convenience methods.

Read or mutate the Set-Cookie header of the request.

Given a name, set a cookie with the given value on the request.

Given a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found, the first one is returned.

Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the request.

Given a cookie name, delete the cookie from the request.

Given a cookie name, return true if the cookie exists on the request.

Remove the Set-Cookie header from the request.

Extends the native URL API with additional convenience methods, including Next.js specific properties.

The following options are available:

**Examples:**

Example 1 (unknown):
```unknown
// Given incoming request /home
// Set a cookie to hide the banner
// request will have a `Set-Cookie:show-banner=false;path=/home` header
request.cookies.set('show-banner', 'false')
```

Example 2 (unknown):
```unknown
// Given incoming request /home
// { name: 'show-banner', value: 'false', Path: '/home' }
request.cookies.get('show-banner')
```

Example 3 (unknown):
```unknown
// Given incoming request /home
// [
//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },
//   { name: 'experiments', value: 'winter-launch', Path: '/home' },
// ]
request.cookies.getAll('experiments')
// Alternatively, get all cookies for the request
request.cookies.getAll()
```

Example 4 (unknown):
```unknown
// Returns true for deleted, false is nothing is deleted
request.cookies.delete('experiments')
```

---

## Components

**URL:** https://nextjs.org/docs/app/api-reference/components

**Contents:**
- Components
  - Font
  - Form Component
  - Image Component
  - Link Component
  - Script Component

---

## How to create a static export of your Next.js application

**URL:** https://nextjs.org/docs/pages/guides/static-exports

**Contents:**
- How to create a static export of your Next.js application
- Configuration
- Supported Features
  - Image Optimization
- Unsupported Features
- Deploying
- Version History

Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.

When running next build, Next.js generates an HTML file per route. By breaking a strict SPA into individual HTML files, Next.js can avoid loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.

Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.

To enable a static export, change the output mode inside next.config.js:

After running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application.

You can utilize getStaticProps and getStaticPaths to generate an HTML file for each page in your pages directory (or more for dynamic routes).

The majority of core Next.js features needed to build a static site are supported, including:

Image Optimization through next/image can be used with a static export by defining a custom image loader in next.config.js. For example, you can optimize images with a service like Cloudinary:

This custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for Cloudinary:

You can then use next/image in your application, defining relative paths to the image in Cloudinary:

Features that require a Node.js server, or dynamic logic that cannot be computed during the build process, are not supported:

With a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.

When running next build, Next.js generates the static export into the out folder. For example, let's say you have the following routes:

After running next build, Next.js will generate the following files:

If you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files:

**Examples:**

Example 1 (javascript):
```javascript
/**
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  output: 'export',
 
  // Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html`
  // trailingSlash: true,
 
  // Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href`
  // skipTrailingSlashRedirect: true,
 
  // Optional: Change the output directory `out` -> `dist`
  // distDir: 'dist',
}
 
module.exports = nextConfig
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  images: {
    loader: 'custom',
    loaderFile: './my-loader.ts',
  },
}
 
module.exports = nextConfig
```

Example 3 (javascript):
```javascript
export default function cloudinaryLoader({
  src,
  width,
  quality,
}: {
  src: string
  width: number
  quality?: number
}) {
  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]
  return `https://res.cloudinary.com/demo/image/upload/${params.join(
    ','
  )}${src}`
}
```

Example 4 (python):
```python
import Image from 'next/image'
 
export default function Page() {
  return <Image alt="turtles" src="/turtles.jpg" width={300} height={300} />
}
```

---

## instrumentation-client.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation-client

**Contents:**
- instrumentation-client.js
- Usage
- Router navigation tracking
- Performance considerations
- Execution timing
- Examples
  - Error tracking
  - Analytics tracking
  - Performance monitoring
  - Polyfills

The instrumentation-client.js|ts file allows you to add monitoring, analytics code, and other side-effects that run before your application becomes interactive. This is useful for setting up performance tracking, error monitoring, polyfills, or any other client-side observability tools.

To use it, place the file in the root of your application or inside a src folder.

Unlike server-side instrumentation, you do not need to export any specific functions. You can write your monitoring code directly in the file:

Error handling: Implement try-catch blocks around your instrumentation code to ensure robust monitoring. This prevents individual tracking failures from affecting other instrumentation features.

You can export an onRouterTransitionStart function to receive notifications when navigation begins:

The onRouterTransitionStart function receives two parameters:

Keep instrumentation code lightweight.

Next.js monitors initialization time in development and will log warnings if it takes longer than 16ms, which could impact smooth page loading.

The instrumentation-client.js file executes at a specific point in the application lifecycle:

This timing makes it ideal for setting up error tracking, analytics, and performance monitoring that needs to capture early application lifecycle events.

Initialize error tracking before React starts and add navigation breadcrumbs for better debugging context.

Initialize analytics and track navigation events with detailed metadata for user behavior analysis.

Track Time to Interactive and navigation performance using the Performance Observer API and performance marks.

Load polyfills before application code runs. Use static imports for immediate loading and dynamic imports for conditional loading based on feature detection.

**Examples:**

Example 1 (javascript):
```javascript
// Set up performance monitoring
performance.mark('app-init')
 
// Initialize analytics
console.log('Analytics initialized')
 
// Set up error tracking
window.addEventListener('error', (event) => {
  // Send to your error tracking service
  reportError(event.error)
})
```

Example 2 (unknown):
```unknown
performance.mark('app-init')
 
export function onRouterTransitionStart(
  url: string,
  navigationType: 'push' | 'replace' | 'traverse'
) {
  console.log(`Navigation started: ${navigationType} to ${url}`)
  performance.mark(`nav-start-${Date.now()}`)
}
```

Example 3 (python):
```python
import Monitor from './lib/monitoring'
 
Monitor.initialize()
 
export function onRouterTransitionStart(url: string) {
  Monitor.pushEvent({
    message: `Navigation to ${url}`,
    category: 'navigation',
  })
}
```

Example 4 (python):
```python
import { analytics } from './lib/analytics'
 
analytics.init()
 
export function onRouterTransitionStart(url: string, navigationType: string) {
  analytics.track('page_navigation', {
    url,
    type: navigationType,
    timestamp: Date.now(),
  })
}
```

---

## Testing

**URL:** https://nextjs.org/docs/app/guides/testing

**Contents:**
- Testing
- Types of tests
- Async Server Components
- Guides
  - Cypress
  - Jest
  - Playwright
  - Vitest

In React and Next.js, there are a few different types of tests you can write, each with its own purpose and use cases. This page provides an overview of types and commonly used tools you can use to test your application.

Since async Server Components are new to the React ecosystem, some tools do not fully support them. In the meantime, we recommend using End-to-End Testing over Unit Testing for async components.

See the guides below to learn how to set up Next.js with these commonly used testing tools:

---

## Client-side Rendering (CSR)

**URL:** https://nextjs.org/docs/pages/building-your-application/rendering/client-side-rendering

**Contents:**
- Client-side Rendering (CSR)
- Next Steps
  - Server-side Rendering (SSR)
  - Static Site Generation (SSG)
  - ISR

In Client-Side Rendering (CSR) with React, the browser downloads a minimal HTML page and the JavaScript needed for the page. The JavaScript is then used to update the DOM and render the page. When the application is first loaded, the user may notice a slight delay before they can see the full page, this is because the page isn't fully rendered until all the JavaScript is downloaded, parsed, and executed.

After the page has been loaded for the first time, navigating to other pages on the same website is typically faster, as only necessary data needs to be fetched, and JavaScript can re-render parts of the page without requiring a full page refresh.

In Next.js, there are two ways you can implement client-side rendering:

Here's an example of using useEffect() inside a Next.js page:

In the example above, the component starts by rendering Loading.... Then, once the data is fetched, it re-renders and displays the data.

Although fetching data in a useEffect is a pattern you may see in older React Applications, we recommend using a data-fetching library for better performance, caching, optimistic updates, and more. Here's a minimum example using SWR to fetch data on the client:

Keep in mind that CSR can impact SEO. Some search engine crawlers might not execute JavaScript and therefore only see the initial empty or loading state of your application. It can also lead to performance issues for users with slower internet connections or devices, as they need to wait for all the JavaScript to load and run before they can see the full page. Next.js promotes a hybrid approach that allows you to use a combination of server-side rendering, static site generation, and client-side rendering, depending on the needs of each page in your application. In the App Router, you can also use Loading UI with Suspense to show a loading indicator while the page is being rendered.

**Examples:**

Example 1 (python):
```python
import React, { useState, useEffect } from 'react'
 
export function Page() {
  const [data, setData] = useState(null)
 
  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data')
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      const result = await response.json()
      setData(result)
    }
 
    fetchData().catch((e) => {
      // handle the error as needed
      console.error('An error occurred while fetching the data: ', e)
    })
  }, [])
 
  return <p>{data ? `Your data: ${data}` : 'Loading...'}</p>
}
```

Example 2 (python):
```python
import useSWR from 'swr'
 
export function Page() {
  const { data, error, isLoading } = useSWR(
    'https://api.example.com/data',
    fetcher
  )
 
  if (error) return <p>Failed to load.</p>
  if (isLoading) return <p>Loading...</p>
 
  return <p>Your Data: {data}</p>
}
```

---

## optimizePackageImports

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/optimizePackageImports

**Contents:**
- optimizePackageImports

Some packages can export hundreds or thousands of modules, which can cause performance issues in development and production.

Adding a package to experimental.optimizePackageImports will only load the modules you are actually using, while still giving you the convenience of writing import statements with many named exports.

The following libraries are optimized by default:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  experimental: {
    optimizePackageImports: ['package-name'],
  },
}
```

---

## No Head Import in Document

**URL:** https://nextjs.org/docs/messages/no-head-import-in-document

**Contents:**
- No Head Import in Document
- Why This Error Occurred
- Possible Ways to Fix It
- Useful Links

Prevent usage of next/head in pages/_document.js.

next/head was imported in pages/_document.js. This can cause unexpected issues in your application.

Only import and use next/document within pages/_document.js to override the default Document component. If you are importing next/head to use the Head component, import it from next/document instead in order to modify <head> code across all pages:

**Examples:**

Example 1 (python):
```python
import Document, { Html, Head, Main, NextScript } from 'next/document'
 
class MyDocument extends Document {
  static async getInitialProps(ctx) {
    //...
  }
 
  render() {
    return (
      <Html>
        <Head></Head>
      </Html>
    )
  }
}
 
export default MyDocument
```

---

## Upgrade Guides

**URL:** https://nextjs.org/docs/15/app/guides/upgrading

**Contents:**
- Upgrade Guides
  - Codemods
  - Version 14
  - Version 15

Learn how to upgrade to the latest versions of Next.js following the versions-specific guides:

---

## cacheComponents

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/cacheComponents

**Contents:**
- cacheComponents
- Usage
- Notes
- Version History

The cacheComponents flag is a feature in Next.js that causes data fetching operations in the App Router to be excluded from pre-renders unless they are explicitly cached. This can be useful for optimizing the performance of dynamic data fetching in Server Components.

It is useful if your application requires fresh data fetching during runtime rather than serving from a pre-rendered cache.

It is expected to be used in conjunction with use cache so that your data fetching happens at runtime by default unless you define specific parts of your application to be cached with use cache at the page, function, or component level.

To enable the cacheComponents flag, set it to true in your next.config.ts file:

When cacheComponents is enabled, you can use the following cache functions and configurations:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  cacheComponents: true,
}
 
export default nextConfig
```

---

## How to use CSS-in-JS libraries

**URL:** https://nextjs.org/docs/pages/guides/css-in-js

**Contents:**
- How to use CSS-in-JS libraries
  - Disabling JavaScript

It's possible to use any existing CSS-in-JS solution. The simplest one is inline styles:

We bundle styled-jsx to provide support for isolated scoped CSS. The aim is to support "shadow CSS" similar to Web Components, which unfortunately do not support server-rendering and are JS-only.

See the above examples for other popular CSS-in-JS solutions (like Styled Components).

A component using styled-jsx looks like this:

Please see the styled-jsx documentation for more examples.

Yes, if you disable JavaScript the CSS will still be loaded in the production build (next start). During development, we require JavaScript to be enabled to provide the best developer experience with Fast Refresh.

**Examples:**

Example 1 (unknown):
```unknown
function HiThere() {
  return <p style={{ color: 'red' }}>hi there</p>
}
 
export default HiThere
```

Example 2 (unknown):
```unknown
function HelloWorld() {
  return (
    <div>
      Hello world
      <p>scoped!</p>
      <style jsx>{`
        p {
          color: blue;
        }
        div {
          background: red;
        }
        @media (max-width: 600px) {
          div {
            background: blue;
          }
        }
      `}</style>
      <style global jsx>{`
        body {
          background: black;
        }
      `}</style>
    </div>
  )
}
 
export default HelloWorld
```

---

## How to upgrade to version 9

**URL:** https://nextjs.org/docs/pages/guides/upgrading/version-9

**Contents:**
- How to upgrade to version 9
- Check your Custom App File (pages/_app.js)
- Breaking Changes
  - @zeit/next-typescript is no longer necessary
  - The config key is now an export on a page
  - next/dynamic no longer renders "loading..." by default while loading
  - withAmp has been removed in favor of an exported configuration object
  - next export no longer exports pages as index.html
  - pages/api/ is treated differently
- Deprecated Features

To upgrade to version 9, run the following command:

Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions.

If you previously copied the Custom <App> example, you may be able to remove your getInitialProps.

Removing getInitialProps from pages/_app.js (when possible) is important to leverage new Next.js features!

The following getInitialProps does nothing and may be removed:

Next.js will now ignore usage @zeit/next-typescript and warn you to remove it. Please remove this plugin from your next.config.js.

Remove references to @zeit/next-typescript/babel from your custom .babelrc (if present).

The usage of fork-ts-checker-webpack-plugin should also be removed from your next.config.js.

TypeScript Definitions are published with the next package, so you need to uninstall @types/next as they would conflict.

The following types are different:

This list was created by the community to help you upgrade, if you find other differences please send a pull-request to this list to help other users.

You may no longer export a custom variable named config from a page (i.e. export { config } / export const config ...). This exported variable is now used to specify page-level Next.js configuration like Opt-in AMP and API Route features.

You must rename a non-Next.js-purposed config export to something different.

Dynamic components will not render anything by default while loading. You can still customize this behavior by setting the loading property:

Next.js now has the concept of page-level configuration, so the withAmp higher-order component has been removed for consistency.

This change can be automatically migrated by running the following commands in the root of your Next.js project:

To perform this migration by hand, or view what the codemod will produce, see below:

Previously, exporting pages/about.js would result in out/about/index.html. This behavior has been changed to result in out/about.html.

You can revert to the previous behavior by creating a next.config.js with the following content:

Pages in pages/api/ are now considered API Routes. Pages in this directory will no longer contain a client-side bundle.

The ability to load multiple modules at once has been deprecated in next/dynamic to be closer to React's implementation (React.lazy and Suspense).

Updating code that relies on this behavior is relatively straightforward! We've provided an example of a before/after to help you migrate your application:

**Examples:**

Example 1 (unknown):
```unknown
npm i next@9
```

Example 2 (unknown):
```unknown
yarn add next@9
```

Example 3 (unknown):
```unknown
pnpm up next@9
```

Example 4 (unknown):
```unknown
bun add next@9
```

---

## useSearchParams

**URL:** https://nextjs.org/docs/app/api-reference/functions/use-search-params

**Contents:**
- useSearchParams
- Parameters
- Returns
- Behavior
  - Static Rendering
  - Dynamic Rendering
  - Server Components
    - Pages
    - Layouts
- Examples

useSearchParams is a Client Component hook that lets you read the current URL's query string.

useSearchParams returns a read-only version of the URLSearchParams interface.

useSearchParams does not take any parameters.

useSearchParams returns a read-only version of the URLSearchParams interface, which includes utility methods for reading the URL's query string:

URLSearchParams.get(): Returns the first value associated with the search parameter. For example:

URLSearchParams.has(): Returns a boolean value indicating if the given parameter exists. For example:

Learn more about other read-only methods of URLSearchParams, including the getAll(), keys(), values(), entries(), forEach(), and toString().

If a route is statically rendered, calling useSearchParams will cause the Client Component tree up to the closest Suspense boundary to be client-side rendered.

This allows a part of the route to be statically rendered while the dynamic part that uses useSearchParams is client-side rendered.

We recommend wrapping the Client Component that uses useSearchParams in a <Suspense/> boundary. This will allow any Client Components above it to be statically rendered and sent as part of initial HTML. Example.

If a route is dynamically rendered, useSearchParams will be available on the server during the initial server render of the Client Component.

To access search params in Pages (Server Components), use the searchParams prop.

Unlike Pages, Layouts (Server Components) do not receive the searchParams prop. This is because a shared layout is not re-rendered during navigation which could lead to stale searchParams between navigations. View detailed explanation.

Instead, use the Page searchParams prop or the useSearchParams hook in a Client Component, which is re-rendered on the client with the latest searchParams.

You can use useRouter or Link to set new searchParams. After a navigation is performed, the current page.js will receive an updated searchParams prop.

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useSearchParams } from 'next/navigation'
 
export default function SearchBar() {
  const searchParams = useSearchParams()
 
  const search = searchParams.get('search')
 
  // URL -> `/dashboard?search=my-project`
  // `search` -> 'my-project'
  return <>Search: {search}</>
}
```

Example 2 (javascript):
```javascript
const searchParams = useSearchParams()
```

Example 3 (python):
```python
'use client'
 
import { useSearchParams } from 'next/navigation'
 
export default function SearchBar() {
  const searchParams = useSearchParams()
 
  const search = searchParams.get('search')
 
  // This will not be logged on the server when using static rendering
  console.log(search)
 
  return <>Search: {search}</>
}
```

Example 4 (python):
```python
import { Suspense } from 'react'
import SearchBar from './search-bar'
 
// This component passed as a fallback to the Suspense boundary
// will be rendered in place of the search bar in the initial HTML.
// When the value is available during React hydration the fallback
// will be replaced with the `<SearchBar>` component.
function SearchBarFallback() {
  return <>placeholder</>
}
 
export default function Page() {
  return (
    <>
      <nav>
        <Suspense fallback={<SearchBarFallback />}>
          <SearchBar />
        </Suspense>
      </nav>
      <h1>Dashboard</h1>
    </>
  )
}
```

---

## revalidatePath

**URL:** https://nextjs.org/docs/app/api-reference/functions/revalidatePath

**Contents:**
- revalidatePath
- Usage
- Parameters
- Returns
- What can be invalidated
- Relationship with revalidateTag and updateTag
  - Building revalidation utilities
- Examples
  - Revalidating a specific URL
  - Revalidating a Page path

revalidatePath allows you to invalidate cached data on-demand for a specific path.

revalidatePath can be called in Server Functions and Route Handlers.

revalidatePath cannot be called in Client Components or Proxy, as it only works in server environments.

Use a specific URL when you want to refresh a single page. Use a route pattern plus type to refresh multiple URLs.

revalidatePath does not return a value.

The path parameter can point to pages, layouts, or route handlers:

revalidatePath, revalidateTag and updateTag serve different purposes:

When you call revalidatePath, only the specified path gets fresh data on the next visit. Other pages that use the same data tags will continue to serve cached data until those specific tags are also revalidated:

After calling revalidatePath('/blog'):

Learn about the difference between revalidateTag and updateTag.

revalidatePath and updateTag are complementary primitives that are often used together in utility functions to ensure comprehensive data consistency across your application:

This pattern ensures that both the specific page and any other pages using the same data remain consistent.

This will invalidate one specific URL for revalidation on the next page visit.

This will invalidate any URL that matches the provided page file for revalidation on the next page visit. This will not invalidate pages beneath the specific page. For example, /blog/[slug] won't invalidate /blog/[slug]/[author].

This will invalidate any URL that matches the provided layout file for revalidation on the next page visit. This will cause pages beneath with the same layout to be invalidated and revalidated on the next visit. For example, in the above case, /blog/[slug]/[another] would also be invalidated and revalidated on the next visit.

This will purge the Client-side Router Cache, and invalidate the Data Cache for revalidation on the next page visit.

**Examples:**

Example 1 (unknown):
```unknown
revalidatePath(path: string, type?: 'page' | 'layout'): void;
```

Example 2 (javascript):
```javascript
export async function GET() {
  const data = await fetch('https://api.vercel.app/blog', {
    cache: 'force-cache',
  })
 
  return Response.json(await data.json())
}
```

Example 3 (javascript):
```javascript
// Page A: /blog
const posts = await fetch('https://api.vercel.app/blog', {
  next: { tags: ['posts'] },
})
 
// Page B: /dashboard
const recentPosts = await fetch('https://api.vercel.app/blog?limit=5', {
  next: { tags: ['posts'] },
})
```

Example 4 (python):
```python
'use server'
 
import { revalidatePath, updateTag } from 'next/cache'
 
export async function updatePost() {
  await updatePostInDatabase()
 
  revalidatePath('/blog') // Refresh the blog page
  updateTag('posts') // Refresh all pages using 'posts' tag
}
```

---

## How to load and optimize scripts

**URL:** https://nextjs.org/docs/pages/guides/scripts

**Contents:**
- How to load and optimize scripts
  - Application Scripts
  - Strategy
  - Offloading Scripts To A Web Worker (experimental)
    - Using custom Partytown configuration
  - Inline Scripts
  - Executing Additional Code
  - Additional Attributes

To load a third-party script for all routes, import next/script and include the script directly in your custom _app:

This script will load and execute when any route in your application is accessed. Next.js will ensure the script will only load once, even if a user navigates between multiple pages.

Recommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any unnecessary impact to performance.

Although the default behavior of next/script allows you to load third-party scripts in any page or layout, you can fine-tune its loading behavior by using the strategy property:

Refer to the next/script API reference documentation to learn more about each strategy and their use cases.

Warning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution.

Scripts that use the worker strategy are offloaded and executed in a web worker with Partytown. This can improve the performance of your site by dedicating the main thread to the rest of your application code.

This strategy is still experimental and can only be used if the nextScriptWorkers flag is enabled in next.config.js:

Then, run next (normally npm run dev or yarn dev) and Next.js will guide you through the installation of the required packages to finish the setup:

You'll see instructions like these: Please install Partytown by running npm install @builder.io/partytown

Once setup is complete, defining strategy="worker" will automatically instantiate Partytown in your application and offload the script to a web worker.

There are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown's tradeoffs documentation for more information.

Although the worker strategy does not require any additional configuration to work, Partytown supports the use of a config object to modify some of its settings, including enabling debug mode and forwarding events and triggers.

If you would like to add additional configuration options, you can include it within the <Head /> component used in a custom _document.js:

In order to modify Partytown's configuration, the following conditions must be met:

Note: If you are using an asset prefix and would like to modify Partytown's default configuration, you must include it as part of the lib path.

Take a look at Partytown's configuration options to see the full list of other properties that can be added.

Inline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces:

Or by using the dangerouslySetInnerHTML property:

Warning: An id property must be assigned for inline scripts in order for Next.js to track and optimize the script.

Event handlers can be used with the Script component to execute additional code after a certain event occurs:

These handlers will only work when next/script is imported and used inside of a Client Component where "use client" is defined as the first line of code:

Refer to the next/script API reference to learn more about each event handler and view examples.

There are many DOM attributes that can be assigned to a <script> element that are not used by the Script component, like nonce or custom data attributes. Including any additional attributes will automatically forward it to the final, optimized <script> element that is included in the HTML.

**Examples:**

Example 1 (python):
```python
import Script from 'next/script'
 
export default function MyApp({ Component, pageProps }) {
  return (
    <>
      <Component {...pageProps} />
      <Script src="https://example.com/script.js" />
    </>
  )
}
```

Example 2 (unknown):
```unknown
module.exports = {
  experimental: {
    nextScriptWorkers: true,
  },
}
```

Example 3 (unknown):
```unknown
npm run dev
```

Example 4 (python):
```python
import Script from 'next/script'
 
export default function Home() {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="worker" />
    </>
  )
}
```

---

## How to configure Continuous Integration (CI) build caching

**URL:** https://nextjs.org/docs/pages/guides/ci-build-caching

**Contents:**
- How to configure Continuous Integration (CI) build caching
- Vercel
- CircleCI
- Travis CI
- GitLab CI
- Netlify CI
- AWS CodeBuild
- GitHub Actions
- Bitbucket Pipelines
- Heroku

To improve build performance, Next.js saves a cache to .next/cache that is shared between builds.

To take advantage of this cache in Continuous Integration (CI) environments, your CI workflow will need to be configured to correctly persist the cache between builds.

If your CI is not configured to persist .next/cache between builds, you may see a No Cache Detected error.

Here are some example cache configurations for common CI providers:

Next.js caching is automatically configured for you. There's no action required on your part. If you are using Turborepo on Vercel, learn more here.

Edit your save_cache step in .circleci/config.yml to include .next/cache:

If you do not have a save_cache key, please follow CircleCI's documentation on setting up build caching.

Add or merge the following into your .travis.yml:

Add or merge the following into your .gitlab-ci.yml:

Use Netlify Plugins with @netlify/plugin-nextjs.

Add (or merge in) the following to your buildspec.yml:

Using GitHub's actions/cache, add the following step in your workflow file:

Add or merge the following into your bitbucket-pipelines.yml at the top level (same level as pipelines):

Then reference it in the caches section of your pipeline's step:

Using Heroku's custom cache, add a cacheDirectories array in your top-level package.json:

Using Azure Pipelines' Cache task, add the following task to your pipeline yaml file somewhere prior to the task that executes next build:

Using Jenkins' Job Cacher plugin, add the following build step to your Jenkinsfile where you would normally run next build or npm install:

**Examples:**

Example 1 (unknown):
```unknown
steps:
  - save_cache:
      key: dependency-cache-{{ checksum "yarn.lock" }}
      paths:
        - ./node_modules
        - ./.next/cache
```

Example 2 (unknown):
```unknown
cache:
  directories:
    - $HOME/.cache/yarn
    - node_modules
    - .next/cache
```

Example 3 (unknown):
```unknown
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .next/cache/
```

Example 4 (unknown):
```unknown
cache:
  paths:
    - 'node_modules/**/*' # Cache `node_modules` for faster `yarn` or `npm i`
    - '.next/cache/**/*' # Cache Next.js for faster application rebuilds
```

---

## Prefetching

**URL:** https://nextjs.org/docs/15/app/guides/prefetching

**Contents:**
- Prefetching
- How does prefetching work?
- Prefetching static vs. dynamic routes
- Automatic prefetch
- Manual prefetch
- Hover-triggered prefetch
- Extending or ejecting link
- Disabled prefetch
- Prefetching optimizations
  - Client cache

Prefetching makes navigating between different routes in your application feel instant. Next.js tries to intelligently prefetch by default, based on the links used in your application code.

This guide will explain how prefetching works and show common implementation patterns:

When navigating between routes, the browser requests assets for the page like HTML and JavaScript files. Prefetching is the process of fetching these resources ahead of time, before you navigate to a new route.

Next.js automatically splits your application into smaller JavaScript chunks based on routes. Instead of loading all the code upfront like traditional SPAs, only the code needed for the current route is loaded. This reduces the initial load time while other parts of the app are loaded in the background. By the time you click the link, the resources for the new route have already been loaded into the browser cache.

When navigating to the new page, there's no full page reload or browser loading spinner. Instead, Next.js performs a client-side transition, making the page navigation feel instant.

Good to know: During the initial navigation, the browser fetches the HTML, JavaScript, and React Server Components (RSC) Payload. For subsequent navigations, the browser will fetch the RSC Payload for Server Components and JS bundle for Client Components.

Automatic prefetching runs only in production. Disable with prefetch={false} or use the wrapper in Disabled Prefetch.

Call router.prefetch() to warm routes outside the viewport or in response to analytics, hover, scroll, etc.

Proceed with caution: Extending Link opts you into maintaining prefetching, cache invalidation, and accessibility concerns. Proceed only if defaults are insufficient.

Next.js tries to do the right prefetching by default, but power users can eject and modify based on their needs. You have the control between performance and resource consumption.

For example, you might have to only trigger prefetches on hover, instead of when entering the viewport (the default behavior):

prefetch={null} restores default (static) prefetching once the user shows intent.

You can extend the <Link> component to create your own custom prefetching strategy. For example, using the ForesightJS library which prefetches links by predicting the direction of the user's cursor.

Alternatively, you can use useRouter to recreate some of the native <Link> behavior. However, be aware this opts you into maintaining prefetching and cache invalidation.

onInvalidate is invoked when Next.js suspects cached data is stale, allowing you to refresh the prefetch.

Good to know: Using an a tag will cause a full page navigation to the destination route, you can use onClick to prevent the full page navigation, and then invoke router.push to navigate to the destination.

You can fully disable prefetching for certain routes for more fine-grained control over resource consumption.

For example, you may still want to have consistent usage of <Link> in your application, but links in your footer might not need to be prefetched when entering the viewport.

Good to know: Layout deduplication and prefetch scheduling are part of upcoming optimizations. Currently available in Next.js canary via the experimental.clientSegmentCache flag.

Next.js stores prefetched React Server Component payloads in memory, keyed by route segments. When navigating between sibling routes (e.g. /dashboard/settings â†’ /dashboard/analytics), it reuses the parent layout and only fetches the updated leaf page. This reduces network traffic and improves navigation speed.

Next.js maintains a small task queue, which prefetches in the following order:

The scheduler prioritizes likely navigations while minimizing unused downloads.

When PPR is enabled, a page is divided into a static shell and a streamed dynamic section:

If your layouts or pages are not pure and have side-effects (e.g. tracking analytics), these might be triggered when the route is prefetched, not when the user visits the page.

To avoid this, you should move side-effects to a useEffect hook or a Server Action triggered from a Client Component.

Next.js automatically prefetches links in the viewport when using the <Link> component.

There may be cases where you want to prevent this to avoid unnecessary usage of resources, such as when rendering a large list of links (e.g. an infinite scroll table).

You can disable prefetching by setting the prefetch prop of the <Link> component to false.

However, this means static routes will only be fetched on click, and dynamic routes will wait for the server to render before navigating.

To reduce resource usage without disabling prefetch entirely, you can defer prefetching until the user hovers over a link. This targets only links the user is likely to visit.

**Examples:**

Example 1 (python):
```python
import Link from 'next/link'
 
export default function NavLink() {
  return <Link href="/about">About</Link>
}
```

Example 2 (python):
```python
'use client'
 
import { useRouter } from 'next/navigation'
 
const router = useRouter()
router.prefetch('/pricing')
```

Example 3 (python):
```python
'use client'
 
import Link from 'next/link'
import { useState } from 'react'
 
export function HoverPrefetchLink({
  href,
  children,
}: {
  href: string
  children: React.ReactNode
}) {
  const [active, setActive] = useState(false)
 
  return (
    <Link
      href={href}
      prefetch={active ? null : false}
      onMouseEnter={() => setActive(true)}
    >
      {children}
    </Link>
  )
}
```

Example 4 (python):
```python
'use client'
 
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'
 
function ManualPrefetchLink({
  href,
  children,
}: {
  href: string
  children: React.ReactNode
}) {
  const router = useRouter()
 
  useEffect(() => {
    let cancelled = false
    const poll = () => {
      if (!cancelled) router.prefetch(href, { onInvalidate: poll })
    }
    poll()
    return () => {
      cancelled = true
    }
  }, [href, router])
 
  return (
    <a
      href={href}
      onClick={(event) => {
        event.preventDefault()
        router.push(href)
      }}
    >
      {children}
    </a>
  )
}
```

---

## How to optimize your local development environment

**URL:** https://nextjs.org/docs/15/app/guides/local-development

**Contents:**
- How to optimize your local development environment
- Local dev vs. production
- Improving local dev performance
  - 1. Check your computer's antivirus
  - 2. Update Next.js and enable Turbopack
  - 3. Check your imports
    - Icon libraries
    - Barrel files
    - Optimize package imports
  - 4. Check your Tailwind CSS setup

Next.js is designed to provide a great developer experience. As your application grows, you might notice slower compilation times during local development. This guide will help you identify and fix common compile-time performance issues.

The development process with next dev is different than next build and next start.

next dev compiles routes in your application as you open or navigate to them. This enables you to start the dev server without waiting for every route in your application to compile, which is both faster and uses less memory. Running a production build applies other optimizations, like minifying files and creating content hashes, which are not needed for local development.

Antivirus software can slow down file access.

Try adding your project folder to the antivirus exclusion list. While this is more common on Windows machines, we recommend this for any system with an antivirus tool installed.

Make sure you're using the latest version of Next.js. Each new version often includes performance improvements.

Turbopack is a new bundler integrated into Next.js that can improve local performance.

Learn more about Turbopack. See our upgrade guides and codemods for more information.

The way you import code can greatly affect compilation and bundling time. Learn more about optimizing package bundling and explore tools like Dependency Cruiser or Madge.

Libraries like @material-ui/icons, @phosphor-icons/react, or react-icons can import thousands of icons, even if you only use a few. Try to import only the icons you need:

You can often find what import pattern to use in the documentation for the icon library you're using. This example follows @phosphor-icons/react recommendation.

Libraries like react-icons includes many different icon sets. Choose one set and stick with that set.

For example, if your application uses react-icons and imports all of these:

Combined they will be tens of thousands of modules that the compiler has to handle, even if you only use a single import from each.

"Barrel files" are files that export many items from other files. They can slow down builds because the compiler has to parse them to find if there are side-effects in the module scope by using the import.

Try to import directly from specific files when possible. Learn more about barrel files and the built-in optimizations in Next.js.

Next.js can automatically optimize imports for certain packages. If you are using packages that utilize barrel files, add them to your next.config.js:

Turbopack automatically analyzes imports and optimizes them. It does not require this configuration.

If you're using Tailwind CSS, make sure it's set up correctly.

A common mistake is configuring your content array in a way which includes node_modules or other large directories of files that should not be scanned.

Tailwind CSS version 3.4.8 or newer will warn you about settings that might slow down your build.

In your tailwind.config.js, be specific about which files to scan:

Avoid scanning unnecessary files:

If you've added custom webpack settings, they might be slowing down compilation.

Consider if you really need them for local development. You can optionally only include certain tools for production builds, or explore moving to Turbopack and using loaders.

If your app is very large, it might need more memory.

Learn more about optimizing memory usage.

Changes to Server Components cause the entire page to re-render locally in order to show the new changes, which includes fetching new data for the component.

The experimental serverComponentsHmrCache option allows you to cache fetch responses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls.

Learn more about the experimental option.

If you're using Docker for development on Mac or Windows, you may experience significantly slower performance compared to running Next.js locally.

Docker's filesystem access on Mac and Windows can cause Hot Module Replacement (HMR) to take seconds or even minutes, while the same application runs with fast HMR when developed locally.

This performance difference is due to how Docker handles filesystem operations outside of Linux environments. For the best development experience:

Learn more about Docker deployment for production use.

Use the logging.fetches option in your next.config.js file, to see more detailed information about what's happening during development:

Learn more about fetch logging.

Turbopack tracing is a tool that helps you understand the performance of your application during local development. It provides detailed information about the time taken for each module to compile and how they are related.

Make sure you have the latest version of Next.js installed.

Generate a Turbopack trace file:

Navigate around your application or make edits to files to reproduce the problem.

Stop the Next.js development server.

A file called trace-turbopack will be available in the .next folder.

You can interpret the file using npx next internal trace [path-to-file]:

On versions where trace is not available, the command was named turbo-trace-server:

Once the trace server is running you can view the trace at https://trace.nextjs.org/.

By default the trace viewer will aggregate timings, in order to see each individual time you can switch from "Aggregated in order" to "Spans in order" at the top right of the viewer.

Share the trace file generated in the Turbopack Tracing section and share it on GitHub Discussions or Discord.

**Examples:**

Example 1 (unknown):
```unknown
npm install next@latest
npm run dev --turbopack
```

Example 2 (python):
```python
// Instead of this:
import { TriangleIcon } from '@phosphor-icons/react'
 
// Do this:
import { TriangleIcon } from '@phosphor-icons/react/dist/csr/Triangle'
```

Example 3 (unknown):
```unknown
module.exports = {
  experimental: {
    optimizePackageImports: ['package-name'],
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  content: [
    './src/**/*.{js,ts,jsx,tsx}', // Good
    // This might be too broad
    // It will match `packages/**/node_modules` too
    // '../../packages/**/*.{js,ts,jsx,tsx}',
  ],
}
```

---

## How to use debugging tools with Next.js

**URL:** https://nextjs.org/docs/app/guides/debugging

**Contents:**
- How to use debugging tools with Next.js
- Debugging with VS Code
- Using the Debugger in Jetbrains WebStorm
- Debugging with Browser DevTools
  - Client-side code
  - React Developer Tools
  - Server-side code
  - Inspect Server Errors with Browser DevTools
  - Debugging on Windows
- More information

This documentation explains how you can debug your Next.js frontend and backend code with full source maps support using the VS Code debugger, Chrome DevTools, or Firefox DevTools.

Any debugger that can attach to Node.js can also be used to debug a Next.js application. You can find more details in the Node.js Debugging Guide.

Create a file named .vscode/launch.json at the root of your project with the following content:

Note: To use Firefox debugging in VS Code, you'll need to install the Firefox Debugger extension.

npm run dev can be replaced with yarn dev if you're using Yarn or pnpm dev if you're using pnpm.

In the "Next.js: debug full stack" configuration, serverReadyAction.action specifies which browser to open when the server is ready. debugWithEdge means to launch the Edge browser. If you are using Chrome, change this value to debugWithChrome.

If you're changing the port number your application starts on, replace the 3000 in http://localhost:3000 with the port you're using instead.

If you're running Next.js from a directory other than root (for example, if you're using Turborepo) then you need to add cwd to the server-side and full stack debugging tasks. For example, "cwd": "${workspaceFolder}/apps/web".

Now go to the Debug panel (Ctrl+Shift+D on Windows/Linux, â‡§+âŒ˜+D on macOS), select a launch configuration, then press F5 or select Debug: Start Debugging from the Command Palette to start your debugging session.

Click the drop down menu listing the runtime configuration, and click Edit Configurations.... Create a JavaScript Debug debug configuration with http://localhost:3000 as the URL. Customize to your liking (e.g. Browser for debugging, store as project file), and click OK. Run this debug configuration, and the selected browser should automatically open. At this point, you should have 2 applications in debug mode: the NextJS node application, and the client/browser application.

Start your development server as usual by running next dev, npm run dev, or yarn dev. Once the server starts, open http://localhost:3000 (or your alternate URL) in your preferred browser.

In either browser, any time your client-side code reaches a debugger statement, code execution will pause and that file will appear in the debug area. You can also search for files to set breakpoints manually:

Note that when searching, your source files will have paths starting with webpack://_N_E/./.

For React-specific debugging, install the React Developer Tools browser extension. This essential tool helps you:

To debug server-side Next.js code with browser DevTools, you need to pass the --inspect flag:

The value of --inspect is passed to the underlying Node.js process. Check out the --inspect docs for advanced use cases.

Good to know: Use --inspect=0.0.0.0 to allow remote debugging access outside localhost, such as when running the app in a Docker container.

Launching the Next.js dev server with the --inspect flag will look something like this:

Debugging server-side code works similarly to client-side debugging. When searching for files (Ctrl+P/âŒ˜+P), your source files will have paths starting with webpack://{application-name}/./ (where {application-name} will be replaced with the name of your application according to your package.json file).

To use --inspect-brk or --inspect-wait, you have to specify NODE_OPTIONS instead. e.g. NODE_OPTIONS=--inspect-brk next dev.

When you encounter an error, inspecting the source code can help trace the root cause of errors.

Next.js will display a Node.js icon underneath the Next.js version indicator on the error overlay. By clicking that icon, the DevTools URL is copied to your clipboard. You can open a new browser tab with that URL to inspect the Next.js server process.

Ensure Windows Defender is disabled on your machine. This external service will check every file read, which has been reported to greatly increase Fast Refresh time with next dev. This is a known issue, not related to Next.js, but it does affect Next.js development.

To learn more about how to use a JavaScript debugger, take a look at the following documentation:

**Examples:**

Example 1 (unknown):
```unknown
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Next.js: debug server-side",
      "type": "node-terminal",
      "request": "launch",
      "command": "npm run dev -- --inspect"
    },
    {
      "name": "Next.js: debug client-side",
      "type": "chrome",
      "request": "launch",
      "url": "http://localhost:3000"
    },
    {
      "name": "Next.js: debug client-side (Firefox)",
      "type": "firefox",
      "request": "launch",
      "url": "http://localhost:3000",
      "reAttach": true,
      "pathMappings": [
        {
          "url": "webpack://_N_E",
          "path": "${workspaceFolder}"
        }
      ]
    },
    {
      "name": "Next.js: debug full stack",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/node_modules/next/dist/bin/next",
      "runtimeArgs": ["--inspect"],
      "skipFiles": ["<node_internals>/**"],
      "serverReadyAction": {
        "action": "debugWithEdge",
        "killOnServerStop": true,
        "pattern": "- Local:.+(https?://.+)",
        "uriFormat": "%s",
        "webRoot": "${workspaceFolder}"
      }
    }
  ]
}
```

Example 2 (unknown):
```unknown
next dev --inspect
```

Example 3 (unknown):
```unknown
Debugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95
For help, see: https://nodejs.org/en/docs/inspector
ready - started server on 0.0.0.0:3000, url: http://localhost:3000
```

---

## Guides

**URL:** https://nextjs.org/docs/app/guides

**Contents:**
- Guides
  - Analytics
  - Authentication
  - Backend for Frontend
  - Caching
  - CI Build Caching
  - Content Security Policy
  - CSS-in-JS
  - Custom Server
  - Data Security

---

## robots.txt

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots

**Contents:**
- robots.txt
- Static robots.txt
- Generate a Robots file
  - Customizing specific user agents
  - Robots object
- Version History

Add or generate a robots.txt file that matches the Robots Exclusion Standard in the root of app directory to tell search engine crawlers which URLs they can access on your site.

Add a robots.js or robots.ts file that returns a Robots object.

Good to know: robots.js is a special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.

You can customise how individual search engine bots crawl your site by passing an array of user agents to the rules property. For example:

**Examples:**

Example 1 (unknown):
```unknown
User-Agent: *
Allow: /
Disallow: /private/

Sitemap: https://acme.com/sitemap.xml
```

Example 2 (python):
```python
import type { MetadataRoute } from 'next'
 
export default function robots(): MetadataRoute.Robots {
  return {
    rules: {
      userAgent: '*',
      allow: '/',
      disallow: '/private/',
    },
    sitemap: 'https://acme.com/sitemap.xml',
  }
}
```

Example 3 (unknown):
```unknown
User-Agent: *
Allow: /
Disallow: /private/

Sitemap: https://acme.com/sitemap.xml
```

Example 4 (python):
```python
import type { MetadataRoute } from 'next'
 
export default function robots(): MetadataRoute.Robots {
  return {
    rules: [
      {
        userAgent: 'Googlebot',
        allow: ['/'],
        disallow: '/private/',
      },
      {
        userAgent: ['Applebot', 'Bingbot'],
        disallow: ['/'],
      },
    ],
    sitemap: 'https://acme.com/sitemap.xml',
  }
}
```

---

## getServerSideProps

**URL:** https://nextjs.org/docs/pages/api-reference/functions/get-server-side-props

**Contents:**
- getServerSideProps
- Context parameter
- getServerSideProps return values
  - props
  - notFound
  - redirect
- Version History

When exporting a function called getServerSideProps (Server-Side Rendering) from a page, Next.js will pre-render this page on each request using the data returned by getServerSideProps. This is useful if you want to fetch data that changes often, and have the page update to show the most current data.

You can import modules in top-level scope for use in getServerSideProps. Imports used will not be bundled for the client-side. This means you can write server-side code directly in getServerSideProps, including fetching data from your database.

The context parameter is an object containing the following keys:

The getServerSideProps function should return an object with any one of the following properties:

The props object is a key-value pair, where each value is received by the page component. It should be a serializable object so that any props passed, could be serialized with JSON.stringify.

The notFound boolean allows the page to return a 404 status and 404 Page. With notFound: true, the page will return a 404 even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author.

The redirect object allows redirecting to internal and external resources. It should match the shape of { destination: string, permanent: boolean }. In some rare cases, you might need to assign a custom status code for older HTTP clients to properly redirect. In these cases, you can use the statusCode property instead of the permanent property, but not both.

**Examples:**

Example 1 (python):
```python
import type { InferGetServerSidePropsType, GetServerSideProps } from 'next'
 
type Repo = {
  name: string
  stargazers_count: number
}
 
export const getServerSideProps = (async () => {
  // Fetch data from external API
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo: Repo = await res.json()
  // Pass data to the page via props
  return { props: { repo } }
}) satisfies GetServerSideProps<{ repo: Repo }>
 
export default function Page({
  repo,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return (
    <main>
      <p>{repo.stargazers_count}</p>
    </main>
  )
}
```

Example 2 (unknown):
```unknown
export async function getServerSideProps(context) {
  return {
    props: { message: `Next.js is awesome` }, // will be passed to the page component as props
  }
}
```

Example 3 (javascript):
```javascript
export async function getServerSideProps(context) {
  const res = await fetch(`https://.../data`)
  const data = await res.json()
 
  if (!data) {
    return {
      notFound: true,
    }
  }
 
  return {
    props: { data }, // will be passed to the page component as props
  }
}
```

Example 4 (javascript):
```javascript
export async function getServerSideProps(context) {
  const res = await fetch(`https://.../data`)
  const data = await res.json()
 
  if (!data) {
    return {
      redirect: {
        destination: '/',
        permanent: false,
      },
    }
  }
 
  return {
    props: {}, // will be passed to the page component as props
  }
}
```

---

## distDir

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/distDir

**Contents:**
- distDir

You can specify a name to use for a custom build directory to use instead of .next.

Open next.config.js and add the distDir config:

Now if you run next build Next.js will use build instead of the default .next folder.

distDir should not leave your project directory. For example, ../build is an invalid directory.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  distDir: 'build',
}
```

---

## use cache: remote

**URL:** https://nextjs.org/docs/app/api-reference/directives/use-cache-remote

**Contents:**
- use cache: remote
- Usage
  - Basic example
- How use cache: remote differs from use cache and use cache: private
  - When to use each directive
- How it works
  - Dynamic context detection
  - Storage behavior
  - Dynamic context example
- Request APIs and remote caches

The 'use cache: remote' directive enables caching of shared data in dynamic contexts where regular use cache would not work, for example after calling await connection(), await cookies() or await headers().

To use 'use cache: remote', enable the cacheComponents flag in your next.config.ts file:

Then add 'use cache: remote' to your function that needs to cache data in a dynamic context.

Cache product pricing that needs to be fetched at request time but can be shared across all users. Use cacheLife to set the cache lifetime of the price.

Note: Regular use cache will not cache anything when used in a dynamic context (after await connection(), await cookies(), await headers(), etc.). Use 'use cache: remote' to enable runtime caching in these scenarios.

Next.js provides three caching directives, each designed for different use cases:

Note: While you can't call await cookies() or await headers() inside 'use cache: remote', you can read the values before calling a function that is wrapped by 'use cache: remote' and the arguments will be included in the cache key. Note that this is not recommended as it will dramatically increase the cache size and reduce the cache hit rate.

Choose the right caching directive based on your use case:

Use 'use cache: remote' when:

Use 'use cache: private' when:

The 'use cache: remote' directive enables runtime caching of shared data in dynamic contexts by storing results in server-side cache handlers rather than prerendering at build time.

When Next.js encounters certain APIs like connection(), cookies(), or headers(), the context becomes "dynamic". In a dynamic context:

Good to know: Without 'use cache: remote', functions in dynamic contexts would execute on every request, potentially creating performance bottlenecks. Remote caching eliminates this issue by storing results in server-side cache handlers.

Remote caches are persisted using server-side cache handlers, which may include:

While 'use cache: remote' technically allows access to request-specific data by calling API's like cookies() and headers() before calling a function that is wrapped by 'use cache: remote', it's generally not recommended to use them together:

Important: If you need to cache based on cookies, headers, or search params, use 'use cache: private' instead. Remote caches are shared across all users, so caching user-specific data in them can lead to incorrect results being served to different users.

Remote caches have specific nesting rules:

The following examples demonstrate common patterns for using 'use cache: remote'. For details about cacheLife parameters (stale, revalidate, expire), see the cacheLife API reference.

Cache expensive database queries that are accessed in dynamic contexts, reducing load on your database:

Cache API responses that are fetched during streaming or after dynamic operations:

Cache expensive computations that occur after dynamic security or feature checks:

Combine static, remote, and private caching for optimal performance:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  cacheComponents: true,
}
 
export default nextConfig
```

Example 2 (python):
```python
import { Suspense } from 'react'
import { connection } from 'next/server'
import { cacheTag, cacheLife } from 'next/cache'
 
export default async function ProductPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
 
  return (
    <div>
      <ProductDetails id={id} />
      <Suspense fallback={<div>Loading price...</div>}>
        <ProductPrice productId={id} />
      </Suspense>
    </div>
  )
}
 
function ProductDetails({ id }: { id: string }) {
  return <div>Product: {id}</div>
}
 
async function ProductPrice({ productId }: { productId: string }) {
  // Calling connection() makes this component dynamic, preventing
  // it from being included in the static shell. This ensures the price
  // is always fetched at request time.
  await connection()
 
  // Now we can cache the price in a remote cache handler.
  // Regular 'use cache' would NOT work here because we're in a dynamic context.
  const price = await getProductPrice(productId)
 
  return <div>Price: ${price}</div>
}
 
async function getProductPrice(productId: string) {
  'use cache: remote'
  cacheTag(`product-price-${productId}`)
  cacheLife({ expire: 3600 }) // 1 hour
 
  // This database query is cached and shared across all users
  return db.products.getPrice(productId)
}
```

Example 3 (javascript):
```javascript
async function UserDashboard() {
  // Calling connection() makes the context dynamic
  await connection()
 
  // Without any caching directive, this runs on every request
  const stats = await getStats()
 
  // With 'use cache: remote', this is cached in the remote handler
  const analytics = await getAnalytics()
 
  return (
    <div>
      <Stats data={stats} />
      <Analytics data={analytics} />
    </div>
  )
}
 
async function getAnalytics() {
  'use cache: remote'
  cacheLife({ expire: 300 }) // 5 minutes
 
  // This expensive operation is cached and shared across all requests
  return fetchAnalyticsData()
}
```

Example 4 (javascript):
```javascript
// VALID: Remote inside remote
async function outerRemote() {
  'use cache: remote'
  const result = await innerRemote()
  return result
}
 
async function innerRemote() {
  'use cache: remote'
  return getData()
}
 
// VALID: Remote inside regular cache
async function outerCache() {
  'use cache'
  // If this is in a dynamic context, the inner remote cache will work
  const result = await innerRemote()
  return result
}
 
async function innerRemote() {
  'use cache: remote'
  return getData()
}
 
// INVALID: Remote inside private
async function outerPrivate() {
  'use cache: private'
  const result = await innerRemote() // Error!
  return result
}
 
async function innerRemote() {
  'use cache: remote'
  return getData()
}
 
// INVALID: Private inside remote
async function outerRemote() {
  'use cache: remote'
  const result = await innerPrivate() // Error!
  return result
}
 
async function innerPrivate() {
  'use cache: private'
  return getData()
}
```

---

## unstable_rethrow

**URL:** https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow

**Contents:**
- unstable_rethrow

unstable_rethrow can be used to avoid catching internal errors thrown by Next.js when attempting to handle errors thrown in your application code.

For example, calling the notFound function will throw an internal Next.js error and render the not-found.js component. However, if used inside the try block of a try/catch statement, the error will be caught, preventing not-found.js from rendering:

You can use unstable_rethrow API to re-throw the internal error and continue with the expected behavior:

The following Next.js APIs rely on throwing an error which should be rethrown and handled by Next.js itself:

If a route segment is marked to throw an error unless it's static, a Dynamic API call will also throw an error that should similarly not be caught by the developer. Note that Partial Prerendering (PPR) affects this behavior as well. These APIs are:

**Examples:**

Example 1 (python):
```python
import { notFound } from 'next/navigation'
 
export default async function Page() {
  try {
    const post = await fetch('https://.../posts/1').then((res) => {
      if (res.status === 404) notFound()
      if (!res.ok) throw new Error(res.statusText)
      return res.json()
    })
  } catch (err) {
    console.error(err)
  }
}
```

Example 2 (python):
```python
import { notFound, unstable_rethrow } from 'next/navigation'
 
export default async function Page() {
  try {
    const post = await fetch('https://.../posts/1').then((res) => {
      if (res.status === 404) notFound()
      if (!res.ok) throw new Error(res.statusText)
      return res.json()
    })
  } catch (err) {
    unstable_rethrow(err)
    console.error(err)
  }
}
```

---

## How to upgrade to version 11

**URL:** https://nextjs.org/docs/pages/guides/upgrading/version-11

**Contents:**
- How to upgrade to version 11
  - Webpack 5
  - Cleaning the distDir is now a default
  - PORT is now supported for next dev and next start
  - next.config.js customization to import images
  - Remove super.componentDidCatch() from pages/_app.js
  - Remove Container from pages/_app.js
  - Remove props.url usage from page components
  - Remove unsized property on next/image
  - Remove modules property on next/dynamic

To upgrade to version 11, run the following command:

Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions.

Webpack 5 is now the default for all Next.js applications. If you did not have a custom webpack configuration, your application is already using webpack 5. If you do have a custom webpack configuration, you can refer to the Next.js webpack 5 documentation for upgrade guidance.

The build output directory (defaults to .next) is now cleared by default except for the Next.js caches. You can refer to the cleaning distDir RFC for more information.

If your application was relying on this behavior previously you can disable the new default behavior by adding the cleanDistDir: false flag in next.config.js.

Next.js 11 supports the PORT environment variable to set the port the application runs on. Using -p/--port is still recommended but if you were prohibited from using -p in any way you can now use PORT as an alternative:

Next.js 11 supports static image imports with next/image. This new feature relies on being able to process image imports. If you previously added the next-images or next-optimized-images packages you can either move to the new built-in support using next/image or disable the feature:

The next/app component's componentDidCatch was deprecated in Next.js 9 as it's no longer needed and has since been a no-op. In Next.js 11, it was removed.

If your pages/_app.js has a custom componentDidCatch method you can remove super.componentDidCatch as it is no longer needed.

This export was deprecated in Next.js 9 as it's no longer needed and has since been a no-op with a warning during development. In Next.js 11 it was removed.

If your pages/_app.js imports Container from next/app you can remove Container as it was removed. Learn more in the documentation.

This property was deprecated in Next.js 4 and has since shown a warning during development. With the introduction of getStaticProps / getServerSideProps these methods already disallowed the usage of props.url. In Next.js 11, it was removed completely.

You can learn more in the documentation.

The unsized property on next/image was deprecated in Next.js 10.0.1. You can use layout="fill" instead. In Next.js 11 unsized was removed.

The modules and render option for next/dynamic were deprecated in Next.js 9.5. This was done in order to make the next/dynamic API closer to React.lazy. In Next.js 11, the modules and render options were removed.

This option hasn't been mentioned in the documentation since Next.js 8 so it's less likely that your application is using it.

If your application does use modules and render you can refer to the documentation.

Head.rewind has been a no-op since Next.js 9.5, in Next.js 11 it was removed. You can safely remove your usage of Head.rewind.

Moment.js includes translations for a lot of locales by default. Next.js now automatically excludes these locales by default to optimize bundle size for applications using Moment.js.

To load a specific locale use this snippet:

You can opt-out of this new default by adding excludeDefaultMomentLocales: false to next.config.js if you do not want the new behavior, do note it's highly recommended to not disable this new optimization as it significantly reduces the size of Moment.js.

In case you're accessing router.events during rendering, in Next.js 11 router.events is no longer provided during pre-rendering. Ensure you're accessing router.events in useEffect:

If your application uses router.router.events which was an internal property that was not public please make sure to use router.events as well.

React 17 introduced a new JSX Transform that brings a long-time Next.js feature to the wider React ecosystem: Not having to import React from 'react' when using JSX. When using React 17 Next.js will automatically use the new transform. This transform does not make the React variable global, which was an unintended side-effect of the previous Next.js implementation. A codemod is available to automatically fix cases where you accidentally used React without importing it.

Most applications already use the latest version of React, with Next.js 11 the minimum React version has been updated to 17.0.2.

To upgrade you can run the following command:

**Examples:**

Example 1 (unknown):
```unknown
npm i next@11 react@17 react-dom@17
```

Example 2 (unknown):
```unknown
yarn add next@11 react@17 react-dom@17
```

Example 3 (unknown):
```unknown
pnpm up next@11 react@17 react-dom@17
```

Example 4 (unknown):
```unknown
bun add next@11 react@17 react-dom@17
```

---

## typescript

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/typescript

**Contents:**
- typescript

Next.js fails your production build (next build) when TypeScript errors are present in your project.

If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.

Open next.config.js and enable the ignoreBuildErrors option in the typescript config:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}
```

---

## Head

**URL:** https://nextjs.org/docs/pages/api-reference/components/head

**Contents:**
- Head
- Avoid duplicated tags
- Use minimal nesting
- Use next/script for scripts
- No html or body tags

We expose a built-in component for appending elements to the head of the page:

To avoid duplicate tags in your head you can use the key property, which will make sure the tag is only rendered once, as in the following example:

In this case only the second <meta property="og:title" /> is rendered. meta tags with duplicate key attributes are automatically handled.

Good to know: <title> and <base> tags are automatically checked for duplicates by Next.js, so using key is not necessary for these tags.

The contents of head get cleared upon unmounting the component, so make sure each page completely defines what it needs in head, without making assumptions about what other pages added.

title, meta or any other elements (e.g. script) need to be contained as direct children of the Head element, or wrapped into maximum one level of <React.Fragment> or arraysâ€”otherwise the tags won't be correctly picked up on client-side navigations.

We recommend using next/script in your component instead of manually creating a <script> in next/head.

You cannot use <Head> to set attributes on <html> or <body> tags. This will result in an next-head-count is missing error. next/head can only handle tags inside the HTML <head> tag.

**Examples:**

Example 1 (python):
```python
import Head from 'next/head'
 
function IndexPage() {
  return (
    <div>
      <Head>
        <title>My page title</title>
      </Head>
      <p>Hello world!</p>
    </div>
  )
}
 
export default IndexPage
```

Example 2 (python):
```python
import Head from 'next/head'
 
function IndexPage() {
  return (
    <div>
      <Head>
        <title>My page title</title>
        <meta property="og:title" content="My page title" key="title" />
      </Head>
      <Head>
        <meta property="og:title" content="My new title" key="title" />
      </Head>
      <p>Hello world!</p>
    </div>
  )
}
 
export default IndexPage
```

---

## ImageResponse

**URL:** https://nextjs.org/docs/app/api-reference/functions/image-response

**Contents:**
- ImageResponse
- Reference
  - Parameters
  - Supported HTML and CSS features
- Behavior
- Examples
  - Route Handlers
  - File-based Metadata
  - Custom fonts
- Version History

The ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for generating social media images such as Open Graph images, Twitter cards, and more.

The following parameters are available for ImageResponse:

Examples are available in the Vercel OG Playground.

ImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images.

Please refer to Satoriâ€™s documentation for a list of supported HTML and CSS features.

ImageResponse can be used in Route Handlers to generate images dynamically at request time.

You can use ImageResponse in a opengraph-image.tsx file to generate Open Graph images at build time or dynamically at request time.

You can use custom fonts in your ImageResponse by providing a fonts array in the options.

**Examples:**

Example 1 (python):
```python
import { ImageResponse } from 'next/og'
 
new ImageResponse(
  element: ReactElement,
  options: {
    width?: number = 1200
    height?: number = 630
    emoji?: 'twemoji' | 'blobmoji' | 'noto' | 'openmoji' = 'twemoji',
    fonts?: {
      name: string,
      data: ArrayBuffer,
      weight: number,
      style: 'normal' | 'italic'
    }[]
    debug?: boolean = false
 
    // Options that will be passed to the HTTP response
    status?: number = 200
    statusText?: string
    headers?: Record<string, string>
  },
)
```

Example 2 (python):
```python
import { ImageResponse } from 'next/og'
 
export async function GET() {
  try {
    return new ImageResponse(
      (
        <div
          style={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: 'white',
            padding: '40px',
          }}
        >
          <div
            style={{
              fontSize: 60,
              fontWeight: 'bold',
              color: 'black',
              textAlign: 'center',
            }}
          >
            Welcome to My Site
          </div>
          <div
            style={{
              fontSize: 30,
              color: '#666',
              marginTop: '20px',
            }}
          >
            Generated with Next.js ImageResponse
          </div>
        </div>
      ),
      {
        width: 1200,
        height: 630,
      }
    )
  } catch (e) {
    console.log(`${e.message}`)
    return new Response(`Failed to generate the image`, {
      status: 500,
    })
  }
}
```

Example 3 (python):
```python
import { ImageResponse } from 'next/og'
 
// Image metadata
export const alt = 'My site'
export const size = {
  width: 1200,
  height: 630,
}
 
export const contentType = 'image/png'
 
// Image generation
export default async function Image() {
  return new ImageResponse(
    (
      // ImageResponse JSX element
      <div
        style={{
          fontSize: 128,
          background: 'white',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        My site
      </div>
    ),
    // ImageResponse options
    {
      // For convenience, we can re-use the exported opengraph-image
      // size config to also set the ImageResponse's width and height.
      ...size,
    }
  )
}
```

Example 4 (python):
```python
import { ImageResponse } from 'next/og'
import { readFile } from 'node:fs/promises'
import { join } from 'node:path'
 
// Image metadata
export const alt = 'My site'
export const size = {
  width: 1200,
  height: 630,
}
 
export const contentType = 'image/png'
 
// Image generation
export default async function Image() {
  // Font loading, process.cwd() is Next.js project directory
  const interSemiBold = await readFile(
    join(process.cwd(), 'assets/Inter-SemiBold.ttf')
  )
 
  return new ImageResponse(
    (
      // ...
    ),
    // ImageResponse options
    {
      // For convenience, we can re-use the exported opengraph-image
      // size config to also set the ImageResponse's width and height.
      ...size,
      fonts: [
        {
          name: 'Inter',
          data: interSemiBold,
          style: 'normal',
          weight: 400,
        },
      ],
    }
  )
}
```

---

## CLI

**URL:** https://nextjs.org/docs/15/app/api-reference/cli

**Contents:**
- CLI
  - create-next-app
  - next CLI

Next.js comes with two Command Line Interface (CLI) tools:

---

## headers

**URL:** https://nextjs.org/docs/app/api-reference/functions/headers

**Contents:**
- headers
- Reference
  - Parameters
  - Returns
- Good to know
- Examples
  - Using the Authorization header
- Version History

headers is an async function that allows you to read the HTTP incoming request headers from a Server Component.

headers does not take any parameters.

headers returns a read-only Web Headers object.

**Examples:**

Example 1 (python):
```python
import { headers } from 'next/headers'
 
export default async function Page() {
  const headersList = await headers()
  const userAgent = headersList.get('user-agent')
}
```

Example 2 (python):
```python
import { headers } from 'next/headers'
 
export default async function Page() {
  const authorization = (await headers()).get('authorization')
  const res = await fetch('...', {
    headers: { authorization }, // Forward the authorization header
  })
  const user = await res.json()
 
  return <h1>{user.name}</h1>
}
```

---

## How to create a static export of your Next.js application

**URL:** https://nextjs.org/docs/app/guides/static-exports

**Contents:**
- How to create a static export of your Next.js application
- Configuration
- Supported Features
  - Server Components
  - Client Components
  - Image Optimization
  - Route Handlers
  - Browser APIs
- Unsupported Features
- Deploying

Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.

When running next build, Next.js generates an HTML file per route. By breaking a strict SPA into individual HTML files, Next.js can avoid loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.

Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.

To enable a static export, change the output mode inside next.config.js:

After running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application.

The core of Next.js has been designed to support static exports.

When you run next build to generate a static export, Server Components consumed inside the app directory will run during the build, similar to traditional static-site generation.

The resulting component will be rendered into static HTML for the initial page load and a static payload for client navigation between routes. No changes are required for your Server Components when using the static export, unless they consume dynamic server functions.

If you want to perform data fetching on the client, you can use a Client Component with SWR to memoize requests.

Since route transitions happen client-side, this behaves like a traditional SPA. For example, the following index route allows you to navigate to different posts on the client:

Image Optimization through next/image can be used with a static export by defining a custom image loader in next.config.js. For example, you can optimize images with a service like Cloudinary:

This custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for Cloudinary:

You can then use next/image in your application, defining relative paths to the image in Cloudinary:

Route Handlers will render a static response when running next build. Only the GET HTTP verb is supported. This can be used to generate static HTML, JSON, TXT, or other files from cached or uncached data. For example:

The above file app/data.json/route.ts will render to a static file during next build, producing data.json containing { name: 'Lee' }.

If you need to read dynamic values from the incoming request, you cannot use a static export.

Client Components are pre-rendered to HTML during next build. Because Web APIs like window, localStorage, and navigator are not available on the server, you need to safely access these APIs only when running in the browser. For example:

Features that require a Node.js server, or dynamic logic that cannot be computed during the build process, are not supported:

Attempting to use any of these features with next dev will result in an error, similar to setting the dynamic option to error in the root layout.

With a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.

When running next build, Next.js generates the static export into the out folder. For example, let's say you have the following routes:

After running next build, Next.js will generate the following files:

If you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files:

**Examples:**

Example 1 (javascript):
```javascript
/**
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  output: 'export',
 
  // Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html`
  // trailingSlash: true,
 
  // Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href`
  // skipTrailingSlashRedirect: true,
 
  // Optional: Change the output directory `out` -> `dist`
  // distDir: 'dist',
}
 
module.exports = nextConfig
```

Example 2 (javascript):
```javascript
export default async function Page() {
  // This fetch will run on the server during `next build`
  const res = await fetch('https://api.example.com/...')
  const data = await res.json()
 
  return <main>...</main>
}
```

Example 3 (python):
```python
'use client'
 
import useSWR from 'swr'
 
const fetcher = (url: string) => fetch(url).then((r) => r.json())
 
export default function Page() {
  const { data, error } = useSWR(
    `https://jsonplaceholder.typicode.com/posts/1`,
    fetcher
  )
  if (error) return 'Failed to load'
  if (!data) return 'Loading...'
 
  return data.title
}
```

Example 4 (python):
```python
import Link from 'next/link'
 
export default function Page() {
  return (
    <>
      <h1>Index Page</h1>
      <hr />
      <ul>
        <li>
          <Link href="/post/1">Post 1</Link>
        </li>
        <li>
          <Link href="/post/2">Post 2</Link>
        </li>
      </ul>
    </>
  )
}
```

---

## How to load and optimize scripts

**URL:** https://nextjs.org/docs/app/guides/scripts

**Contents:**
- How to load and optimize scripts
  - Layout Scripts
  - Application Scripts
  - Strategy
  - Offloading Scripts To A Web Worker (experimental)
  - Inline Scripts
  - Executing Additional Code
  - Additional Attributes
- API Reference
  - Script Component

To load a third-party script for multiple routes, import next/script and include the script directly in your layout component:

The third-party script is fetched when the folder route (e.g. dashboard/page.js) or any nested route (e.g. dashboard/settings/page.js) is accessed by the user. Next.js will ensure the script will only load once, even if a user navigates between multiple routes in the same layout.

To load a third-party script for all routes, import next/script and include the script directly in your root layout:

This script will load and execute when any route in your application is accessed. Next.js will ensure the script will only load once, even if a user navigates between multiple pages.

Recommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any unnecessary impact to performance.

Although the default behavior of next/script allows you to load third-party scripts in any page or layout, you can fine-tune its loading behavior by using the strategy property:

Refer to the next/script API reference documentation to learn more about each strategy and their use cases.

Warning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution.

Scripts that use the worker strategy are offloaded and executed in a web worker with Partytown. This can improve the performance of your site by dedicating the main thread to the rest of your application code.

This strategy is still experimental and can only be used if the nextScriptWorkers flag is enabled in next.config.js:

Then, run next (normally npm run dev or yarn dev) and Next.js will guide you through the installation of the required packages to finish the setup:

You'll see instructions like these: Please install Partytown by running npm install @builder.io/partytown

Once setup is complete, defining strategy="worker" will automatically instantiate Partytown in your application and offload the script to a web worker.

There are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown's tradeoffs documentation for more information.

Inline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces:

Or by using the dangerouslySetInnerHTML property:

Warning: An id property must be assigned for inline scripts in order for Next.js to track and optimize the script.

Event handlers can be used with the Script component to execute additional code after a certain event occurs:

These handlers will only work when next/script is imported and used inside of a Client Component where "use client" is defined as the first line of code:

Refer to the next/script API reference to learn more about each event handler and view examples.

There are many DOM attributes that can be assigned to a <script> element that are not used by the Script component, like nonce or custom data attributes. Including any additional attributes will automatically forward it to the final, optimized <script> element that is included in the HTML.

**Examples:**

Example 1 (python):
```python
import Script from 'next/script'
 
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <>
      <section>{children}</section>
      <Script src="https://example.com/script.js" />
    </>
  )
}
```

Example 2 (python):
```python
import Script from 'next/script'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
      <Script src="https://example.com/script.js" />
    </html>
  )
}
```

Example 3 (unknown):
```unknown
module.exports = {
  experimental: {
    nextScriptWorkers: true,
  },
}
```

Example 4 (unknown):
```unknown
npm run dev
```

---

## How to set up Vitest with Next.js

**URL:** https://nextjs.org/docs/pages/guides/testing/vitest

**Contents:**
- How to set up Vitest with Next.js
- Quickstart
- Manual Setup
- Creating your first Vitest Unit Test
- Running your tests
- Additional Resources

Vitest and React Testing Library are frequently used together for Unit Testing. This guide will show you how to setup Vitest with Next.js and write your first tests.

Good to know: Since async Server Components are new to the React ecosystem, Vitest currently does not support them. While you can still run unit tests for synchronous Server and Client Components, we recommend using E2E tests for async components.

You can use create-next-app with the Next.js with-vitest example to quickly get started:

To manually set up Vitest, install vitest and the following packages as dev dependencies:

Create a vitest.config.mts|js file in the root of your project, and add the following options:

For more information on configuring Vitest, please refer to the Vitest Configuration docs.

Then, add a test script to your package.json:

When you run npm run test, Vitest will watch for changes in your project by default.

Check that everything is working by creating a test to check if the <Page /> component successfully renders a heading:

Then, run the following command to run your tests:

You may find these resources helpful:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --example with-vitest with-vitest-app
```

Example 2 (unknown):
```unknown
# Using TypeScript
npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom vite-tsconfig-paths
# Using JavaScript
npm install -D vitest @vitejs/plugin-react jsdom @testing-library/react @testing-library/dom
```

Example 3 (python):
```python
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import tsconfigPaths from 'vite-tsconfig-paths'
 
export default defineConfig({
  plugins: [tsconfigPaths(), react()],
  test: {
    environment: 'jsdom',
  },
})
```

Example 4 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "test": "vitest"
  }
}
```

---

## How to build multi-tenant apps in Next.js

**URL:** https://nextjs.org/docs/app/guides/multi-tenant

**Contents:**
- How to build multi-tenant apps in Next.js

If you are looking to build a single Next.js application that serves multiple tenants, we have built an example showing our recommended architecture.

---

## How to optimize your Next.js application for production

**URL:** https://nextjs.org/docs/app/guides/production-checklist

**Contents:**
- How to optimize your Next.js application for production
- Automatic optimizations
- During development
  - Routing and rendering
  - Data fetching and caching
  - UI and accessibility
  - Security
  - Metadata and SEO
  - Type safety
- Before going to production

Before taking your Next.js application to production, there are some optimizations and patterns you should consider implementing for the best user experience, performance, and security.

This page provides best practices that you can use as a reference when building your application and before going to production, as well as the automatic Next.js optimizations you should be aware of.

These Next.js optimizations are enabled by default and require no configuration:

These defaults aim to improve your application's performance, and reduce the cost and amount of data transferred on each network request.

While building your application, we recommend using the following features to ensure the best performance and user experience:

Good to know: Partial Prerendering (experimental) will allow parts of a route to be dynamic without opting the whole route into dynamic rendering.

Before going to production, you can run next build to build your application locally and catch any build errors, then run next start to measure the performance of your application in a production-like environment.

Use the @next/bundle-analyzer plugin to analyze the size of your JavaScript bundles and identify large modules and dependencies that might be impacting your application's performance.

Additionally, the following tools can help you understand the impact of adding new dependencies to your application:

---

## How to set up a custom server in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/custom-server

**Contents:**
- How to set up a custom server in Next.js

Next.js includes its own server with next start by default. If you have an existing backend, you can still use it with Next.js (this is not a custom server). A custom Next.js server allows you to programmatically start a server for custom patterns. The majority of the time, you will not need this approach. However, it's available if you need to eject.

Take a look at the following example of a custom server:

server.js does not run through the Next.js Compiler or bundling process. Make sure the syntax and source code this file requires are compatible with the current Node.js version you are using. View an example.

To run the custom server, you'll need to update the scripts in package.json like so:

Alternatively, you can set up nodemon (example). The custom server uses the following import to connect the server with the Next.js application:

The above next import is a function that receives an object with the following options:

The returned app can then be used to let Next.js handle requests as required.

**Examples:**

Example 1 (python):
```python
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'
 
const port = parseInt(process.env.PORT || '3000', 10)
const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()
 
app.prepare().then(() => {
  createServer((req, res) => {
    const parsedUrl = parse(req.url!, true)
    handle(req, res, parsedUrl)
  }).listen(port)
 
  console.log(
    `> Server listening at http://localhost:${port} as ${
      dev ? 'development' : process.env.NODE_ENV
    }`
  )
})
```

Example 2 (unknown):
```unknown
{
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "NODE_ENV=production node server.js"
  }
}
```

Example 3 (python):
```python
import next from 'next'
 
const app = next({})
```

---

## How to implement JSON-LD in your Next.js application

**URL:** https://nextjs.org/docs/15/app/guides/json-ld

**Contents:**
- How to implement JSON-LD in your Next.js application

JSON-LD is a format for structured data that can be used by search engines and AI to help them understand the structure of the page beyond pure content. For example, you can use it to describe a person, an event, an organization, a movie, a book, a recipe, and many other types of entities.

Our current recommendation for JSON-LD is to render structured data as a <script> tag in your layout.js or page.js components.

The following snippet uses JSON.stringify, which does not sanitize malicious strings used in XSS injection. To prevent this type of vulnerability, you can scrub HTML tags from the JSON-LD payload, for example, by replacing the character, <, with its unicode equivalent, \u003c.

Review your organization's recommended approach to sanitize potentially dangerous strings, or use community maintained alternatives for JSON.stringify such as, serialize-javascript.

You can validate and test your structured data with the Rich Results Test for Google or the generic Schema Markup Validator.

You can type your JSON-LD with TypeScript using community packages like schema-dts:

**Examples:**

Example 1 (javascript):
```javascript
export default async function Page({ params }) {
  const { id } = await params
  const product = await getProduct(id)
 
  const jsonLd = {
    '@context': 'https://schema.org',
    '@type': 'Product',
    name: product.name,
    image: product.image,
    description: product.description,
  }
 
  return (
    <section>
      {/* Add JSON-LD to your page */}
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify(jsonLd).replace(/</g, '\\u003c'),
        }}
      />
      {/* ... */}
    </section>
  )
}
```

Example 2 (python):
```python
import { Product, WithContext } from 'schema-dts'
 
const jsonLd: WithContext<Product> = {
  '@context': 'https://schema.org',
  '@type': 'Product',
  name: 'Next.js Sticker',
  image: 'https://nextjs.org/imgs/sticker.png',
  description: 'Dynamic at the speed of static.',
}
```

---

## assetPrefix

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/assetPrefix

**Contents:**
- assetPrefix
- Set up a CDN

Attention: Deploying to Vercel automatically configures a global CDN for your Next.js project. You do not need to manually setup an Asset Prefix.

Good to know: Next.js 9.5+ added support for a customizable Base Path, which is better suited for hosting your application on a sub-path like /docs. We do not suggest you use a custom Asset Prefix for this use case.

To set up a CDN, you can set up an asset prefix and configure your CDN's origin to resolve to the domain that Next.js is hosted on.

Open next.config.mjs and add the assetPrefix config based on the phase:

Next.js will automatically use your asset prefix for the JavaScript and CSS files it loads from the /_next/ path (.next/static/ folder). For example, with the above configuration, the following request for a JS chunk:

Would instead become:

The exact configuration for uploading your files to a given CDN will depend on your CDN of choice. The only folder you need to host on your CDN is the contents of .next/static/, which should be uploaded as _next/static/ as the above URL request indicates. Do not upload the rest of your .next/ folder, as you should not expose your server code and other configuration to the public.

While assetPrefix covers requests to _next/static, it does not influence the following paths:

**Examples:**

Example 1 (python):
```python
// @ts-check
import { PHASE_DEVELOPMENT_SERVER } from 'next/constants'
 
export default (phase) => {
  const isDev = phase === PHASE_DEVELOPMENT_SERVER
  /**
   * @type {import('next').NextConfig}
   */
  const nextConfig = {
    assetPrefix: isDev ? undefined : 'https://cdn.mydomain.com',
  }
  return nextConfig
}
```

Example 2 (unknown):
```unknown
/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
```

Example 3 (unknown):
```unknown
https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
```

---

## How to set up a custom server in Next.js

**URL:** https://nextjs.org/docs/pages/guides/custom-server

**Contents:**
- How to set up a custom server in Next.js
- Disabling file-system routing

Next.js includes its own server with next start by default. If you have an existing backend, you can still use it with Next.js (this is not a custom server). A custom Next.js server allows you to programmatically start a server for custom patterns. The majority of the time, you will not need this approach. However, it's available if you need to eject.

Take a look at the following example of a custom server:

server.js does not run through the Next.js Compiler or bundling process. Make sure the syntax and source code this file requires are compatible with the current Node.js version you are using. View an example.

To run the custom server, you'll need to update the scripts in package.json like so:

Alternatively, you can set up nodemon (example). The custom server uses the following import to connect the server with the Next.js application:

The above next import is a function that receives an object with the following options:

The returned app can then be used to let Next.js handle requests as required.

By default, Next will serve each file in the pages folder under a pathname matching the filename. If your project uses a custom server, this behavior may result in the same content being served from multiple paths, which can present problems with SEO and UX.

To disable this behavior and prevent routing based on files in pages, open next.config.js and disable the useFileSystemPublicRoutes config:

Note that useFileSystemPublicRoutes disables filename routes from SSR; client-side routing may still access those paths. When using this option, you should guard against navigation to routes you do not want programmatically.

You may also wish to configure the client-side router to disallow client-side redirects to filename routes; for that refer to router.beforePopState.

**Examples:**

Example 1 (python):
```python
import { createServer } from 'http'
import { parse } from 'url'
import next from 'next'
 
const port = parseInt(process.env.PORT || '3000', 10)
const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()
 
app.prepare().then(() => {
  createServer((req, res) => {
    const parsedUrl = parse(req.url!, true)
    handle(req, res, parsedUrl)
  }).listen(port)
 
  console.log(
    `> Server listening at http://localhost:${port} as ${
      dev ? 'development' : process.env.NODE_ENV
    }`
  )
})
```

Example 2 (unknown):
```unknown
{
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "NODE_ENV=production node server.js"
  }
}
```

Example 3 (python):
```python
import next from 'next'
 
const app = next({})
```

Example 4 (unknown):
```unknown
module.exports = {
  useFileSystemPublicRoutes: false,
}
```

---

## allowedDevOrigins

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/allowedDevOrigins

**Contents:**
- allowedDevOrigins

Next.js does not automatically block cross-origin requests during development, but will block by default in a future major version of Next.js to prevent unauthorized requesting of internal assets/endpoints that are available in development mode.

To configure a Next.js application to allow requests from origins other than the hostname the server was initialized with (localhost by default) you can use the allowedDevOrigins config option.

allowedDevOrigins allows you to set additional origins that can be used in development mode. For example, to use local-origin.dev instead of only localhost, open next.config.js and add the allowedDevOrigins config:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  allowedDevOrigins: ['local-origin.dev', '*.local-origin.dev'],
}
```

---

## How to use Sass

**URL:** https://nextjs.org/docs/15/app/guides/sass

**Contents:**
- How to use Sass
  - Customizing Sass Options
    - Implementation
  - Sass Variables

Next.js has built-in support for integrating with Sass after the package is installed using both the .scss and .sass extensions. You can use component-level Sass via CSS Modules and the .module.scssor .module.sass extension.

Sass supports two different syntaxes, each with their own extension. The .scss extension requires you use the SCSS syntax, while the .sass extension requires you use the Indented Syntax ("Sass").

If you're not sure which to choose, start with the .scss extension which is a superset of CSS, and doesn't require you learn the Indented Syntax ("Sass").

If you want to configure your Sass options, use sassOptions in next.config.

You can use the implementation property to specify the Sass implementation to use. By default, Next.js uses the sass package.

Next.js supports Sass variables exported from CSS Module files.

For example, using the exported primaryColor Sass variable:

**Examples:**

Example 1 (unknown):
```unknown
npm install --save-dev sass
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  sassOptions: {
    additionalData: `$var: red;`,
  },
}
 
export default nextConfig
```

Example 3 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  sassOptions: {
    implementation: 'sass-embedded',
  },
}
 
export default nextConfig
```

Example 4 (unknown):
```unknown
$primary-color: #64ff00;
 
:export {
  primaryColor: $primary-color;
}
```

---

## Directives

**URL:** https://nextjs.org/docs/15/app/api-reference/directives

**Contents:**
- Directives
  - use cache
  - use client
  - use server

The following directives are available:

---

## not-found.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/not-found

**Contents:**
- not-found.js
- not-found.js
- global-not-found.js (experimental)
- Reference
  - Props
- Examples
  - Data Fetching
  - Metadata
- Version History

Next.js provides two conventions to handle not found cases:

The not-found file is used to render UI when the notFound function is thrown within a route segment. Along with serving a custom UI, Next.js will return a 200 HTTP status code for streamed responses, and 404 for non-streamed responses.

The global-not-found.js file lets you define a 404 page for your entire application. Unlike not-found.js, which works at the route level, this is used when a requested URL doesn't match any route at all. Next.js skips rendering and directly returns this global page.

The global-not-found.js file bypasses your app's normal rendering, which means you'll need to import any global styles, fonts, or other dependencies that your 404 page requires.

Good to know: A smaller version of your global styles, and a simpler font family could improve performance of this page.

global-not-found.js is useful when you can't build a 404 page using a combination of layout.js and not-found.js. This can happen in two cases:

To enable it, add the globalNotFound flag in next.config.ts:

Then, create a file in the root of the app directory: app/global-not-found.js:

Unlike not-found.js, this file must return a full HTML document, including <html> and <body> tags.

not-found.js or global-not-found.js components do not accept any props.

Good to know: In addition to catching expected notFound() errors, the root app/not-found.js and app/global-not-found.js files handle any unmatched URLs for your whole application. This means users that visit a URL that is not handled by your app will be shown the exported UI.

By default, not-found is a Server Component. You can mark it as async to fetch and display data:

If you need to use Client Component hooks like usePathname to display content based on the path, you must fetch data on the client-side instead.

For global-not-found.js, you can export a metadata object or a generateMetadata function to customize the <title>, <meta>, and other head tags for your 404 page:

Good to know: Next.js automatically injects <meta name="robots" content="noindex" /> for pages that return a 404 status code, including global-not-found.js pages.

**Examples:**

Example 1 (python):
```python
import Link from 'next/link'
 
export default function NotFound() {
  return (
    <div>
      <h2>Not Found</h2>
      <p>Could not find requested resource</p>
      <Link href="/">Return Home</Link>
    </div>
  )
}
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    globalNotFound: true,
  },
}
 
export default nextConfig
```

Example 3 (python):
```python
// Import global styles and fonts
import './globals.css'
import { Inter } from 'next/font/google'
import type { Metadata } from 'next'
 
const inter = Inter({ subsets: ['latin'] })
 
export const metadata: Metadata = {
  title: '404 - Page Not Found',
  description: 'The page you are looking for does not exist.',
}
 
export default function GlobalNotFound() {
  return (
    <html lang="en" className={inter.className}>
      <body>
        <h1>404 - Page Not Found</h1>
        <p>This page does not exist.</p>
      </body>
    </html>
  )
}
```

Example 4 (python):
```python
import Link from 'next/link'
import { headers } from 'next/headers'
 
export default async function NotFound() {
  const headersList = await headers()
  const domain = headersList.get('host')
  const data = await getSiteData(domain)
  return (
    <div>
      <h2>Not Found: {data.name}</h2>
      <p>Could not find requested resource</p>
      <p>
        View <Link href="/blog">all posts</Link>
      </p>
    </div>
  )
}
```

---

## Enabling Next.js MCP Server for Coding Agents

**URL:** https://nextjs.org/docs/app/guides/mcp

**Contents:**
- Enabling Next.js MCP Server for Coding Agents
- Getting started
- Capabilities
  - Application Runtime Access
  - Development Tools
- Development workflow
  - Available tools
- Using with agents
  - Benefits for agent-assisted development
- Examples

The Model Context Protocol (MCP) is an open standard that allows AI agents and coding assistants to interact with your applications through a standardized interface.

Next.js 16+ includes MCP support that enables coding agents to access your application's internals in real-time. To use this functionality, install the next-devtools-mcp package.

Requirements: Next.js 16 or above

Add next-devtools-mcp to the .mcp.json file at the root of your project:

That's it! When you start your development server, next-devtools-mcp will automatically discover and connect to your running Next.js instance.

For more configuration options, see the next-devtools-mcp repository.

next-devtools-mcp provides coding agents with a growing set of capabilities:

Note: The Next.js team is actively expanding these capabilities. New tools and features are added regularly to improve the agent development experience.

Your Coding Agent will automatically connect to the running Next.js instance via next-devtools-mcp

Open your application in the browser to view pages

Query your agent for insights and diagnostics (see examples below)

Through next-devtools-mcp, agents can use the following tools:

MCP-compatible Coding Agents can automatically discover and connect to your Next.js development server, providing them with rich context about your project.

Ask your agent about errors in real-time:

Get help with Next.js concepts and migrations:

The agent will analyze your current version, guide you through automated migrations with codemods, and provide step-by-step instructions for handling breaking changes.

Ask conceptual questions:

The agent will query the Next.js knowledge base and provide documentation-backed explanations with examples from your codebase.

Next.js 16+ includes a built-in MCP endpoint at /_next/mcp that runs within your development server. The next-devtools-mcp package automatically discovers and communicates with these endpoints, allowing it to:

This architecture decouples the agent interface from the internal implementation, enabling next-devtools-mcp to work seamlessly across different Next.js projects.

**Examples:**

Example 1 (unknown):
```unknown
{
  "mcpServers": {
    "next-devtools": {
      "command": "npx",
      "args": ["-y", "next-devtools-mcp@latest"]
    }
  }
}
```

Example 2 (unknown):
```unknown
npm run dev
```

Example 3 (unknown):
```unknown
User: "What errors are currently in my application?"
```

Example 4 (javascript):
```javascript
> fix errors on the page
 
âº I'll help you fix the errors on the page. Let me first check what errors exist by looking at the
  current state of the project.
 
âº next-devtools - nextjs_runtime (MCP)(action: "discover_servers")
âº next-devtools - nextjs_runtime (MCP)(action: "call_tool", toolName: "get_errors")
 
âº I found a hydration error on the /about page. The error shows that the server is rendering
  "server" but the client is rendering "client", causing a mismatch. Let me create a todo list and fix
   this issue.
 
âº Perfect! Now let me check for errors on the page.           01:14 PM  claude-sonnet-4-5-20250929
 
âº next-devtools - nextjs_runtime (MCP)(action: "call_tool", toolName: "get_errors")
  âŽ¿ {
      "success": true,
      "port": 3000,
      "toolName": "get_errors",
      "result": {
        "content": [
          {
            "type": "text",
            "text": "# Found errors in 1 browser session(s)\n\n## Session: /about\n\n**1 error(s)
     found**\n\n### Runtime Errors\n\n#### Error 1 (Type: recoverable)\n\n**Error**: Hydration failed
```

---

## Edge Runtime

**URL:** https://nextjs.org/docs/app/api-reference/edge

**Contents:**
- Edge Runtime
- Caveats
- Reference
  - Network APIs
  - Encoding APIs
  - Stream APIs
  - Crypto APIs
  - Web Standard APIs
  - Next.js Specific Polyfills
  - Environment Variables

Next.js has two server runtimes you can use in your application:

The Edge Runtime supports the following APIs:

You can use process.env to access Environment Variables for both next dev and next build.

The Edge Runtime has some restrictions including:

The following JavaScript language features are disabled, and will not work:

In rare cases, your code could contain (or import) some dynamic code evaluation statements which can not be reached at runtime and which can not be removed by treeshaking. You can relax the check to allow specific files with your Proxy configuration:

unstable_allowDynamic is a glob, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to your application root folder.

Be warned that if these statements are executed on the Edge, they will throw and cause a runtime error.

**Examples:**

Example 1 (javascript):
```javascript
export const config = {
  unstable_allowDynamic: [
    // allows a single file
    '/lib/utilities.js',
    // use a glob to allow anything in the function-bind 3rd party module
    '**/node_modules/function-bind/**',
  ],
}
```

---

## staleTimes

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/staleTimes

**Contents:**
- staleTimes
  - Version History

staleTimes is an experimental feature that enables caching of page segments in the client-side router cache.

You can enable this experimental feature and provide custom revalidation times by setting the experimental staleTimes flag:

The static and dynamic properties correspond with the time period (in seconds) based on different types of link prefetching.

You can learn more about the Client Router Cache here.

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    staleTimes: {
      dynamic: 30,
      static: 180,
    },
  },
}
 
module.exports = nextConfig
```

---

## useLightningcss

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/useLightningcss

**Contents:**
- useLightningcss
- Version History

Experimental support for using Lightning CSS with webpack. Lightning CSS is a fast CSS transformer and minifier, written in Rust.

If this option is not set, Next.js on webpack uses PostCSS with postcss-preset-env by default.

Turbopack uses Lightning CSS by default since Next 14.2. This configuration option has no effect on Turbopack. Turbopack always uses Lightning CSS.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    useLightningcss: false, // default, ignored on Turbopack
  },
}
 
export default nextConfig
```

---

## How to build micro-frontends using multi-zones and Next.js

**URL:** https://nextjs.org/docs/15/app/guides/multi-zones

**Contents:**
- How to build micro-frontends using multi-zones and Next.js
- How to define a zone
- How to route requests to the right zone
  - Routing requests using middleware
- Linking between zones
- Sharing code
- Server Actions

Multi-Zones are an approach to micro-frontends that separate a large application on a domain into smaller Next.js applications that each serve a set of paths. This is useful when there are collections of pages unrelated to the other pages in the application. By moving those pages to a separate zone (i.e., a separate application), you can reduce the size of each application which improves build times and removes code that is only necessary for one of the zones. Since applications are decoupled, Multi-Zones also allows other applications on the domain to use their own choice of framework.

For example, let's say you have the following set of pages that you would like to split up:

With Multi-Zones support, you can create three applications that all are served on the same domain and look the same to the user, but you can develop and deploy each of the applications independently.

Navigating between pages in the same zone will perform soft navigations, a navigation that does not require reloading the page. For example, in this diagram, navigating from / to /products will be a soft navigation.

Navigating from a page in one zone to a page in another zone, such as from / to /dashboard, will perform a hard navigation, unloading the resources of the current page and loading the resources of the new page. Pages that are frequently visited together should live in the same zone to avoid hard navigations.

A zone is a normal Next.js application where you also configure an assetPrefix to avoid conflicts with pages and static files in other zones.

Next.js assets, such as JavaScript and CSS, will be prefixed with assetPrefix to make sure that they don't conflict with assets from other zones. These assets will be served under /assetPrefix/_next/... for each of the zones.

The default application handling all paths not routed to another more specific zone does not need an assetPrefix.

In versions older than Next.js 15, you may also need an additional rewrite to handle the static assets. This is no longer necessary in Next.js 15.

With the Multi Zones set-up, you need to route the paths to the correct zone since they are served by different applications. You can use any HTTP proxy to do this, but one of the Next.js applications can also be used to route requests for the entire domain.

To route to the correct zone using a Next.js application, you can use rewrites. For each path served by a different zone, you would add a rewrite rule to send that path to the domain of the other zone, and you also need to rewrite the requests for the static assets. For example:

destination should be a URL that is served by the zone, including scheme and domain. This should point to the zone's production domain, but it can also be used to route requests to localhost in local development.

Good to know: URL paths should be unique to a zone. For example, two zones trying to serve /blog would create a routing conflict.

Routing requests through rewrites is recommended to minimize latency overhead for the requests, but middleware can also be used when there is a need for a dynamic decision when routing. For example, if you are using a feature flag to decide where a path should be routed such as during a migration, you can use middleware.

Links to paths in a different zone should use an a tag instead of the Next.js <Link> component. This is because Next.js will try to prefetch and soft navigate to any relative path in <Link> component, which will not work across zones.

The Next.js applications that make up the different zones can live in any repository. However, it is often convenient to put these zones in a monorepo to more easily share code. For zones that live in different repositories, code can also be shared using public or private NPM packages.

Since the pages in different zones may be released at different times, feature flags can be useful for enabling or disabling features in unison across the different zones.

When using Server Actions with Multi-Zones, you must explicitly allow the user-facing origin since your user facing domain may serve multiple applications. In your next.config.js file, add the following lines:

See serverActions.allowedOrigins for more information.

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  assetPrefix: '/blog-static',
}
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  assetPrefix: '/blog-static',
  async rewrites() {
    return {
      beforeFiles: [
        {
          source: '/blog-static/_next/:path+',
          destination: '/_next/:path+',
        },
      ],
    }
  },
}
```

Example 3 (unknown):
```unknown
async rewrites() {
    return [
        {
            source: '/blog',
            destination: `${process.env.BLOG_DOMAIN}/blog`,
        },
        {
            source: '/blog/:path+',
            destination: `${process.env.BLOG_DOMAIN}/blog/:path+`,
        },
        {
            source: '/blog-static/:path+',
            destination: `${process.env.BLOG_DOMAIN}/blog-static/:path+`,
        }
    ];
}
```

Example 4 (javascript):
```javascript
export async function middleware(request) {
  const { pathname, search } = req.nextUrl;
  if (pathname === '/your-path' && myFeatureFlag.isEnabled()) {
    return NextResponse.rewrite(`${rewriteDomain}${pathname}${search});
  }
}
```

---

## favicon, icon, and apple-icon

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons

**Contents:**
- favicon, icon, and apple-icon
- Image files (.ico, .jpg, .png)
  - favicon
  - icon
  - apple-icon
- Generate icons using code (.js, .ts, .tsx)
  - Props
    - params (optional)
  - Returns
  - Config exports

The favicon, icon, or apple-icon file conventions allow you to set icons for your application.

They are useful for adding app icons that appear in places like web browser tabs, phone home screens, and search engine results.

There are two ways to set app icons:

Use an image file to set an app icon by placing a favicon, icon, or apple-icon image file within your /app directory. The favicon image can only be located in the top level of app/.

Next.js will evaluate the file and automatically add the appropriate tags to your app's <head> element.

Add a favicon.ico image file to the root /app route segment.

Add an icon.(ico|jpg|jpeg|png|svg) image file.

Add an apple-icon.(jpg|jpeg|png) image file.

In addition to using literal image files, you can programmatically generate icons using code.

Generate an app icon by creating an icon or apple-icon route that default exports a function.

The easiest way to generate an icon is to use the ImageResponse API from next/og.

The default export function receives the following props:

A promise that resolves to an object containing the dynamic route parameters object from the root segment down to the segment icon or apple-icon is colocated in.

Good to know: If you use generateImageMetadata, the function will also receive an id prop that is a promise resolving to the id value from one of the items returned by generateImageMetadata.

The default export function should return a Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response.

Good to know: ImageResponse satisfies this return type.

You can optionally configure the icon's metadata by exporting size and contentType variables from the icon or apple-icon route.

icon and apple-icon are specialized Route Handlers that can use the same route segment configuration options as Pages and Layouts.

**Examples:**

Example 1 (unknown):
```unknown
<link rel="icon" href="/favicon.ico" sizes="any" />
```

Example 2 (unknown):
```unknown
<link
  rel="icon"
  href="/icon?<generated>"
  type="image/<generated>"
  sizes="<generated>"
/>
```

Example 3 (unknown):
```unknown
<link
  rel="apple-touch-icon"
  href="/apple-icon?<generated>"
  type="image/<generated>"
  sizes="<generated>"
/>
```

Example 4 (python):
```python
import { ImageResponse } from 'next/og'
 
// Image metadata
export const size = {
  width: 32,
  height: 32,
}
export const contentType = 'image/png'
 
// Image generation
export default function Icon() {
  return new ImageResponse(
    (
      // ImageResponse JSX element
      <div
        style={{
          fontSize: 24,
          background: 'black',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: 'white',
        }}
      >
        A
      </div>
    ),
    // ImageResponse options
    {
      // For convenience, we can re-use the exported icons size metadata
      // config to also set the ImageResponse's width and height.
      ...size,
    }
  )
}
```

---

## Image (Legacy)

**URL:** https://nextjs.org/docs/pages/api-reference/components/image-legacy

**Contents:**
- Image (Legacy)
- Comparison
- Required Props
  - src
  - width
  - height
- Optional Props
  - layout
  - loader
  - sizes

Starting with Next.js 13, the next/image component was rewritten to improve both the performance and developer experience. In order to provide a backwards compatible upgrade solution, the old next/image was renamed to next/legacy/image.

Warning: next/legacy/image is deprecated and will be removed in a future version of Next.js. Please use next/image instead.

Compared to next/legacy/image, the new next/image component has the following changes:

The <Image /> component requires the following properties.

Must be one of the following:

When using the default loader, also consider the following for source images:

The width property can represent either the rendered width or original width in pixels, depending on the layout and sizes properties.

When using layout="intrinsic" or layout="fixed" the width property represents the rendered width in pixels, so it will affect how large the image appears.

When using layout="responsive", layout="fill", the width property represents the original width in pixels, so it will only affect the aspect ratio.

The width property is required, except for statically imported images, or those with layout="fill".

The height property can represent either the rendered height or original height in pixels, depending on the layout and sizes properties.

When using layout="intrinsic" or layout="fixed" the height property represents the rendered height in pixels, so it will affect how large the image appears.

When using layout="responsive", layout="fill", the height property represents the original height in pixels, so it will only affect the aspect ratio.

The height property is required, except for statically imported images, or those with layout="fill".

The <Image /> component accepts a number of additional properties beyond those which are required. This section describes the most commonly-used properties of the Image component. Find details about more rarely-used properties in the Advanced Props section.

The layout behavior of the image as the viewport changes size.

A custom function used to resolve URLs. Setting the loader as a prop on the Image component overrides the default loader defined in the images section of next.config.js.

A loader is a function returning a URL string for the image, given the following parameters:

Here is an example of using a custom loader:

A string that provides information about how wide the image will be at different breakpoints. The value of sizes will greatly affect performance for images using layout="responsive" or layout="fill". It will be ignored for images using layout="intrinsic" or layout="fixed".

The sizes property serves two important purposes related to image performance:

First, the value of sizes is used by the browser to determine which size of the image to download, from next/legacy/image's automatically-generated source set. When the browser chooses, it does not yet know the size of the image on the page, so it selects an image that is the same size or larger than the viewport. The sizes property allows you to tell the browser that the image will actually be smaller than full screen. If you don't specify a sizes value, a default value of 100vw (full screen width) is used.

Second, the sizes value is parsed and used to trim the values in the automatically-created source set. If the sizes property includes sizes such as 50vw, which represent a percentage of the viewport width, then the source set is trimmed to not include any values which are too small to ever be necessary.

For example, if you know your styling will cause an image to be full-width on mobile devices, in a 2-column layout on tablets, and a 3-column layout on desktop displays, you should include a sizes property such as the following:

This example sizes could have a dramatic effect on performance metrics. Without the 33vw sizes, the image selected from the server would be 3 times as wide as it needs to be. Because file size is proportional to the square of the width, without sizes the user would download an image that's 9 times larger than necessary.

Learn more about srcset and sizes:

The quality of the optimized image, an integer between 1 and 100 where 100 is the best quality. Defaults to 75.

When true, the image will be considered high priority and preload. Lazy loading is automatically disabled for images using priority.

You should use the priority property on any image detected as the Largest Contentful Paint (LCP) element. It may be appropriate to have multiple priority images, as different images may be the LCP element for different viewport sizes.

Should only be used when the image is visible above the fold. Defaults to false.

A placeholder to use while the image is loading. Possible values are blur or empty. Defaults to empty.

When blur, the blurDataURL property will be used as the placeholder. If src is an object from a static import and the imported image is .jpg, .png, .webp, or .avif, then blurDataURL will be automatically populated.

For dynamic images, you must provide the blurDataURL property. Solutions such as Plaiceholder can help with base64 generation.

When empty, there will be no placeholder while the image is loading, only empty space.

In some cases, you may need more advanced usage. The <Image /> component optionally accepts the following advanced properties.

Allows passing CSS styles to the underlying image element.

Note that all layout modes apply their own styles to the image element, and these automatic styles take precedence over the style prop.

Also keep in mind that the required width and height props can interact with your styling. If you use styling to modify an image's width, you must set the height="auto" style as well, or your image will be distorted.

Defines how the image will fit into its parent container when using layout="fill".

This value is passed to the object-fit CSS property for the src image.

Defines how the image is positioned within its parent element when using layout="fill".

This value is passed to the object-position CSS property applied to the image.

A callback function that is invoked once the image is completely loaded and the placeholder has been removed.

The onLoadingComplete function accepts one parameter, an object with the following properties:

The loading behavior of the image. Defaults to lazy.

When lazy, defer loading the image until it reaches a calculated distance from the viewport.

When eager, load the image immediately.

A Data URL to be used as a placeholder image before the src image successfully loads. Only takes effect when combined with placeholder="blur".

Must be a base64-encoded image. It will be enlarged and blurred, so a very small image (10px or less) is recommended. Including larger images as placeholders may harm your application performance.

You can also generate a solid color Data URL to match the image.

A string (with similar syntax to the margin property) that acts as the bounding box used to detect the intersection of the viewport with the image and trigger lazy loading. Defaults to "200px".

If the image is nested in a scrollable parent element other than the root document, you will also need to assign the lazyRoot prop.

A React Ref pointing to the scrollable parent element. Defaults to null (the document viewport).

The Ref must point to a DOM element or a React component that forwards the Ref to the underlying DOM element.

Example pointing to a DOM element

Example pointing to a React component

When true, the source image will be served as-is from the src instead of changing quality, size, or format. Defaults to false.

This is useful for images that do not benefit from optimization such as small images (less than 1KB), vector images (SVG), or animated images (GIF).

Since Next.js 12.3.0, this prop can be assigned to all images by updating next.config.js with the following configuration:

Other properties on the <Image /> component will be passed to the underlying img element with the exception of the following:

To protect your application from malicious users, configuration is required in order to use external images. This ensures that only external images from your account can be served from the Next.js Image Optimization API. These external images can be configured with the remotePatterns property in your next.config.js file, as shown below:

Good to know: The example above will ensure the src property of next/legacy/image must start with https://example.com/account123/ and must not have a query string. Any other protocol, hostname, port, or unmatched path will respond with 400 Bad Request.

Below is an example of the remotePatterns property in the next.config.js file using a wildcard pattern in the hostname:

Good to know: The example above will ensure the src property of next/legacy/image must start with https://img1.example.com or https://me.avatar.example.com or any number of subdomains. It cannot have a port or query string. Any other protocol or unmatched hostname will respond with 400 Bad Request.

Wildcard patterns can be used for both pathname and hostname and have the following syntax:

The ** syntax does not work in the middle of the pattern.

Good to know: When omitting protocol, port, pathname, or search then the wildcard ** is implied. This is not recommended because it may allow malicious actors to optimize urls you did not intend.

Below is an example of the remotePatterns property in the next.config.js file using search:

Good to know: The example above will ensure the src property of next/legacy/image must start with https://assets.example.com and must have the exact query string ?v=1727111025337. Any other protocol or query string will respond with 400 Bad Request.

Warning: Deprecated since Next.js 14 in favor of strict remotePatterns in order to protect your application from malicious users. Only use domains if you own all the content served from the domain.

Similar to remotePatterns, the domains configuration can be used to provide a list of allowed hostnames for external images.

However, the domains configuration does not support wildcard pattern matching and it cannot restrict protocol, port, or pathname.

Below is an example of the domains property in the next.config.js file:

If you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure the loader and path prefix in your next.config.js file. This allows you to use relative URLs for the Image src and automatically generate the correct absolute URL for your provider.

If you want to change or prefix the default path for the built-in Next.js image optimization, you can do so with the path property. The default value for path is /_next/image.

The following Image Optimization cloud providers are included:

If you need a different provider, you can use the loader prop with next/legacy/image.

Images can not be optimized at build time using output: 'export', only on-demand. To use next/legacy/image with output: 'export', you will need to use a different loader than the default. Read more in the discussion.

The following configuration is for advanced use cases and is usually not necessary. If you choose to configure the properties below, you will override any changes to the Next.js defaults in future updates.

If you know the expected device widths of your users, you can specify a list of device width breakpoints using the deviceSizes property in next.config.js. These widths are used when the next/legacy/image component uses layout="responsive" or layout="fill" to ensure the correct image is served for user's device.

If no configuration is provided, the default below is used.

You can specify a list of image widths using the images.imageSizes property in your next.config.js file. These widths are concatenated with the array of device sizes to form the full array of sizes used to generate image srcsets.

The reason there are two separate lists is that imageSizes is only used for images which provide a sizes prop, which indicates that the image is less than the full width of the screen. Therefore, the sizes in imageSizes should all be smaller than the smallest size in deviceSizes.

If no configuration is provided, the default below is used.

The default Image Optimization API will automatically detect the browser's supported image formats via the request's Accept header in order to determine the best output format.

If the Accept header matches more than one of the configured formats, the first match in the array is used. Therefore, the array order matters. If there is no match (or the source image is animated), the Image Optimization API will fallback to the original image's format.

If no configuration is provided, the default below is used.

You can enable AVIF support, which will fallback to the original format of the src image if the browser does not support AVIF:

The following describes the caching algorithm for the default loader. For all other loaders, please refer to your cloud provider's documentation.

Images are optimized dynamically upon request and stored in the <distDir>/cache/images directory. The optimized image file will be served for subsequent requests until the expiration is reached. When a request is made that matches a cached but expired file, the expired image is served stale immediately. Then the image is optimized again in the background (also called revalidation) and saved to the cache with the new expiration date.

The cache status of an image can be determined by reading the value of the x-nextjs-cache (x-vercel-cache when deployed on Vercel) response header. The possible values are the following:

The expiration (or rather Max Age) is defined by either the minimumCacheTTL configuration or the upstream image Cache-Control header, whichever is larger. Specifically, the max-age value of the Cache-Control header is used. If both s-maxage and max-age are found, then s-maxage is preferred. The max-age is also passed-through to any downstream clients including CDNs and browsers.

You can configure the Time to Live (TTL) in seconds for cached optimized images. In many cases, it's better to use a Static Image Import which will automatically hash the file contents and cache the image forever with a Cache-Control header of immutable.

If no configuration is provided, the default below is used.

You can increase the TTL to reduce the number of revalidations and potentially lower cost:

The expiration (or rather Max Age) of the optimized image is defined by either the minimumCacheTTL or the upstream image Cache-Control header, whichever is larger.

If you need to change the caching behavior per image, you can configure headers to set the Cache-Control header on the upstream image (e.g. /some-asset.jpg, not /_next/image itself).

There is no mechanism to invalidate the cache at this time, so its best to keep minimumCacheTTL low. Otherwise you may need to manually change the src prop or delete <distDir>/cache/images.

The default behavior allows you to import static files such as import icon from './icon.png' and then pass that to the src property.

In some cases, you may wish to disable this feature if it conflicts with other plugins that expect the import to behave differently.

You can disable static image imports inside your next.config.js:

The default loader does not optimize SVG images for a few reasons. First, SVG is a vector format meaning it can be resized losslessly. Second, SVG has many of the same features as HTML/CSS, which can lead to vulnerabilities without proper Content Security Policy (CSP) headers.

Therefore, we recommended using the unoptimized prop when the src prop is known to be SVG. This happens automatically when src ends with ".svg".

However, if you need to serve SVG images with the default Image Optimization API, you can set dangerouslyAllowSVG inside your next.config.js:

In addition, it is strongly recommended to also set contentDispositionType to force the browser to download the image, as well as contentSecurityPolicy to prevent scripts embedded in the image from executing.

The default loader sets the Content-Disposition header to attachment for added protection since the API can serve arbitrary remote images.

The default value is attachment which forces the browser to download the image when visiting directly. This is particularly important when dangerouslyAllowSVG is true.

You can optionally configure inline to allow the browser to render the image when visiting directly, without downloading it.

The default loader will automatically bypass Image Optimization for animated images and serve the image as-is.

Auto-detection for animated files is best-effort and supports GIF, APNG, and WebP. If you want to explicitly bypass Image Optimization for a given animated image, use the unoptimized prop.

**Examples:**

Example 1 (python):
```python
import Image from 'next/legacy/image'
 
const myLoader = ({ src, width, quality }) => {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
 
const MyImage = (props) => {
  return (
    <Image
      loader={myLoader}
      src="me.png"
      alt="Picture of the author"
      width={500}
      height={500}
    />
  )
}
```

Example 2 (python):
```python
import Image from 'next/legacy/image'
const Example = () => (
  <div className="grid-element">
    <Image
      src="/example.png"
      layout="fill"
      sizes="(max-width: 768px) 100vw,
              (max-width: 1200px) 50vw,
              33vw"
    />
  </div>
)
```

Example 3 (python):
```python
import Image from 'next/legacy/image'
import React from 'react'
 
const Example = () => {
  const lazyRoot = React.useRef(null)
 
  return (
    <div ref={lazyRoot} style={{ overflowX: 'scroll', width: '500px' }}>
      <Image lazyRoot={lazyRoot} src="/one.jpg" width="500" height="500" />
      <Image lazyRoot={lazyRoot} src="/two.jpg" width="500" height="500" />
    </div>
  )
}
```

Example 4 (python):
```python
import Image from 'next/legacy/image'
import React from 'react'
 
const Container = React.forwardRef((props, ref) => {
  return (
    <div ref={ref} style={{ overflowX: 'scroll', width: '500px' }}>
      {props.children}
    </div>
  )
})
 
const Example = () => {
  const lazyRoot = React.useRef(null)
 
  return (
    <Container ref={lazyRoot}>
      <Image lazyRoot={lazyRoot} src="/one.jpg" width="500" height="500" />
      <Image lazyRoot={lazyRoot} src="/two.jpg" width="500" height="500" />
    </Container>
  )
}
```

---

## How to lazy load Client Components and libraries

**URL:** https://nextjs.org/docs/15/app/guides/lazy-loading

**Contents:**
- How to lazy load Client Components and libraries
- next/dynamic
- Examples
  - Importing Client Components
  - Skipping SSR
  - Importing Server Components
  - Loading External Libraries
  - Adding a custom loading component
  - Importing Named Exports

Lazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route.

It allows you to defer loading of Client Components and imported libraries, and only include them in the client bundle when they're needed. For example, you might want to defer loading a modal until a user clicks to open it.

There are two ways you can implement lazy loading in Next.js:

By default, Server Components are automatically code split, and you can use streaming to progressively send pieces of UI from the server to the client. Lazy loading applies to Client Components.

next/dynamic is a composite of React.lazy() and Suspense. It behaves the same way in the app and pages directories to allow for incremental migration.

Note: When a Server Component dynamically imports a Client Component, automatic code splitting is currently not supported.

When using React.lazy() and Suspense, Client Components will be prerendered (SSR) by default.

Note: ssr: false option will only work for Client Components, move it into Client Components ensure the client code-splitting working properly.

If you want to disable pre-rendering for a Client Component, you can use the ssr option set to false:

If you dynamically import a Server Component, only the Client Components that are children of the Server Component will be lazy-loaded - not the Server Component itself. It will also help preload the static assets such as CSS when you're using it in Server Components.

Note: ssr: false option is not supported in Server Components. You will see an error if you try to use it in Server Components. ssr: false is not allowed with next/dynamic in Server Components. Please move it into a Client Component.

External libraries can be loaded on demand using the import() function. This example uses the external library fuse.js for fuzzy search. The module is only loaded on the client after the user types in the search input.

To dynamically import a named export, you can return it from the Promise returned by import() function:

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useState } from 'react'
import dynamic from 'next/dynamic'
 
// Client Components:
const ComponentA = dynamic(() => import('../components/A'))
const ComponentB = dynamic(() => import('../components/B'))
const ComponentC = dynamic(() => import('../components/C'), { ssr: false })
 
export default function ClientComponentExample() {
  const [showMore, setShowMore] = useState(false)
 
  return (
    <div>
      {/* Load immediately, but in a separate client bundle */}
      <ComponentA />
 
      {/* Load on demand, only when/if the condition is met */}
      {showMore && <ComponentB />}
      <button onClick={() => setShowMore(!showMore)}>Toggle</button>
 
      {/* Load only on the client side */}
      <ComponentC />
    </div>
  )
}
```

Example 2 (javascript):
```javascript
const ComponentC = dynamic(() => import('../components/C'), { ssr: false })
```

Example 3 (python):
```python
import dynamic from 'next/dynamic'
 
// Server Component:
const ServerComponent = dynamic(() => import('../components/ServerComponent'))
 
export default function ServerComponentExample() {
  return (
    <div>
      <ServerComponent />
    </div>
  )
}
```

Example 4 (python):
```python
'use client'
 
import { useState } from 'react'
 
const names = ['Tim', 'Joe', 'Bel', 'Lee']
 
export default function Page() {
  const [results, setResults] = useState()
 
  return (
    <div>
      <input
        type="text"
        placeholder="Search"
        onChange={async (e) => {
          const { value } = e.currentTarget
          // Dynamically load fuse.js
          const Fuse = (await import('fuse.js')).default
          const fuse = new Fuse(names)
 
          setResults(fuse.search(value))
        }}
      />
      <pre>Results: {JSON.stringify(results, null, 2)}</pre>
    </div>
  )
}
```

---

## mdx-components.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/mdx-components

**Contents:**
- mdx-components.js
- Exports
  - useMDXComponents function
- Version History
- Learn more about MDX Components
  - MDX

The mdx-components.js|tsx file is required to use @next/mdx with App Router and will not work without it. Additionally, you can use it to customize styles.

Use the file mdx-components.tsx (or .js) in the root of your project to define MDX Components. For example, at the same level as pages or app, or inside src if applicable.

The file must export a single function named useMDXComponents. This function does not accept any arguments.

**Examples:**

Example 1 (python):
```python
import type { MDXComponents } from 'mdx/types'
 
const components: MDXComponents = {}
 
export function useMDXComponents(): MDXComponents {
  return components
}
```

Example 2 (python):
```python
import type { MDXComponents } from 'mdx/types'
 
const components: MDXComponents = {}
 
export function useMDXComponents(): MDXComponents {
  return components
}
```

---

## How to create forms with Server Actions

**URL:** https://nextjs.org/docs/15/app/guides/forms

**Contents:**
- How to create forms with Server Actions
- How it works
- Passing additional arguments
- Form validation
- Validation errors
- Pending states
- Optimistic updates
- Nested form elements
- Programmatic form submission

React Server Actions are Server Functions that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create forms in Next.js with Server Actions.

React extends the HTML <form> element to allow Server Actions to be invoked with the action attribute.

When used in a form, the function automatically receives the FormData object. You can then extract the data using the native FormData methods:

Good to know: When working with forms that have multiple fields, use JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData). Note that this object will contain extra properties prefixed with $ACTION_.

Outside of form fields, you can pass additional arguments to a Server Function using the JavaScript bind method. For example, to pass the userId argument to the updateUser Server Function:

The Server Function will receive the userId as an additional argument:

Forms can be validated on the client or server.

To display validation errors or messages, turn the component that defines the <form> into a Client Component and use React useActionState.

When using useActionState, the Server function signature will change to receive a new prevState or initialState parameter as its first argument.

You can then conditionally render the error message based on the state object.

The useActionState hook exposes a pending boolean that can be used to show a loading indicator or disable the submit button while the action is being executed.

Alternatively, you can use the useFormStatus hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending:

You can then nest the SubmitButton component inside the form:

Good to know: In React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available.

You can use the React useOptimistic hook to optimistically update the UI before the Server Function finishes executing, rather than waiting for the response:

You can call Server Actions in elements nested inside <form> such as <button>, <input type="submit">, and <input type="image">. These elements accept the formAction prop or event handlers.

This is useful in cases where you want to call multiple Server Actions within a form. For example, you can create a specific <button> element for saving a post draft in addition to publishing it. See the React <form> docs for more information.

You can trigger a form submission programmatically using the requestSubmit() method. For example, when the user submits a form using the âŒ˜ + Enter keyboard shortcut, you can listen for the onKeyDown event:

This will trigger the submission of the nearest <form> ancestor, which will invoke the Server Function.

**Examples:**

Example 1 (javascript):
```javascript
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'
 
    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }
 
    // mutate data
    // revalidate the cache
  }
 
  return <form action={createInvoice}>...</form>
}
```

Example 2 (python):
```python
'use client'
 
import { updateUser } from './actions'
 
export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)
 
  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Update User Name</button>
    </form>
  )
}
```

Example 3 (unknown):
```unknown
'use server'
 
export async function updateUser(userId: string, formData: FormData) {}
```

Example 4 (python):
```python
'use server'
 
import { z } from 'zod'
 
const schema = z.object({
  email: z.string({
    invalid_type_error: 'Invalid Email',
  }),
})
 
export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })
 
  // Return early if the form data is invalid
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }
 
  // Mutate data
}
```

---

## Cache Components

**URL:** https://nextjs.org/docs/pages/building-your-application/rendering

**Contents:**
- Cache Components
- Cache Components
- How it works
  - 1. Suspense for runtime data
  - 2. Suspense for dynamic data
  - 3. Cached data with use cache
- Using Suspense boundaries
  - Missing Suspense boundaries
  - How streaming works
- Using use cache

Cache Components is a new approach to rendering and caching in Next.js that provides fine-grained control over what gets cached and when, while ensuring a great user experience through Partial Prerendering (PPR).

When developing dynamic applications, you have to balance two primary approaches:

With Cache Components enabled, Next.js treats all routes as dynamic by default. Every request renders with the latest available data. However, most pages are made up of both static and dynamic parts, and not all dynamic data needs to be resolved from source on every request.

Cache Components allows you to mark data, and even parts of your UI as cacheable, which includes them in the pre-render pass alongside static parts of the page.

Before Cache Components, Next.js tried to statically optimize entire pages automatically, which could lead to unexpected behavior when adding dynamic code.

Cache Components implements Partial Prerendering (PPR), and use cache to give you the best of both worlds:

When a user visits a route:

ðŸŽ¥ Watch: Why PPR and how it works â†’ YouTube (10 minutes).

Good to know: Cache Components is an opt-in feature. Enable it by setting the cacheComponents flag to true in your Next config file. See Enabling Cache Components for more details.

Cache Components gives you three key tools to control rendering:

Some data is only available at runtime when an actual user makes a request. APIs like cookies, headers, and searchParams access request-specific information. Wrap components using these APIs in Suspense boundaries so the rest of the page can be pre-rendered as a static shell.

Runtime APIs include:

Dynamic data like fetch calls or database queries (db.query(...)) can change between requests but isn't user-specific. The connection API is meta-dynamicâ€”it represents waiting for a user navigation even though there's no actual data to return. Wrap components that use these in Suspense boundaries to enable streaming.

Dynamic data patterns include:

Add use cache to any Server Component to make it cached and include it in the pre-rendered shell. You cannot use runtime APIs from inside a cached component. You can also mark utility functions as use cache and call them from Server Components.

React Suspense boundaries let you define what fallback UI to use when it wraps dynamic or runtime data.

Content outside the boundary, including the fallback UI, is pre-rendered as a static shell, while content inside the boundary streams in when ready.

Here's how to use Suspense with Cache Components:

At build time, Next.js pre-renders the static content and the fallback UI, while the dynamic content is postponed until a user requests the route.

Good to know: Wrapping a component in Suspense doesn't make it dynamic; your API usage does. Suspense acts as a boundary that encapsulates dynamic content and enables streaming.

Cache Components enforces that dynamic code must be wrapped in a Suspense boundary. If you forget, you'll see the Uncached data was accessed outside of <Suspense> error:

Uncached data was accessed outside of <Suspense>

This delays the entire page from rendering, resulting in a slow user experience. Next.js uses this error to ensure your app loads instantly on every navigation.

To fix this, you can either:

Wrap the component in a <Suspense> boundary. This allows Next.js to stream its contents to the user as soon as it's ready, without blocking the rest of the app.

Move the asynchronous await into a Cache Component("use cache"). This allows Next.js to statically prerender the component as part of the HTML document, so it's instantly visible to the user.

Note that request-specific information, such as params, cookies, and headers, is not available during static prerendering, so it must be wrapped in <Suspense>.

This error helps prevent a situation where, instead of getting a static shell instantly, users would hit a blocking runtime render with nothing to show. To fix it, add a Suspense boundary or use use cache to cache the work instead.

Streaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.

With partial pre-rendering, the initial UI can be sent immediately to the browser while the dynamic parts render. This decreases time to UI and may decrease total request time depending on how much of your UI is pre-rendered.

To reduce network overhead, the full response, including static HTML and streamed dynamic parts, is sent in a single HTTP request. This avoids extra round-trips and improves both initial load and overall performance.

While Suspense boundaries manage dynamic content, the use cache directive is available for caching data or computations that don't change often.

Add use cache to cache a page, component, or async function, and define a lifetime with cacheLife:

When using use cache, keep these constraints in mind:

Like Server Actions, arguments to cached functions must be serializable. This means you can pass primitives, plain objects, and arrays, but not class instances, functions, or other complex types.

You can accept unserializable values as arguments as long as you don't introspect them. However, you can return them. This allows patterns like cached components that accept Server or Client Components as children:

Tag cached data with cacheTag and revalidate it after mutations using updateTag in Server Actions for immediate updates, or revalidateTag delay in updates are acceptable.

Use updateTag when you need to expire and immediately refresh cached data within the same request:

Use revalidateTag when you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency.

For more detailed explanation and usage examples, see the use cache API reference.

You can enable Cache Components (which includes PPR) by adding the cacheComponents option to your Next config file:

When the cacheComponents flag is enabled, Next.js uses React's <Activity> component to preserve component state during client-side navigation.

Rather than unmounting the previous route when you navigate away, Next.js sets the Activity mode to "hidden". This means:

This behavior improves the navigation experience by maintaining UI state (form inputs, or expanded sections) when users navigate back and forth between routes.

Good to know: Next.js uses heuristics to keep a few recently visited routes "hidden", while older routes are removed from the DOM to prevent excessive growth.

When Cache Components is enabled, several route segment config options are no longer needed or supported. Here's what changes and how to migrate:

Not needed. All pages are dynamic by default with Cache Components enabled, so this configuration is unnecessary.

Replace with use cache. You must add use cache to each Layout and Page for the associated route instead.

Note: force-static previously allowed the use of runtime APIs like cookies(), but this is no longer supported. If you add use cache and see an error related to runtime data, you must remove the use of runtime APIs.

Replace with cacheLife. Use the cacheLife function to define cache duration instead of the route segment config.

Not needed. With use cache, all data fetching within a cached scope is automatically cached, making fetchCache unnecessary.

Not supported. Cache Components requires Node.js runtime and will throw errors with Edge Runtime.

Understanding how Cache Components changes your mental model:

When accessing runtime APIs like cookies(), Next.js will only pre-render the fallback UI above this component.

In this example, we have no fallback defined, so Next.js shows an error instructing us to provide one. The <User /> component needs to be wrapped in Suspense because it uses the cookies API:

Now we have a Suspense boundary around our User component we can pre-render the Page with a Skeleton UI and stream in the <User /> UI when a specific user makes a request

Components that access runtime values like cookies or searchParams cannot be prerendered. To prerender more of a page's content, you can pass these props down and access their values lower in the tree. For example, if you are reading searchParams from a <Page /> component, you can forward this value to another component as a prop:

Inside of the table component, accessing the value from searchParams will make the component dynamic while the rest of the page will be pre-rendered.

GET Route Handlers follow the same model as normal UI routes in your application. They are dynamic by default, can be pre-rendered when deterministic, and you can use cache to include more dynamic data in the cached response.

Dynamic example, returns a different number for every request:

A handler that returns only static data will be pre-rendered at build time:

If you had a route that returned fresh dynamic data on every request, say products from a database:

To cache this and avoid hitting the database on every request, extract the dynamic work into a use cache function and set cacheLife('hours') so the database is queried at most once per hour:

No. Cache Components implements PPR as a feature. The old experimental PPR flag has been removed but PPR is here to stay.

PPR provides the static shell and streaming infrastructure; use cache lets you include optimized dynamic output in that shell when beneficial.

What you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use use cache with cacheLife to describe that behavior.

For content management systems with update mechanisms, consider using tags with longer cache durations and rely on revalidateTag to mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively.

Use cacheTag to tag your cached data, then trigger updateTag or revalidateTag.

**Examples:**

Example 1 (javascript):
```javascript
export async function getProducts() {
  'use cache'
  const data = await db.query('SELECT * FROM products')
  return data
}
```

Example 2 (python):
```python
import { Suspense } from 'react'
 
export default function Page() {
  return (
    <>
      <h1>This will be pre-rendered</h1>
      <Suspense fallback={<Skeleton />}>
        <DynamicContent />
      </Suspense>
    </>
  )
}
 
async function DynamicContent() {
  const res = await fetch('http://api.cms.com/posts')
  const { posts } = await res.json()
  return <div>{/* ... */}</div>
}
```

Example 3 (python):
```python
import { cacheLife } from 'next/cache'
 
export default async function Page() {
  'use cache'
  cacheLife('hours')
  // fetch or compute
  return <div>...</div>
}
```

Example 4 (python):
```python
import type { ReactNode } from 'react'
import { setTimeout } from 'node:timers/promises'
 
async function getSiteTitle() {
  // Simulate a slow database or API call
  await setTimeout(1000) // from 'node:timers/promises'
  return 'My Website'
}
 
export async function CachedWrapper({ children }: { children: ReactNode }) {
  'use cache'
  const title = await getSiteTitle()
 
  // Don't introspect children, just pass it through
  return (
    <div className="wrapper">
      <h1>{title}</h1>
      {children}
    </div>
  )
}
```

---

## getStaticPaths

**URL:** https://nextjs.org/docs/pages/api-reference/functions/get-static-paths

**Contents:**
- getStaticPaths
- getStaticPaths return values
  - paths
  - fallback: false
  - fallback: true
    - When is fallback: true useful?
  - fallback: 'blocking'
  - Fallback pages
- Version History

When exporting a function called getStaticPaths from a page that uses Dynamic Routes, Next.js will statically pre-render all the paths specified by getStaticPaths.

The getStaticPaths function should return an object with the following required properties:

The paths key determines which paths will be pre-rendered. For example, suppose that you have a page that uses Dynamic Routes named pages/posts/[id].js. If you export getStaticPaths from this page and return the following for paths:

Then, Next.js will statically generate /posts/1 and /posts/2 during next build using the page component in pages/posts/[id].js.

The value for each params object must match the parameters used in the page name:

The params strings are case-sensitive and ideally should be normalized to ensure the paths are generated correctly. For example, if WoRLD is returned for a param it will only match if WoRLD is the actual path visited, not world or World.

Separate of the params object a locale field can be returned when i18n is configured, which configures the locale for the path being generated.

If fallback is false, then any paths not returned by getStaticPaths will result in a 404 page.

When next build is run, Next.js will check if getStaticPaths returned fallback: false, it will then build only the paths returned by getStaticPaths. This option is useful if you have a small number of paths to create, or new page data is not added often. If you find that you need to add more paths, and you have fallback: false, you will need to run next build again so that the new paths can be generated.

The following example pre-renders one blog post per page called pages/posts/[id].js. The list of blog posts will be fetched from a CMS and returned by getStaticPaths. Then, for each page, it fetches the post data from a CMS using getStaticProps.

If fallback is true, then the behavior of getStaticProps changes in the following ways:

Good to know: fallback: true is not supported when using output: 'export'.

fallback: true is useful if your app has a very large number of static pages that depend on data (such as a very large e-commerce site). If you want to pre-render all product pages, the builds would take a very long time.

Instead, you may statically generate a small subset of pages and use fallback: true for the rest. When someone requests a page that is not generated yet, the user will see the page with a loading indicator or skeleton component.

Shortly after, getStaticProps finishes and the page will be rendered with the requested data. From now on, everyone who requests the same page will get the statically pre-rendered page.

This ensures that users always have a fast experience while preserving fast builds and the benefits of Static Generation.

fallback: true will not update generated pages, for that take a look at Incremental Static Regeneration.

If fallback is 'blocking', new paths not returned by getStaticPaths will wait for the HTML to be generated, identical to SSR (hence why blocking), and then be cached for future requests so it only happens once per path.

getStaticProps will behave as follows:

fallback: 'blocking' will not update generated pages by default. To update generated pages, use Incremental Static Regeneration in conjunction with fallback: 'blocking'.

Good to know: fallback: 'blocking' is not supported when using output: 'export'.

In the â€œfallbackâ€ version of a page:

The following example showcases using isFallback:

**Examples:**

Example 1 (python):
```python
import type {
  InferGetStaticPropsType,
  GetStaticProps,
  GetStaticPaths,
} from 'next'
 
type Repo = {
  name: string
  stargazers_count: number
}
 
export const getStaticPaths = (async () => {
  return {
    paths: [
      {
        params: {
          name: 'next.js',
        },
      }, // See the "paths" section below
    ],
    fallback: true, // false or "blocking"
  }
}) satisfies GetStaticPaths
 
export const getStaticProps = (async (context) => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo = await res.json()
  return { props: { repo } }
}) satisfies GetStaticProps<{
  repo: Repo
}>
 
export default function Page({
  repo,
}: InferGetStaticPropsType<typeof getStaticProps>) {
  return repo.stargazers_count
}
```

Example 2 (unknown):
```unknown
return {
  paths: [
    { params: { id: '1' }},
    {
      params: { id: '2' },
      // with i18n configured the locale for the path can be returned as well
      locale: "en",
    },
  ],
  fallback: ...
}
```

Example 3 (javascript):
```javascript
function Post({ post }) {
  // Render post...
}
 
// This function gets called at build time
export async function getStaticPaths() {
  // Call an external API endpoint to get posts
  const res = await fetch('https://.../posts')
  const posts = await res.json()
 
  // Get the paths we want to pre-render based on posts
  const paths = posts.map((post) => ({
    params: { id: post.id },
  }))
 
  // We'll pre-render only these paths at build time.
  // { fallback: false } means other routes should 404.
  return { paths, fallback: false }
}
 
// This also gets called at build time
export async function getStaticProps({ params }) {
  // params contains the post `id`.
  // If the route is like /posts/1, then params.id is 1
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()
 
  // Pass post data to the page via props
  return { props: { post } }
}
 
export default Post
```

Example 4 (python):
```python
import { useRouter } from 'next/router'
 
function Post({ post }) {
  const router = useRouter()
 
  // If the page is not yet generated, this will be displayed
  // initially until getStaticProps() finishes running
  if (router.isFallback) {
    return <div>Loading...</div>
  }
 
  // Render post...
}
 
// This function gets called at build time
export async function getStaticPaths() {
  return {
    // Only `/posts/1` and `/posts/2` are generated at build time
    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
    // Enable statically generating additional pages
    // For example: `/posts/3`
    fallback: true,
  }
}
 
// This also gets called at build time
export async function getStaticProps({ params }) {
  // params contains the post `id`.
  // If the route is like /posts/1, then params.id is 1
  const res = await fetch(`https://.../posts/${params.id}`)
  const post = await res.json()
 
  // Pass post data to the page via props
  return {
    props: { post },
    // Re-generate the post at most once per second
    // if a request comes in
    revalidate: 1,
  }
}
 
export default Post
```

---

## How to use CSS-in-JS libraries

**URL:** https://nextjs.org/docs/15/app/guides/css-in-js

**Contents:**
- How to use CSS-in-JS libraries
- Configuring CSS-in-JS in app
  - styled-jsx
  - Styled Components

Warning: Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React, including concurrent rendering.

The following libraries are supported in Client Components in the app directory (alphabetical):

The following are currently working on support:

Good to know: We're testing out different CSS-in-JS libraries and we'll be adding more examples for libraries that support React 18 features and/or the app directory.

Configuring CSS-in-JS is a three-step opt-in process that involves:

Using styled-jsx in Client Components requires using v5.1.0. First, create a new registry:

Then, wrap your root layout with the registry:

View an example here.

Below is an example of how to configure styled-components@6 or newer:

First, enable styled-components in next.config.js.

Then, use the styled-components API to create a global registry component to collect all CSS style rules generated during a render, and a function to return those rules. Then use the useServerInsertedHTML hook to inject the styles collected in the registry into the <head> HTML tag in the root layout.

Wrap the children of the root layout with the style registry component:

View an example here.

**Examples:**

Example 1 (python):
```python
'use client'
 
import React, { useState } from 'react'
import { useServerInsertedHTML } from 'next/navigation'
import { StyleRegistry, createStyleRegistry } from 'styled-jsx'
 
export default function StyledJsxRegistry({
  children,
}: {
  children: React.ReactNode
}) {
  // Only create stylesheet once with lazy initial state
  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state
  const [jsxStyleRegistry] = useState(() => createStyleRegistry())
 
  useServerInsertedHTML(() => {
    const styles = jsxStyleRegistry.styles()
    jsxStyleRegistry.flush()
    return <>{styles}</>
  })
 
  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>
}
```

Example 2 (python):
```python
import StyledJsxRegistry from './registry'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <StyledJsxRegistry>{children}</StyledJsxRegistry>
      </body>
    </html>
  )
}
```

Example 3 (unknown):
```unknown
module.exports = {
  compiler: {
    styledComponents: true,
  },
}
```

Example 4 (python):
```python
'use client'
 
import React, { useState } from 'react'
import { useServerInsertedHTML } from 'next/navigation'
import { ServerStyleSheet, StyleSheetManager } from 'styled-components'
 
export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode
}) {
  // Only create stylesheet once with lazy initial state
  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())
 
  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement()
    styledComponentsStyleSheet.instance.clearTag()
    return <>{styles}</>
  })
 
  if (typeof window !== 'undefined') return <>{children}</>
 
  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  )
}
```

---

## sitemap.xml

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap

**Contents:**
- sitemap.xml
  - Sitemap files (.xml)
  - Generating a sitemap using code (.js, .ts)
  - Image Sitemaps
  - Video Sitemaps
  - Generate a localized Sitemap
  - Generating multiple sitemaps
- Returns
- Version History
- Next Steps

sitemap.(xml|js|ts) is a special file that matches the Sitemaps XML format to help search engine crawlers index your site more efficiently.

For smaller applications, you can create a sitemap.xml file and place it in the root of your app directory.

You can use the sitemap.(js|ts) file convention to programmatically generate a sitemap by exporting a default function that returns an array of URLs. If using TypeScript, a Sitemap type is available.

Good to know: sitemap.js is a special Route Handler that is cached by default unless it uses a Dynamic API or dynamic config option.

You can use images property to create image sitemaps. Learn more details in the Google Developer Docs.

You can use videos property to create video sitemaps. Learn more details in the Google Developer Docs.

While a single sitemap will work for most applications. For large web applications, you may need to split a sitemap into multiple files.

There are two ways you can create multiple sitemaps:

For example, to split a sitemap using generateSitemaps, return an array of objects with the sitemap id. Then, use the id to generate the unique sitemaps.

Your generated sitemaps will be available at /.../sitemap/[id]. For example, /product/sitemap/1.xml.

See the generateSitemaps API reference for more information.

The default function exported from sitemap.(xml|ts|js) should return an array of objects with the following properties:

**Examples:**

Example 1 (unknown):
```unknown
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://acme.com</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>yearly</changefreq>
    <priority>1</priority>
  </url>
  <url>
    <loc>https://acme.com/about</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.8</priority>
  </url>
  <url>
    <loc>https://acme.com/blog</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.5</priority>
  </url>
</urlset>
```

Example 2 (python):
```python
import type { MetadataRoute } from 'next'
 
export default function sitemap(): MetadataRoute.Sitemap {
  return [
    {
      url: 'https://acme.com',
      lastModified: new Date(),
      changeFrequency: 'yearly',
      priority: 1,
    },
    {
      url: 'https://acme.com/about',
      lastModified: new Date(),
      changeFrequency: 'monthly',
      priority: 0.8,
    },
    {
      url: 'https://acme.com/blog',
      lastModified: new Date(),
      changeFrequency: 'weekly',
      priority: 0.5,
    },
  ]
}
```

Example 3 (unknown):
```unknown
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://acme.com</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>yearly</changefreq>
    <priority>1</priority>
  </url>
  <url>
    <loc>https://acme.com/about</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.8</priority>
  </url>
  <url>
    <loc>https://acme.com/blog</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.5</priority>
  </url>
</urlset>
```

Example 4 (python):
```python
import type { MetadataRoute } from 'next'
 
export default function sitemap(): MetadataRoute.Sitemap {
  return [
    {
      url: 'https://example.com',
      lastModified: '2021-01-01',
      changeFrequency: 'weekly',
      priority: 0.5,
      images: ['https://example.com/image.jpg'],
    },
  ]
}
```

---

## route.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/route

**Contents:**
- route.js
- Reference
  - HTTP Methods
  - Parameters
    - request (optional)
    - context (optional)
  - Route Context Helper
- Examples
  - Cookies
  - Headers

Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.

A route file allows you to create custom request handlers for a given route. The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS.

The request object is a NextRequest object, which is an extension of the Web Request API. NextRequest gives you further control over the incoming request, including easily accessing cookies and an extended, parsed, URL object nextUrl.

You can type the Route Handler context using RouteContext to get strongly typed params from a route literal. RouteContext is a globally available helper.

You can read or set cookies with cookies from next/headers.

Alternatively, you can return a new Response using the Set-Cookie header.

You can also use the underlying Web APIs to read cookies from the request (NextRequest):

You can read headers with headers from next/headers.

This headers instance is read-only. To set headers, you need to return a new Response with new headers.

You can also use the underlying Web APIs to read headers from the request (NextRequest):

You can revalidate cached data using the revalidate route segment config option.

Route Handlers can use Dynamic Segments to create request handlers from dynamic data.

The request object passed to the Route Handler is a NextRequest instance, which includes some additional convenience methods, such as those for more easily handling query parameters.

Streaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about the AI SDK.

These abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly.

You can read the Request body using the standard Web API methods:

You can read the FormData using the request.formData() function:

Since formData data are all strings, you may want to use zod-form-data to validate the request and retrieve data in the format you prefer (e.g. number).

You can set CORS headers for a specific Route Handler using the standard Web API methods:

You can use a Route Handler to receive webhooks from third-party services:

Notably, unlike API Routes with the Pages Router, you do not need to use bodyParser to use any additional configuration.

You can use Route Handlers to return non-UI content. Note that sitemap.xml, robots.txt, app icons, and open graph images all have built-in support.

Route Handlers use the same route segment configuration as pages and layouts.

See the API reference for more details.

**Examples:**

Example 1 (unknown):
```unknown
export async function GET() {
  return Response.json({ message: 'Hello World' })
}
```

Example 2 (unknown):
```unknown
export async function GET(request: Request) {}
 
export async function HEAD(request: Request) {}
 
export async function POST(request: Request) {}
 
export async function PUT(request: Request) {}
 
export async function DELETE(request: Request) {}
 
export async function PATCH(request: Request) {}
 
// If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler.
export async function OPTIONS(request: Request) {}
```

Example 3 (python):
```python
import type { NextRequest } from 'next/server'
 
export async function GET(request: NextRequest) {
  const url = request.nextUrl
}
```

Example 4 (javascript):
```javascript
export async function GET(
  request: Request,
  { params }: { params: Promise<{ team: string }> }
) {
  const { team } = await params
}
```

---

## How to use Next.js as a backend for your frontend

**URL:** https://nextjs.org/docs/15/app/guides/backend-for-frontend

**Contents:**
- How to use Next.js as a backend for your frontend
- Public Endpoints
- Content types
  - Consuming request payloads
- Manipulating data
- Proxying to a backend
- NextRequest and NextResponse
- Webhooks and callback URLs
- Redirects
- Middleware

Next.js supports the "Backend for Frontend" pattern. This lets you create public endpoints to handle HTTP requests and return any content typeâ€”not just HTML. You can also access data sources and perform side effects like updating remote data.

If you are starting a new project, using create-next-app with the --api flag automatically includes an example route.ts in your new projectâ€™s app/ folder, demonstrating how to create an API endpoint.

Good to know: Next.js backend capabilities are not a full backend replacement. They serve as an API layer that:

To implement this pattern, use:

Route Handlers are public HTTP endpoints. Any client can access them.

Create a Route Handler using the route.ts or route.js file convention:

This handles GET requests sent to /api.

Use try/catch blocks for operations that may throw an exception:

Avoid exposing sensitive information in error messages sent to the client.

To restrict access, implement authentication and authorization. See Authentication.

Route Handlers let you serve non-UI responses, including JSON, XML, images, files, and plain text.

Next.js uses file conventions for common endpoints:

You can also define custom ones, such as:

For example, app/rss.xml/route.ts creates a Route Handler for rss.xml.

Sanitize any input used to generate markup.

Use Request instance methods like .json(), .formData(), or .text() to access the request body.

GET and HEAD requests donâ€™t carry a body.

Good to know: Validate data before passing it to other systems

You can only read the request body once. Clone the request if you need to read it again:

Route Handlers can transform, filter, and aggregate data from one or more sources. This keeps logic out of the frontend and avoids exposing internal systems.

You can also offload heavy computations to the server and reduce client battery and data usage.

Good to know: This example uses POST to avoid putting geo-location data in the URL. GET requests may be cached or logged, which could expose sensitive info.

You can use a Route Handler as a proxy to another backend. Add validation logic before forwarding the request.

Next.js extends the Request and Response Web APIs with methods that simplify common operations. These extensions are available in both Route Handlers and Middleware.

Both provide methods for reading and manipulating cookies.

NextRequest includes the nextUrl property, which exposes parsed values from the incoming request, for example, it makes it easier to access request pathname and search params.

NextResponse provides helpers like next(), json(), redirect(), and rewrite().

You can pass NextRequest to any function expecting Request. Likewise, you can return NextResponse where a Response is expected.

Learn more about NextRequest and NextResponse.

Use Route Handlers to receive event notifications from third-party applications.

For example, revalidate a route when content changes in a CMS. Configure the CMS to call a specific endpoint on changes.

Callback URLs are another use case. When a user completes a third-party flow, the third party sends them to a callback URL. Use a Route Handler to verify the response and decide where to redirect the user.

Learn more about redirects in redirect and permanentRedirect

Only one middleware file is allowed per project. Use config.matcher to target specific paths. Learn more about middleware.

Use middleware to generate a response before the request reaches a route path.

You can also proxy requests using middleware:

Another type of response middleware can produce are redirects:

Be deliberate about where headers go, and avoid directly passing incoming request headers to the outgoing response.

Learn more in NextResponse headers in Middleware.

You can implement rate limiting in your Next.js backend. In addition to code-based checks, enable any rate limiting features provided by your host.

Never trust incoming request data. Validate content type and size, and sanitize against XSS before use.

Use timeouts to prevent abuse and protect server resources.

Store user-generated static assets in dedicated services. When possible, upload them from the browser and store the returned URI in your database to reduce request size.

Always verify credentials before granting access. Do not rely on middleware alone for authentication and authorization.

Remove sensitive or unnecessary data from responses and backend logs.

Rotate credentials and API keys regularly.

Preflight requests use the OPTIONS method to ask the server if a request is allowed based on origin, method, and headers.

If OPTIONS is not defined, Next.js adds it automatically and sets the Allow header based on the other defined methods.

Community libraries often use the factory pattern for Route Handlers.

This creates a shared handler for GET and POST requests. The library customizes behavior based on the method and pathname in the request.

Libraries can also provide a middleware factory.

See more examples on using Router Handlers and the middleware API references.

These examples include, working with Cookies, Headers, Streaming, Middleware negative matching, and other useful code snippets.

Fetch data in Server Components directly from its source, not via Route Handlers.

For Server Components pre-rendered at build time, using Route Handlers will fail the build step. This is because, while building there is no server listening for these requests.

For Server Components rendered on demand, fetching from Route Handlers is slower due to the extra HTTP round trip between the handler and the render process.

A server side fetch request uses absolute URLs. This implies an HTTP round trip, to an external server. During development, your own development server acts as the external server. At build time there is no server, and at runtime, the server is available through your public facing domain.

Server Components cover most data-fetching needs. However, fetching data client side might be necessary for:

For these, use community libraries like swr or react-query.

Server Actions let you run server-side code from the client. Their primary purpose is to mutate data from your frontend client.

Server Actions are queued. Using them for data fetching introduces sequential execution.

export mode outputs a static site without a runtime server. Features that require the Next.js runtime are not supported, because this mode produces a static site, and no runtime server.

In export mode, only GET Route Handlers are supported, in combination with the dynamic route segment config, set to 'force-static'.

This can be used to generate static HTML, JSON, TXT, or other files.

Some hosts deploy Route Handlers as lambda functions. This means:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --api
```

Example 2 (unknown):
```unknown
export function GET(request: Request) {}
```

Example 3 (python):
```python
import { submit } from '@/lib/submit'
 
export async function POST(request: Request) {
  try {
    await submit(request)
    return new Response(null, { status: 204 })
  } catch (reason) {
    const message =
      reason instanceof Error ? reason.message : 'Unexpected error'
 
    return new Response(message, { status: 500 })
  }
}
```

Example 4 (javascript):
```javascript
export async function GET(request: Request) {
  const rssResponse = await fetch(/* rss endpoint */)
  const rssData = await rssResponse.json()
 
  const rssFeed = `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
 <title>${rssData.title}</title>
 <description>${rssData.description}</description>
 <link>${rssData.link}</link>
 <copyright>${rssData.copyright}</copyright>
 ${rssData.items.map((item) => {
   return `<item>
    <title>${item.title}</title>
    <description>${item.description}</description>
    <link>${item.link}</link>
    <pubDate>${item.publishDate}</pubDate>
    <guid isPermaLink="false">${item.guid}</guid>
 </item>`
 })}
</channel>
</rss>`
 
  const headers = new Headers({ 'content-type': 'application/xml' })
 
  return new Response(rssFeed, { headers })
}
```

---

## No CSS Tags

**URL:** https://nextjs.org/docs/messages/no-css-tags

**Contents:**
- No CSS Tags
- Why This Error Occurred
- Possible Ways to Fix It

Prevent manual stylesheet tags.

A link element was used to link to an external stylesheet. This can negatively affect CSS resource loading on your webpage.

There are multiple ways to include styles using Next.js' built-in CSS support, including the option to use @import within the root stylesheet that is imported in pages/_app.js:

Another option is to use CSS Modules to import the CSS file scoped specifically to the component.

Refer to the Built-In CSS Support documentation to learn about all the ways to include CSS to your application.

**Examples:**

Example 1 (unknown):
```unknown
/* Root stylesheet */
@import 'extra.css';
 
body {
  /* ... */
}
```

Example 2 (python):
```python
import styles from './extra.module.css'
 
export class Home {
  render() {
    return (
      <div>
        <button type="button" className={styles.active}>
          Open
        </button>
      </div>
    )
  }
}
```

---

## How to add analytics to your Next.js application

**URL:** https://nextjs.org/docs/app/guides/analytics

**Contents:**
- How to add analytics to your Next.js application
- Client Instrumentation
- Build Your Own
- Web Vitals
- Sending results to external systems

Next.js has built-in support for measuring and reporting performance metrics. You can either use the useReportWebVitals hook to manage reporting yourself, or alternatively, Vercel provides a managed service to automatically collect and visualize metrics for you.

For more advanced analytics and monitoring needs, Next.js provides a instrumentation-client.js|ts file that runs before your application's frontend code starts executing. This is ideal for setting up global analytics, error tracking, or performance monitoring tools.

To use it, create an instrumentation-client.js or instrumentation-client.ts file in your application's root directory:

Since the useReportWebVitals hook requires the 'use client' directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component.

View the API Reference for more information.

Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:

You can handle all the results of these metrics using the name property.

You can send results to any endpoint to measure and track real user performance on your site. For example:

Good to know: If you use Google Analytics, using the id value can allow you to construct metric distributions manually (to calculate percentiles, etc.)

Read more about sending results to Google Analytics.

**Examples:**

Example 1 (javascript):
```javascript
// Initialize analytics before the app starts
console.log('Analytics initialized')
 
// Set up global error tracking
window.addEventListener('error', (event) => {
  // Send to your error tracking service
  reportError(event.error)
})
```

Example 2 (python):
```python
'use client'
 
import { useReportWebVitals } from 'next/web-vitals'
 
export function WebVitals() {
  useReportWebVitals((metric) => {
    console.log(metric)
  })
}
```

Example 3 (python):
```python
import { WebVitals } from './_components/web-vitals'
 
export default function Layout({ children }) {
  return (
    <html>
      <body>
        <WebVitals />
        {children}
      </body>
    </html>
  )
}
```

Example 4 (python):
```python
'use client'
 
import { useReportWebVitals } from 'next/web-vitals'
 
export function WebVitals() {
  useReportWebVitals((metric) => {
    switch (metric.name) {
      case 'FCP': {
        // handle FCP results
      }
      case 'LCP': {
        // handle LCP results
      }
      // ...
    }
  })
}
```

---

## How to set up Jest with Next.js

**URL:** https://nextjs.org/docs/app/guides/testing/jest

**Contents:**
- How to set up Jest with Next.js
- Quickstart
- Manual setup
- Optional: Handling Absolute Imports and Module Path Aliases
- Optional: Extend Jest with custom matchers
- Add a test script to package.json
  - Creating your first test
- Running your tests
- Additional Resources

Jest and React Testing Library are frequently used together for Unit Testing and Snapshot Testing. This guide will show you how to set up Jest with Next.js and write your first tests.

Good to know: Since async Server Components are new to the React ecosystem, Jest currently does not support them. While you can still run unit tests for synchronous Server and Client Components, we recommend using an E2E tests for async components.

You can use create-next-app with the Next.js with-jest example to quickly get started:

Since the release of Next.js 12, Next.js now has built-in configuration for Jest.

To set up Jest, install jest and the following packages as dev dependencies:

Generate a basic Jest configuration file by running the following command:

This will take you through a series of prompts to setup Jest for your project, including automatically creating a jest.config.ts|js file.

Update your config file to use next/jest. This transformer has all the necessary configuration options for Jest to work with Next.js:

Under the hood, next/jest is automatically configuring Jest for you, including:

Good to know: To test environment variables directly, load them manually in a separate setup script or in your jest.config.ts file. For more information, please see Test Environment Variables.

If your project is using Module Path Aliases, you will need to configure Jest to resolve the imports by matching the paths option in the jsconfig.json file with the moduleNameMapper option in the jest.config.js file. For example:

@testing-library/jest-dom includes a set of convenient custom matchers such as .toBeInTheDocument() making it easier to write tests. You can import the custom matchers for every test by adding the following option to the Jest configuration file:

Then, inside jest.setup, add the following import:

Good to know: extend-expect was removed in v6.0, so if you are using @testing-library/jest-dom before version 6, you will need to import @testing-library/jest-dom/extend-expect instead.

If you need to add more setup options before each test, you can add them to the jest.setup file above.

Finally, add a Jest test script to your package.json file:

jest --watch will re-run tests when a file is changed. For more Jest CLI options, please refer to the Jest Docs.

Your project is now ready to run tests. Create a folder called __tests__ in your project's root directory.

For example, we can add a test to check if the <Page /> component successfully renders a heading:

Optionally, add a snapshot test to keep track of any unexpected changes in your component:

Then, run the following command to run your tests:

For further reading, you may find these resources helpful:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --example with-jest with-jest-app
```

Example 2 (unknown):
```unknown
npm install -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest
# or
yarn add -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest
# or
pnpm install -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest
```

Example 3 (unknown):
```unknown
npm init jest@latest
# or
yarn create jest@latest
# or
pnpm create jest@latest
```

Example 4 (python):
```python
import type { Config } from 'jest'
import nextJest from 'next/jest.js'
 
const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
})
 
// Add any custom config to be passed to Jest
const config: Config = {
  coverageProvider: 'v8',
  testEnvironment: 'jsdom',
  // Add more setup options before each test is run
  // setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
}
 
// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
export default createJestConfig(config)
```

---

## Migrating

**URL:** https://nextjs.org/docs/app/guides/migrating

**Contents:**
- Migrating
  - App Router
  - Create React App
  - Vite

---

## File-system conventions

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions

**Contents:**
- File-system conventions
  - default.js
  - Dynamic Segments
  - error.js
  - forbidden.js
  - instrumentation.js
  - instrumentation-client.js
  - Intercepting Routes
  - layout.js
  - loading.js

---

## How to migrate from Vite to Next.js

**URL:** https://nextjs.org/docs/app/guides/migrating/from-vite

**Contents:**
- How to migrate from Vite to Next.js
- Why Switch?
  - Slow initial page loading time
  - No automatic code splitting
  - Network waterfalls
  - Fast and intentional loading states
  - Choose the data fetching strategy
  - Proxy
  - Built-in Optimizations
- Migration Steps

This guide will help you migrate an existing Vite application to Next.js.

There are several reasons why you might want to switch from Vite to Next.js:

If you have built your application with the default Vite plugin for React, your application is a purely client-side application. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:

The previous issue of slow loading times can be somewhat managed with code splitting. However, if you try to do code splitting manually, you'll often make performance worse. It's easy to inadvertently introduce network waterfalls when code-splitting manually. Next.js provides automatic code splitting built into its router.

A common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One common pattern for data fetching in an SPA is to initially render a placeholder, and then fetch data after the component has mounted. Unfortunately, this means that a child component that fetches data can't start fetching until the parent component has finished loading its own data.

While fetching data on the client is supported with Next.js, it also gives you the option to shift data fetching to the server, which can eliminate client-server waterfalls.

With built-in support for streaming through React Suspense, you can be more intentional about which parts of your UI you want to load first and in what order without introducing network waterfalls.

This enables you to build pages that are faster to load and eliminate layout shifts.

Depending on your needs, Next.js allows you to choose your data fetching strategy on a page and component basis. You can decide to fetch at build time, at request time on the server, or on the client. For example, you can fetch data from your CMS and render your blog posts at build time, which can then be efficiently cached on a CDN.

Next.js Proxy allows you to run code on the server before a request is completed. This is especially useful to avoid having a flash of unauthenticated content when the user visits an authenticated-only page by redirecting the user to a login page. The proxy is also useful for experimentation and internationalization.

Images, fonts, and third-party scripts often have significant impact on an application's performance. Next.js comes with built-in components that automatically optimize those for you.

Our goal with this migration is to get a working Next.js application as quickly as possible, so that you can then adopt Next.js features incrementally. To begin with, we'll keep it as a purely client-side application (SPA) without migrating your existing router. This helps minimize the chances of encountering issues during the migration process and reduces merge conflicts.

The first thing you need to do is to install next as a dependency:

Create a next.config.mjs at the root of your project. This file will hold your Next.js configuration options.

Good to know: You can use either .js or .mjs for your Next.js configuration file.

If you're using TypeScript, you need to update your tsconfig.json file with the following changes to make it compatible with Next.js. If you're not using TypeScript, you can skip this step.

Here's an example of a working tsconfig.json with those changes:

You can find more information about configuring TypeScript on the Next.js docs.

A Next.js App Router application must include a root layout file, which is a React Server Component that will wrap all pages in your application. This file is defined at the top level of the app directory.

The closest equivalent to the root layout file in a Vite application is the index.html file, which contains your <html>, <head>, and <body> tags.

In this step, you'll convert your index.html file into a root layout file:

Good to know: .js, .jsx, or .tsx extensions can be used for Layout files.

With the above changes, you shifted from declaring everything in your index.html to using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages.

On Next.js you declare an entrypoint for your application by creating a page.tsx file. The closest equivalent of this file on Vite is your main.tsx file. In this step, youâ€™ll set up the entrypoint of your application.

Since in this guide we're aiming first to set up our Next.js as an SPA (Single Page Application), you need your page entrypoint to catch all possible routes of your application. For that, create a new [[...slug]] directory in your app directory.

This directory is what is called an optional catch-all route segment. Next.js uses a file-system based router where folders are used to define routes. This special directory will make sure that all routes of your application will be directed to its containing page.tsx file.

Good to know: .js, .jsx, or .tsx extensions can be used for Page files.

This file is a Server Component. When you run next build, the file is prerendered into a static asset. It does not require any dynamic code.

This file imports our global CSS and tells generateStaticParams we are only going to generate one route, the index route at /.

Now, let's move the rest of our Vite application which will run client-only.

This file is a Client Component, defined by the 'use client' directive. Client Components are still prerendered to HTML on the server before being sent to the client.

Since we want a client-only application to start, we can configure Next.js to disable prerendering from the App component down.

Now, update your entrypoint page to use the new component:

Next.js handles static image imports slightly different from Vite. With Vite, importing an image file will return its public URL as a string:

With Next.js, static image imports return an object. The object can then be used directly with the Next.js <Image> component, or you can use the object's src property with your existing <img> tag.

The <Image> component has the added benefits of automatic image optimization. The <Image> component automatically sets the width and height attributes of the resulting <img> based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled to auto. When not styled to auto, the dimension will default to the <img> dimension attribute's value, which can cause the image to appear distorted.

Keeping the <img> tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the <Image> component to take advantage of optimizing images by configuring a loader, or moving to the default Next.js server which has automatic image optimization.

Alternatively, you can reference the public URL for the image asset based on the filename. For example, public/logo.png will serve the image at /logo.png for your application, which would be the src value.

Warning: If you're using TypeScript, you might encounter type errors when accessing the src property. You can safely ignore those for now. They will be fixed by the end of this guide.

Next.js has support for .env environment variables similar to Vite. The main difference is the prefix used to expose environment variables on the client-side.

Vite exposes a few built-in environment variables on the special import.meta.env object which arenâ€™t supported by Next.js. You need to update their usage as follows:

Next.js also doesn't provide a built-in BASE_URL environment variable. However, you can still configure one, if you need it:

You should now be able to run your application to test if you successfully migrated to Next.js. But before that, you need to update your scripts in your package.json with Next.js related commands, and add .next and next-env.d.ts to your .gitignore:

Now run npm run dev, and open http://localhost:3000. You should see your application now running on Next.js.

Example: Check out this pull request for a working example of a Vite application migrated to Next.js.

You can now clean up your codebase from Vite related artifacts:

If everything went according to plan, you now have a functioning Next.js application running as a single-page application. However, you aren't yet taking advantage of most of Next.js' benefits, but you can now start making incremental changes to reap all the benefits. Here's what you might want to do next:

**Examples:**

Example 1 (unknown):
```unknown
npm install next@latest
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export', // Outputs a Single-Page Application (SPA).
  distDir: './dist', // Changes the build output directory to `./dist/`.
}
 
export default nextConfig
```

Example 3 (unknown):
```unknown
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "allowJs": true,
    "forceConsistentCasingInFileNames": true,
    "incremental": true,
    "plugins": [{ "name": "next" }]
  },
  "include": ["./src", "./dist/types/**/*.ts", "./next-env.d.ts"],
  "exclude": ["./node_modules"]
}
```

Example 4 (unknown):
```unknown
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return '...'
}
```

---

## serverActions

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/serverActions

**Contents:**
- serverActions
- allowedOrigins
- bodySizeLimit
- Enabling Server Actions (v13)

Options for configuring Server Actions behavior in your Next.js application.

A list of extra safe origin domains from which Server Actions can be invoked. Next.js compares the origin of a Server Action request with the host domain, ensuring they match to prevent CSRF attacks. If not provided, only the same origin is allowed.

By default, the maximum size of the request body sent to a Server Action is 1MB, to prevent the consumption of excessive server resources in parsing large amounts of data, as well as potential DDoS attacks.

However, you can configure this limit using the serverActions.bodySizeLimit option. It can take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'.

Server Actions became a stable feature in Next.js 14, and are enabled by default. However, if you are using an earlier version of Next.js, you can enable them by setting experimental.serverActions to true.

**Examples:**

Example 1 (unknown):
```unknown
/** @type {import('next').NextConfig} */
 
module.exports = {
  experimental: {
    serverActions: {
      allowedOrigins: ['my-proxy.com', '*.my-proxy.com'],
    },
  },
}
```

Example 2 (unknown):
```unknown
/** @type {import('next').NextConfig} */
 
module.exports = {
  experimental: {
    serverActions: {
      bodySizeLimit: '2mb',
    },
  },
}
```

Example 3 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const config = {
  experimental: {
    serverActions: true,
  },
}
 
module.exports = config
```

---

## Automatic Static Optimization

**URL:** https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization

**Contents:**
- Automatic Static Optimization
- How it works
- Caveats

Next.js automatically determines that a page is static (can be prerendered) if it has no blocking data requirements. This determination is made by the absence of getServerSideProps and getInitialProps in the page.

This feature allows Next.js to emit hybrid applications that contain both server-rendered and statically generated pages.

Good to know: Statically generated pages are still reactive. Next.js will hydrate your application client-side to give it full interactivity.

One of the main benefits of this feature is that optimized pages require no server-side computation, and can be instantly streamed to the end-user from multiple CDN locations. The result is an ultra fast loading experience for your users.

If getServerSideProps or getInitialProps is present in a page, Next.js will switch to render the page on-demand, per-request (meaning Server-Side Rendering).

If the above is not the case, Next.js will statically optimize your page automatically by prerendering the page to static HTML.

During prerendering, the router's query object will be empty since we do not have query information to provide during this phase. After hydration, Next.js will trigger an update to your application to provide the route parameters in the query object.

The cases where the query will be updated after hydration triggering another render are:

To be able to distinguish if the query is fully updated and ready for use, you can leverage the isReady field on next/router.

Good to know: Parameters added with dynamic routes to a page that's using getStaticProps will always be available inside the query object.

next build will emit .html files for statically optimized pages. For example, the result for the page pages/about.js would be:

And if you add getServerSideProps to the page, it will then be JavaScript, like so:

**Examples:**

Example 1 (unknown):
```unknown
.next/server/pages/about.html
```

Example 2 (unknown):
```unknown
.next/server/pages/about.js
```

---

## httpAgentOptions

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/httpAgentOptions

**Contents:**
- httpAgentOptions

In Node.js versions prior to 18, Next.js automatically polyfills fetch() with undici and enables HTTP Keep-Alive by default.

To disable HTTP Keep-Alive for all fetch() calls on the server-side, open next.config.js and add the httpAgentOptions config:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  httpAgentOptions: {
    keepAlive: false,
  },
}
```

---

## How to optimize memory usage

**URL:** https://nextjs.org/docs/15/app/guides/memory-usage

**Contents:**
- How to optimize memory usage
- Reduce number of dependencies
- Try experimental.webpackMemoryOptimizations
- Run next build with --experimental-debug-memory-usage
- Record a heap profile
- Analyze a snapshot of the heap
- Webpack build worker
- Disable Webpack cache
- Disable static analysis
- Disable source maps

As applications grow and become more feature rich, they can demand more resources when developing locally or creating production builds.

Let's explore some strategies and techniques to optimize memory and address common memory issues in Next.js.

Applications with a large amount of dependencies will use more memory.

The Bundle Analyzer can help you investigate large dependencies in your application that may be able to be removed to improve performance and memory usage.

Starting in v15.0.0, you can add experimental.webpackMemoryOptimizations: true to your next.config.js file to change behavior in Webpack that reduces max memory usage but may increase compilation times by a slight amount.

Good to know: This feature is currently experimental to test on more projects first, but it is considered to be low-risk.

Starting in 14.2.0, you can run next build --experimental-debug-memory-usage to run the build in a mode where Next.js will print out information about memory usage continuously throughout the build, such as heap usage and garbage collection statistics. Heap snapshots will also be taken automatically when memory usage gets close to the configured limit.

Good to know: This feature is not compatible with the Webpack build worker option which is auto-enabled unless you have custom webpack config.

To look for memory issues, you can record a heap profile from Node.js and load it in Chrome DevTools to identify potential sources of memory leaks.

In your terminal, pass the --heap-prof flag to Node.js when starting your Next.js build:

At the end of the build, a .heapprofile file will be created by Node.js.

In Chrome DevTools, you can open the Memory tab and click on the "Load Profile" button to visualize the file.

You can use an inspector tool to analyze the memory usage of the application.

When running the next build or next dev command, add NODE_OPTIONS=--inspect to the beginning of the command. This will expose the inspector agent on the default port. If you wish to break before any user code starts, you can pass --inspect-brk instead. While the process is running, you can use a tool such as Chrome DevTools to connect to the debugging port to record and analyze a snapshot of the heap to see what memory is being retained.

Starting in 14.2.0, you can also run next build with the --experimental-debug-memory-usage flag to make it easier to take heap snapshots.

While running in this mode, you can send a SIGUSR2 signal to the process at any point, and the process will take a heap snapshot.

The heap snapshot will be saved to the project root of the Next.js application and can be loaded in any heap analyzer, such as Chrome DevTools, to see what memory is retained. This mode is not yet compatible with Webpack build workers.

See how to record and analyze heap snapshots for more information.

The Webpack build worker allows you to run Webpack compilations inside a separate Node.js worker which will decrease memory usage of your application during builds.

This option is enabled by default if your application does not have a custom Webpack configuration starting in v14.1.0.

If you are using an older version of Next.js or you have a custom Webpack configuration, you can enable this option by setting experimental.webpackBuildWorker: true inside your next.config.js.

Good to know: This feature may not be compatible with all custom Webpack plugins.

The Webpack cache saves generated Webpack modules in memory and/or to disk to improve the speed of builds. This can help with performance, but it will also increase the memory usage of your application to store the cached data.

You can disable this behavior by adding a custom Webpack configuration to your application:

Typechecking and linting may require a lot of memory, especially in large projects. However, most projects have a dedicated CI runner that already handles these tasks. When the build produces out-of-memory issues during the "Linting and checking validity of types" step, you can disable these task during builds:

Keep in mind that this may produce faulty deploys due to type errors or linting issues. We strongly recommend only promoting builds to production after static analysis has completed. If you deploy to Vercel, you can check out the guide for staging deployments to learn how to promote builds to production after custom tasks have succeeded.

Generating source maps consumes extra memory during the build process.

You can disable source map generation by adding productionBrowserSourceMaps: false and experimental.serverSourceMaps: false to your Next.js configuration.

Good to know: Some plugins may turn on source maps and may require custom configuration to disable.

Next.js v14.1.3 fixed a memory issue when using the Edge runtime. Please update to this version (or later) to see if it addresses your issue.

When the Next.js server starts, it preloads each page's JavaScript modules into memory, rather than at request time.

This optimization allows for faster response times, in exchange for a larger initial memory footprint.

To disable this optimization, set the experimental.preloadEntriesOnStart flag to false.

Next.js doesn't unload these JavaScript modules, meaning that even with this optimization disabled, the memory footprint of your Next.js server will eventually be the same if all pages are eventually requested.

**Examples:**

Example 1 (unknown):
```unknown
node --heap-prof node_modules/next/dist/bin/next build
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  webpack: (
    config,
    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }
  ) => {
    if (config.cache && !dev) {
      config.cache = Object.freeze({
        type: 'memory',
      })
    }
    // Important: return the modified config
    return config
  },
}
 
export default nextConfig
```

Example 3 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    // Warning: This allows production builds to successfully complete even if
    // your project has ESLint errors.
    ignoreDuringBuilds: true,
  },
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}
 
export default nextConfig
```

Example 4 (python):
```python
import type { NextConfig } from 'next'
 
const config: NextConfig = {
  experimental: {
    preloadEntriesOnStart: false,
  },
}
 
export default config
```

---

## cssChunking

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/cssChunking

**Contents:**
- cssChunking
- Options

CSS Chunking is a strategy used to improve the performance of your web application by splitting and re-ordering CSS files into chunks. This allows you to load only the CSS that is needed for a specific route, instead of loading all the application's CSS at once.

You can control how CSS files are chunked using the experimental.cssChunking option in your next.config.js file:

You may consider using 'strict' if you run into unexpected CSS behavior. For example, if you import a.css and b.css in different files using a different import order (a before b, or b before a), true will merge the files in any order and assume there are no dependencies between them. However, if b.css depends on a.css, you may want to use 'strict' to prevent the files from being merged, and instead, load them in the order they are imported - which can result in more chunks and requests.

For most applications, we recommend true as it leads to fewer requests and better performance.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig = {
  experimental: {
    cssChunking: true, // default
  },
} satisfies NextConfig
 
export default nextConfig
```

---

## Dynamic Routes

**URL:** https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes

**Contents:**
- Dynamic Routes
- Convention
- Example
- Catch-all Segments
- Optional Catch-all Segments
- Next Steps
  - Linking and Navigating
  - useRouter

When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.

A Dynamic Segment can be created by wrapping a file or folder name in square brackets: [segmentName]. For example, [id] or [slug].

Dynamic Segments can be accessed from useRouter.

For example, a blog could include the following route pages/blog/[slug].js where [slug] is the Dynamic Segment for blog posts.

Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...segmentName].

For example, pages/shop/[...slug].js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-shirts, and so on.

Catch-all Segments can be made optional by including the parameter in double square brackets: [[...segmentName]].

For example, pages/shop/[[...slug]].js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts.

The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also matched (/shop in the example above).

**Examples:**

Example 1 (python):
```python
import { useRouter } from 'next/router'
 
export default function Page() {
  const router = useRouter()
  return <p>Post: {router.query.slug}</p>
}
```

---

## serverExternalPackages

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js/serverExternalPackages

**Contents:**
- serverExternalPackages

Opt-out specific dependencies from being included in the automatic bundling of the bundlePagesRouterDependencies option.

These pages will then use native Node.js require to resolve the dependency.

Next.js includes a short list of popular packages that currently are working on compatibility and automatically opt-ed out:

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  serverExternalPackages: ['@acme/ui'],
}
 
module.exports = nextConfig
```

---

## Data Fetching

**URL:** https://nextjs.org/docs/pages/building-your-application/data-fetching

**Contents:**
- Data Fetching
- Examples
  - getStaticProps
  - getStaticPaths
  - Forms and Mutations
  - getServerSideProps
  - Client-side Fetching

Data fetching in Next.js allows you to render your content in different ways, depending on your application's use case. These include pre-rendering with Server-side Rendering or Static Generation, and updating or creating content at runtime with Incremental Static Regeneration.

---

## Tailwind CSS

**URL:** https://nextjs.org/docs/pages/guides/tailwind-v3-css

**Contents:**
- Tailwind CSS
- Installing Tailwind v3
- Configuring Tailwind v3
- Using classes
- Usage with Turbopack

This guide will walk you through how to install Tailwind CSS v3 in your Next.js application.

Good to know: For the latest Tailwind 4 setup, see the Tailwind CSS setup instructions.

Install Tailwind CSS and its peer dependencies, then run the init command to generate both tailwind.config.js and postcss.config.js files:

Configure your template paths in your tailwind.config.js file:

Add the Tailwind directives to your global CSS file:

Import the CSS file in your pages/_app.js file:

After installing Tailwind CSS and adding the global styles, you can use Tailwind's utility classes in your application.

As of Next.js 13.1, Tailwind CSS and PostCSS are supported with Turbopack.

**Examples:**

Example 1 (unknown):
```unknown
pnpm add -D tailwindcss@^3 postcss autoprefixer
npx tailwindcss init -p
```

Example 2 (unknown):
```unknown
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

Example 3 (unknown):
```unknown
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Example 4 (unknown):
```unknown
import '@/styles/globals.css'
 
export default function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />
}
```

---

## How to handle redirects in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/redirecting

**Contents:**
- How to handle redirects in Next.js
- redirect function
- permanentRedirect function
- useRouter() hook
- redirects in next.config.js
- NextResponse.redirect in Middleware
- Managing redirects at scale (advanced)
  - 1. Creating and storing a redirect map
  - 2. Optimizing data lookup performance
- Next Steps

There are a few ways you can handle redirects in Next.js. This page will go through each available option, use cases, and how to manage large numbers of redirects.

The redirect function allows you to redirect the user to another URL. You can call redirect in Server Components, Route Handlers, and Server Actions.

redirect is often used after a mutation or event. For example, creating a post:

See the redirect API reference for more information.

The permanentRedirect function allows you to permanently redirect the user to another URL. You can call permanentRedirect in Server Components, Route Handlers, and Server Actions.

permanentRedirect is often used after a mutation or event that changes an entity's canonical URL, such as updating a user's profile URL after they change their username:

See the permanentRedirect API reference for more information.

If you need to redirect inside an event handler in a Client Component, you can use the push method from the useRouter hook. For example:

See the useRouter API reference for more information.

The redirects option in the next.config.js file allows you to redirect an incoming request path to a different destination path. This is useful when you change the URL structure of pages or have a list of redirects that are known ahead of time.

redirects supports path, header, cookie, and query matching, giving you the flexibility to redirect users based on an incoming request.

To use redirects, add the option to your next.config.js file:

See the redirects API reference for more information.

Middleware allows you to run code before a request is completed. Then, based on the incoming request, redirect to a different URL using NextResponse.redirect. This is useful if you want to redirect users based on a condition (e.g. authentication, session management, etc) or have a large number of redirects.

For example, to redirect the user to a /login page if they are not authenticated:

See the Middleware documentation for more information.

To manage a large number of redirects (1000+), you may consider creating a custom solution using Middleware. This allows you to handle redirects programmatically without having to redeploy your application.

To do this, you'll need to consider:

Next.js Example: See our Middleware with Bloom filter example for an implementation of the recommendations below.

A redirect map is a list of redirects that you can store in a database (usually a key-value store) or JSON file.

Consider the following data structure:

In Middleware, you can read from a database such as Vercel's Edge Config or Redis, and redirect the user based on the incoming request:

Reading a large dataset for every incoming request can be slow and expensive. There are two ways you can optimize data lookup performance:

Considering the previous example, you can import a generated bloom filter file into Middleware, then, check if the incoming request pathname exists in the bloom filter.

If it does, forward the request to a Route Handler which will check the actual file and redirect the user to the appropriate URL. This avoids importing a large redirects file into Middleware, which can slow down every incoming request.

Then, in the Route Handler:

**Examples:**

Example 1 (python):
```python
'use server'
 
import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'
 
export async function createPost(id: string) {
  try {
    // Call database
  } catch (error) {
    // Handle errors
  }
 
  revalidatePath('/posts') // Update cached posts
  redirect(`/post/${id}`) // Navigate to the new post page
}
```

Example 2 (python):
```python
'use server'
 
import { permanentRedirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'
 
export async function updateUsername(username: string, formData: FormData) {
  try {
    // Call database
  } catch (error) {
    // Handle errors
  }
 
  revalidateTag('username') // Update all references to the username
  permanentRedirect(`/profile/${username}`) // Navigate to the new user profile
}
```

Example 3 (python):
```python
'use client'
 
import { useRouter } from 'next/navigation'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

Example 4 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  async redirects() {
    return [
      // Basic redirect
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
      // Wildcard path matching
      {
        source: '/blog/:slug',
        destination: '/news/:slug',
        permanent: true,
      },
    ]
  },
}
 
export default nextConfig
```

---

## Edge Runtime

**URL:** https://nextjs.org/docs/pages/api-reference/edge

**Contents:**
- Edge Runtime
- Caveats
- Reference
  - Network APIs
  - Encoding APIs
  - Stream APIs
  - Crypto APIs
  - Web Standard APIs
  - Next.js Specific Polyfills
  - Environment Variables

Next.js has two server runtimes you can use in your application:

The Edge Runtime supports the following APIs:

You can use process.env to access Environment Variables for both next dev and next build.

The Edge Runtime has some restrictions including:

The following JavaScript language features are disabled, and will not work:

In rare cases, your code could contain (or import) some dynamic code evaluation statements which can not be reached at runtime and which can not be removed by treeshaking. You can relax the check to allow specific files with your Proxy configuration:

unstable_allowDynamic is a glob, or an array of globs, ignoring dynamic code evaluation for specific files. The globs are relative to your application root folder.

Be warned that if these statements are executed on the Edge, they will throw and cause a runtime error.

**Examples:**

Example 1 (javascript):
```javascript
export const config = {
  unstable_allowDynamic: [
    // allows a single file
    '/lib/utilities.js',
    // use a glob to allow anything in the function-bind 3rd party module
    '**/node_modules/function-bind/**',
  ],
}
```

---

## How to set up Cypress with Next.js

**URL:** https://nextjs.org/docs/pages/guides/testing/cypress

**Contents:**
- How to set up Cypress with Next.js
- Manual setup
- Creating your first Cypress E2E test
  - Running E2E Tests
- Creating your first Cypress component test
  - Running Component Tests
- Continuous Integration (CI)

Cypress is a test runner used for End-to-End (E2E) and Component Testing. This page will show you how to set up Cypress with Next.js and write your first tests.

To manually set up Cypress, install cypress as a dev dependency:

Add the Cypress open command to the package.json scripts field:

Run Cypress for the first time to open the Cypress testing suite:

You can choose to configure E2E Testing and/or Component Testing. Selecting any of these options will automatically create a cypress.config.js file and a cypress folder in your project.

Ensure your cypress.config file has the following configuration:

Then, create two new Next.js files:

Add a test to check your navigation is working correctly:

Cypress will simulate a user navigating your application, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave.

Run npm run build && npm run start to build your Next.js application, then run npm run cypress:open in another terminal window to start Cypress and run your E2E Testing suite.

Component tests build and mount a specific component without having to bundle your whole application or start a server.

Select Component Testing in the Cypress app, then select Next.js as your front-end framework. A cypress/component folder will be created in your project, and a cypress.config.js file will be updated to enable Component Testing.

Ensure your cypress.config file has the following configuration:

Assuming the same components from the previous section, add a test to validate a component is rendering the expected output:

Run npm run cypress:open in your terminal to start Cypress and run your Component Testing suite.

In addition to interactive testing, you can also run Cypress headlessly using the cypress run command, which is better suited for CI environments:

You can learn more about Cypress and Continuous Integration from these resources:

**Examples:**

Example 1 (unknown):
```unknown
npm install -D cypress
# or
yarn add -D cypress
# or
pnpm install -D cypress
```

Example 2 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "cypress:open": "cypress open"
  }
}
```

Example 3 (unknown):
```unknown
npm run cypress:open
```

Example 4 (python):
```python
import { defineConfig } from 'cypress'
 
export default defineConfig({
  e2e: {
    setupNodeEvents(on, config) {},
  },
})
```

---

## How to use debugging tools with Next.js

**URL:** https://nextjs.org/docs/pages/guides/debugging

**Contents:**
- How to use debugging tools with Next.js
- Debugging with VS Code
- Using the Debugger in Jetbrains WebStorm
- Debugging with Browser DevTools
  - Client-side code
  - React Developer Tools
  - Server-side code
  - Inspect Server Errors with Browser DevTools
  - Debugging on Windows
- More information

This documentation explains how you can debug your Next.js frontend and backend code with full source maps support using the VS Code debugger, Chrome DevTools, or Firefox DevTools.

Any debugger that can attach to Node.js can also be used to debug a Next.js application. You can find more details in the Node.js Debugging Guide.

Create a file named .vscode/launch.json at the root of your project with the following content:

Note: To use Firefox debugging in VS Code, you'll need to install the Firefox Debugger extension.

npm run dev can be replaced with yarn dev if you're using Yarn or pnpm dev if you're using pnpm.

In the "Next.js: debug full stack" configuration, serverReadyAction.action specifies which browser to open when the server is ready. debugWithEdge means to launch the Edge browser. If you are using Chrome, change this value to debugWithChrome.

If you're changing the port number your application starts on, replace the 3000 in http://localhost:3000 with the port you're using instead.

If you're running Next.js from a directory other than root (for example, if you're using Turborepo) then you need to add cwd to the server-side and full stack debugging tasks. For example, "cwd": "${workspaceFolder}/apps/web".

Now go to the Debug panel (Ctrl+Shift+D on Windows/Linux, â‡§+âŒ˜+D on macOS), select a launch configuration, then press F5 or select Debug: Start Debugging from the Command Palette to start your debugging session.

Click the drop down menu listing the runtime configuration, and click Edit Configurations.... Create a JavaScript Debug debug configuration with http://localhost:3000 as the URL. Customize to your liking (e.g. Browser for debugging, store as project file), and click OK. Run this debug configuration, and the selected browser should automatically open. At this point, you should have 2 applications in debug mode: the NextJS node application, and the client/browser application.

Start your development server as usual by running next dev, npm run dev, or yarn dev. Once the server starts, open http://localhost:3000 (or your alternate URL) in your preferred browser.

In either browser, any time your client-side code reaches a debugger statement, code execution will pause and that file will appear in the debug area. You can also search for files to set breakpoints manually:

Note that when searching, your source files will have paths starting with webpack://_N_E/./.

For React-specific debugging, install the React Developer Tools browser extension. This essential tool helps you:

To debug server-side Next.js code with browser DevTools, you need to pass the --inspect flag:

The value of --inspect is passed to the underlying Node.js process. Check out the --inspect docs for advanced use cases.

Good to know: Use --inspect=0.0.0.0 to allow remote debugging access outside localhost, such as when running the app in a Docker container.

Launching the Next.js dev server with the --inspect flag will look something like this:

Debugging server-side code works similarly to client-side debugging. When searching for files (Ctrl+P/âŒ˜+P), your source files will have paths starting with webpack://{application-name}/./ (where {application-name} will be replaced with the name of your application according to your package.json file).

To use --inspect-brk or --inspect-wait, you have to specify NODE_OPTIONS instead. e.g. NODE_OPTIONS=--inspect-brk next dev.

When you encounter an error, inspecting the source code can help trace the root cause of errors.

Next.js will display a Node.js icon underneath the Next.js version indicator on the error overlay. By clicking that icon, the DevTools URL is copied to your clipboard. You can open a new browser tab with that URL to inspect the Next.js server process.

Ensure Windows Defender is disabled on your machine. This external service will check every file read, which has been reported to greatly increase Fast Refresh time with next dev. This is a known issue, not related to Next.js, but it does affect Next.js development.

To learn more about how to use a JavaScript debugger, take a look at the following documentation:

**Examples:**

Example 1 (unknown):
```unknown
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Next.js: debug server-side",
      "type": "node-terminal",
      "request": "launch",
      "command": "npm run dev -- --inspect"
    },
    {
      "name": "Next.js: debug client-side",
      "type": "chrome",
      "request": "launch",
      "url": "http://localhost:3000"
    },
    {
      "name": "Next.js: debug client-side (Firefox)",
      "type": "firefox",
      "request": "launch",
      "url": "http://localhost:3000",
      "reAttach": true,
      "pathMappings": [
        {
          "url": "webpack://_N_E",
          "path": "${workspaceFolder}"
        }
      ]
    },
    {
      "name": "Next.js: debug full stack",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/node_modules/next/dist/bin/next",
      "runtimeArgs": ["--inspect"],
      "skipFiles": ["<node_internals>/**"],
      "serverReadyAction": {
        "action": "debugWithEdge",
        "killOnServerStop": true,
        "pattern": "- Local:.+(https?://.+)",
        "uriFormat": "%s",
        "webRoot": "${workspaceFolder}"
      }
    }
  ]
}
```

Example 2 (unknown):
```unknown
next dev --inspect
```

Example 3 (unknown):
```unknown
Debugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95
For help, see: https://nodejs.org/en/docs/inspector
ready - started server on 0.0.0.0:3000, url: http://localhost:3000
```

---

## isolatedDevBuild

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/isolatedDevBuild

**Contents:**
- isolatedDevBuild
- Configuration
- Version History

The experimental isolatedDevBuild option separates development and production build outputs into different directories. When enabled, the development server (next dev) writes its output to .next/dev instead of .next, preventing conflicts when running next dev and next build concurrently.

This is especially helpful when automated tools (for example, AI agents) run next build to validate changes while your development server is running, ensuring the dev server is not affected by changes made by the build process.

This feature is enabled by default to keep development and production outputs separate and prevent conflicts.

To opt out of this feature, set isolatedDevBuild to false in your configuration:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    isolatedDevBuild: false, // defaults to true
  },
}
 
export default nextConfig
```

---

## forbidden.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/forbidden

**Contents:**
- forbidden.js
- Reference
  - Props
- Version History
- Next Steps
  - forbidden

The forbidden file is used to render UI when the forbidden function is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 403 status code.

forbidden.js components do not accept any props.

**Examples:**

Example 1 (python):
```python
import Link from 'next/link'
 
export default function Forbidden() {
  return (
    <div>
      <h2>Forbidden</h2>
      <p>You are not authorized to access this resource.</p>
      <Link href="/">Return Home</Link>
    </div>
  )
}
```

---

## Configuration

**URL:** https://nextjs.org/docs/app/api-reference/config

**Contents:**
- Configuration
  - next.config.js
  - TypeScript
  - ESLint

---

## How to implement Incremental Static Regeneration (ISR)

**URL:** https://nextjs.org/docs/app/guides/incremental-static-regeneration

**Contents:**
- How to implement Incremental Static Regeneration (ISR)
- Reference
  - Route segment config
  - Functions
- Examples
  - Time-based revalidation
  - On-demand revalidation with revalidatePath
  - On-demand revalidation with revalidateTag
  - Handling uncaught exceptions
  - Customizing the cache location

Incremental Static Regeneration (ISR) enables you to:

Here's a minimal example:

Here's how this example works:

This fetches and displays a list of blog posts on /blog. After an hour has passed, the next visitor will still receive the cached (stale) version of the page immediately for a fast response. Simultaneously, Next.js triggers regeneration of a fresh version in the background. Once the new version is successfully generated, it replaces the cached version, and subsequent visitors will receive the updated content.

We recommend setting a high revalidation time. For instance, 1 hour instead of 1 second. If you need more precision, consider using on-demand revalidation. If you need real-time data, consider switching to dynamic rendering.

For a more precise method of revalidation, invalidate cached pages on-demand with the revalidatePath function.

For example, this Server Action would get called after adding a new post. Regardless of how you retrieve your data in your Server Component, either using fetch or connecting to a database, this will invalidate the cache for the entire route. The next request to that route will trigger regeneration and serve fresh data, which will then be cached for subsequent requests.

Note: revalidatePath invalidates the cache entries but regeneration happens on the next request. If you want to eagerly regenerate the cache entry immediately instead of waiting for the next request, you can use the Pages router res.revalidate method. We're working on adding new methods to provide eager regeneration capabilities for the App Router.

View a demo and explore the source code.

For most use cases, prefer revalidating entire paths. If you need more granular control, you can use the revalidateTag function. For example, you can tag individual fetch calls:

If you are using an ORM or connecting to a database, you can use unstable_cache:

You can then use revalidateTag in a Server Actions or Route Handler:

If an error is thrown while attempting to revalidate data, the last successfully generated data will continue to be served from the cache. On the next subsequent request, Next.js will retry revalidating the data. Learn more about error handling.

You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application. Learn more.

If you are using the fetch API, you can add additional logging to understand which requests are cached or uncached. Learn more about the logging option.

To verify your pages are cached and revalidated correctly in production, you can test locally by running next build and then next start to run the production Next.js server.

This will allow you to test ISR behavior as it would work in a production environment. For further debugging, add the following environment variable to your .env file:

This will make the Next.js server console log ISR cache hits and misses. You can inspect the output to see which pages are generated during next build, as well as how pages are updated as paths are accessed on-demand.

Learn how to configure ISR when self-hosting Next.js.

**Examples:**

Example 1 (javascript):
```javascript
interface Post {
  id: string
  title: string
  content: string
}
 
// Next.js will invalidate the cache when a
// request comes in, at most once every 60 seconds.
export const revalidate = 60
 
export async function generateStaticParams() {
  const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  return posts.map((post) => ({
    id: String(post.id),
  }))
}
 
export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post: Post = await fetch(`https://api.vercel.app/blog/${id}`).then(
    (res) => res.json()
  )
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

Example 2 (javascript):
```javascript
interface Post {
  id: string
  title: string
  content: string
}
 
export const revalidate = 3600 // invalidate every hour
 
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts: Post[] = await data.json()
  return (
    <main>
      <h1>Blog Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  )
}
```

Example 3 (python):
```python
'use server'
 
import { revalidatePath } from 'next/cache'
 
export async function createPost() {
  // Invalidate the cache for the /posts route
  revalidatePath('/posts')
}
```

Example 4 (javascript):
```javascript
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog', {
    next: { tags: ['posts'] },
  })
  const posts = await data.json()
  // ...
}
```

---

## unauthorized.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized

**Contents:**
- unauthorized.js
- Reference
  - Props
- Examples
  - Displaying login UI to unauthenticated users
- Version History
- Next Steps
  - unauthorized

The unauthorized file is used to render UI when the unauthorized function is invoked during authentication. Along with allowing you to customize the UI, Next.js will return a 401 status code.

unauthorized.js components do not accept any props.

You can use unauthorized function to render the unauthorized.js file with a login UI.

**Examples:**

Example 1 (python):
```python
import Login from '@/app/components/Login'
 
export default function Unauthorized() {
  return (
    <main>
      <h1>401 - Unauthorized</h1>
      <p>Please log in to access this page.</p>
      <Login />
    </main>
  )
}
```

Example 2 (python):
```python
import { verifySession } from '@/app/lib/dal'
import { unauthorized } from 'next/navigation'
 
export default async function DashboardPage() {
  const session = await verifySession()
 
  if (!session) {
    unauthorized()
  }
 
  return <div>Dashboard</div>
}
```

Example 3 (python):
```python
import Login from '@/app/components/Login'
 
export default function UnauthorizedPage() {
  return (
    <main>
      <h1>401 - Unauthorized</h1>
      <p>Please log in to access this page.</p>
      <Login />
    </main>
  )
}
```

---

## TypeScript

**URL:** https://nextjs.org/docs/app/api-reference/config/typescript

**Contents:**
- TypeScript
- IDE Plugin
- End-to-End Type Safety
- Route-Aware Type Helpers
- Examples
  - Type Checking Next.js Configuration Files
  - Using Node.js Native TypeScript Resolver for next.config.ts
    - For CommonJS Projects (Default)
    - For ESM Projects
  - Statically Typed Links

Next.js comes with built-in TypeScript, automatically installing the necessary packages and configuring the proper settings when you create a new project with create-next-app.

To add TypeScript to an existing project, rename a file to .ts / .tsx. Run next dev and next build to automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options.

Good to know: If you already have a jsconfig.json file, copy the paths compiler option from the old jsconfig.json into the new tsconfig.json file, and delete the old jsconfig.json file.

Next.js includes a custom TypeScript plugin and type checker, which VSCode and other code editors can use for advanced type-checking and auto-completion.

You can enable the plugin in VS Code by:

Now, when editing files, the custom plugin will be enabled. When running next build, the custom type checker will be used.

The TypeScript plugin can help with:

ðŸŽ¥ Watch: Learn about the built-in TypeScript plugin â†’ YouTube (3 minutes)

The Next.js App Router has enhanced type safety. This includes:

Data Fetching in Next.js now provides as close to end-to-end type safety as possible without being prescriptive about your database or content provider selection.

We're able to type the response data as you would expect with normal TypeScript. For example:

For complete end-to-end type safety, this also requires your database or content provider to support TypeScript. This could be through using an ORM or type-safe query builder.

Next.js generates global helpers for App Router route types. These are available without imports and are generated during next dev, next build, or via next typegen:

You can use TypeScript and import types in your Next.js configuration by using next.config.ts.

Module resolution in next.config.ts is currently limited to CommonJS. However, ECMAScript Modules (ESM) syntax is available when using Node.js native TypeScript resolver for Node.js v22.10.0 and higher.

When using the next.config.js file, you can add some type checking in your IDE using JSDoc as below:

Note: Available on Node.js v22.10.0+ and only when the feature is enabled. Next.js does not enable it.

Next.js detects the Node.js native TypeScript resolver via process.features.typescript, added in v22.10.0. When present, next.config.ts can use native ESM, including topâ€‘level await and dynamic import(). This mechanism inherits the capabilities and limitations of Node's resolver.

In Node.js versions v22.18.0+, process.features.typescript is enabled by default. For versions between v22.10.0 and 22.17.x, opt in with NODE_OPTIONS=--experimental-transform-types:

Although next.config.ts supports native ESM syntax on CommonJS projects, Node.js will still assume next.config.ts is a CommonJS file by default, resulting in Node.js reparsing the file as ESM when module syntax is detected. Therefore, we recommend using the next.config.mts file for CommonJS projects to explicitly indicate it's an ESM module:

When "type" is set to "module" in package.json, your project uses ESM. Learn more about this setting in the Node.js docs. In this case, you can write next.config.ts directly with ESM syntax.

Good to know: When using "type": "module" in your package.json, all .js and .ts files in your project are treated as ESM modules by default. You may need to rename files with CommonJS syntax to .cjs or .cts extensions if needed.

Next.js can statically type links to prevent typos and other errors when using next/link, improving type safety when navigating between pages.

Works in both the Pages and App Router for the href prop in next/link. In the App Router, it also types next/navigation methods like push, replace, and prefetch. It does not type next/router methods in Pages Router.

Literal href strings are validated, while non-literal hrefs may require a cast with as Route.

To opt-into this feature, typedRoutes need to be enabled and the project needs to be using TypeScript.

Next.js will generate a link definition in .next/types that contains information about all existing routes in your application, which TypeScript can then use to provide feedback in your editor about invalid links.

Good to know: If you set up your project without create-next-app, ensure the generated Next.js types are included by adding .next/types/**/*.ts to the include array in your tsconfig.json:

Currently, support includes any string literal, including dynamic segments. For non-literal strings, you need to manually cast with as Route. The example below shows both next/link and next/navigation usage:

The same applies for redirecting routes defined by proxy:

To accept href in a custom component wrapping next/link, use a generic:

You can also type a simple data structure and iterate to render links:

Then, map over the items to render Links:

When running next dev or next build, Next.js generates a hidden .d.ts file inside .next that contains information about all existing routes in your application (all valid routes as the href type of Link). This .d.ts file is included in tsconfig.json and the TypeScript compiler will check that .d.ts and provide feedback in your editor about invalid links.

During development, Next.js generates a .d.ts file in .next/types that contains information about the loaded environment variables for your editor's IntelliSense. If the same environment variable key is defined in multiple files, it is deduplicated according to the Environment Variable Load Order.

To opt-into this feature, experimental.typedEnv needs to be enabled and the project needs to be using TypeScript.

Good to know: Types are generated based on the environment variables loaded at development runtime, which excludes variables from .env.production* files by default. To include production-specific variables, run next dev with NODE_ENV=production.

To use an async Server Component with TypeScript, ensure you are using TypeScript 5.1.3 or higher and @types/react 18.2.8 or higher.

If you are using an older version of TypeScript, you may see a 'Promise<Element>' is not a valid JSX element type error. Updating to the latest version of TypeScript and @types/react should resolve this issue.

Since v10.2.1 Next.js supports incremental type checking when enabled in your tsconfig.json, this can help speed up type checking in larger applications.

In some cases, you might want to use a different TypeScript configuration for builds or tooling. To do that, set typescript.tsconfigPath in next.config.ts to point Next.js to another tsconfig file.

For example, switch to a different config for production builds:

You might need to relax checks in scenarios like monorepos, where the build also validates shared dependencies that don't match your project's standards, or when loosening checks in CI to continue delivering while migrating locally to stricter TypeScript settings (and still wanting your IDE to highlight misuse).

For example, if your project uses useUnknownInCatchVariables but some monorepo dependencies still assume any:

This keeps your editor strict via tsconfig.json while allowing the production build to use relaxed settings.

Next.js fails your production build (next build) when TypeScript errors are present in your project.

If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step.

If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.

Open next.config.ts and enable the ignoreBuildErrors option in the typescript config:

Good to know: You can run tsc --noEmit to check for TypeScript errors yourself before building. This is useful for CI/CD pipelines where you'd like to check for TypeScript errors before deploying.

When you need to declare custom types, you might be tempted to modify next-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call it new-types.d.ts, and reference it in your tsconfig.json:

**Examples:**

Example 1 (javascript):
```javascript
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.
  return res.json()
}
 
export default async function Page() {
  const name = await getData()
 
  return '...'
}
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  /* config options here */
}
 
export default nextConfig
```

Example 3 (javascript):
```javascript
// @ts-check
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
}
 
module.exports = nextConfig
```

Example 4 (unknown):
```unknown
NODE_OPTIONS=--experimental-transform-types next <command>
```

---

## webVitalsAttribution

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/webVitalsAttribution

**Contents:**
- webVitalsAttribution

When debugging issues related to Web Vitals, it is often helpful if we can pinpoint the source of the problem. For example, in the case of Cumulative Layout Shift (CLS), we might want to know the first element that shifted when the single largest layout shift occurred. Or, in the case of Largest Contentful Paint (LCP), we might want to identify the element corresponding to the LCP for the page. If the LCP element is an image, knowing the URL of the image resource can help us locate the asset we need to optimize.

Pinpointing the biggest contributor to the Web Vitals score, aka attribution, allows us to obtain more in-depth information like entries for PerformanceEventTiming, PerformanceNavigationTiming and PerformanceResourceTiming.

Attribution is disabled by default in Next.js but can be enabled per metric by specifying the following in next.config.js.

Valid attribution values are all web-vitals metrics specified in the NextWebVitalsMetric type.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  experimental: {
    webVitalsAttribution: ['CLS', 'LCP'],
  },
}
```

---

## env

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/env

**Contents:**
- env

Since the release of Next.js 9.4 we now have a more intuitive and ergonomic experience for adding environment variables. Give it a try!

Good to know: environment variables specified in this way will always be included in the JavaScript bundle, prefixing the environment variable name with NEXT_PUBLIC_ only has an effect when specifying them through the environment or .env files.

To add environment variables to the JavaScript bundle, open next.config.js and add the env config:

Now you can access process.env.customKey in your code. For example:

Next.js will replace process.env.customKey with 'my-value' at build time. Trying to destructure process.env variables won't work due to the nature of webpack DefinePlugin.

For example, the following line:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  env: {
    customKey: 'my-value',
  },
}
```

Example 2 (unknown):
```unknown
function Page() {
  return <h1>The value of customKey is: {process.env.customKey}</h1>
}
 
export default Page
```

Example 3 (unknown):
```unknown
return <h1>The value of customKey is: {process.env.customKey}</h1>
```

Example 4 (unknown):
```unknown
return <h1>The value of customKey is: {'my-value'}</h1>
```

---

## How to use Sass in Next.js

**URL:** https://nextjs.org/docs/pages/guides/sass

**Contents:**
- How to use Sass in Next.js
  - Customizing Sass Options
    - Implementation
  - Sass Variables

Next.js has built-in support for integrating with Sass after the package is installed using both the .scss and .sass extensions. You can use component-level Sass via CSS Modules and the .module.scssor .module.sass extension.

Sass supports two different syntaxes, each with their own extension. The .scss extension requires you use the SCSS syntax, while the .sass extension requires you use the Indented Syntax ("Sass").

If you're not sure which to choose, start with the .scss extension which is a superset of CSS, and doesn't require you learn the Indented Syntax ("Sass").

If you want to configure your Sass options, use sassOptions in next.config.

You can use the implementation property to specify the Sass implementation to use. By default, Next.js uses the sass package.

Next.js supports Sass variables exported from CSS Module files.

For example, using the exported primaryColor Sass variable:

**Examples:**

Example 1 (unknown):
```unknown
npm install --save-dev sass
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  sassOptions: {
    additionalData: `$var: red;`,
  },
}
 
export default nextConfig
```

Example 3 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  sassOptions: {
    implementation: 'sass-embedded',
  },
}
 
export default nextConfig
```

Example 4 (unknown):
```unknown
$primary-color: #64ff00;
 
:export {
  primaryColor: $primary-color;
}
```

---

## Pages Router

**URL:** https://nextjs.org/docs/15/pages

**Contents:**
- Pages Router
  - Getting Started
  - Guides
  - Building Your Application
  - API Reference

You're viewing the documentation for the Pages Router. See the App Router documentation for the latest features.

The Pages Router uses an intuitive file-system router to map each file to a route.

Before Next.js 13, the Pages Router was the main way to create routes in Next.js. It's still supported in newer versions of Next.js, but we recommend migrating to the new App Router to leverage React's latest features.

---

## refresh

**URL:** https://nextjs.org/docs/app/api-reference/functions/refresh

**Contents:**
- refresh
- Usage
- Parameters
- Returns
- Examples
  - Error when used outside Server Actions

refresh allows you to refresh the client router from within a Server Action.

refresh can only be called from within Server Actions. It cannot be used in Route Handlers, Client Components, or any other context.

refresh does not return a value.

**Examples:**

Example 1 (unknown):
```unknown
refresh(): void;
```

Example 2 (python):
```python
'use server'
 
import { refresh } from 'next/cache'
 
export async function createPost(formData: FormData) {
  const title = formData.get('title')
  const content = formData.get('content')
 
  // Create the post in your database
  const post = await db.post.create({
    data: { title, content },
  })
 
  refresh()
}
```

Example 3 (python):
```python
import { refresh } from 'next/cache'
 
export async function POST() {
  // This will throw an error
  refresh()
}
```

---

## userAgent

**URL:** https://nextjs.org/docs/pages/api-reference/functions/userAgent

**Contents:**
- userAgent
- isBot
- browser
- device
- engine
- os
- cpu

The userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.

A boolean indicating whether the request comes from a known bot.

An object containing information about the browser used in the request.

An object containing information about the device used in the request.

An object containing information about the browser's engine.

An object containing information about the operating system.

An object containing information about the CPU architecture.

**Examples:**

Example 1 (python):
```python
import { NextRequest, NextResponse, userAgent } from 'next/server'
 
export function proxy(request: NextRequest) {
  const url = request.nextUrl
  const { device } = userAgent(request)
 
  // device.type can be: 'mobile', 'tablet', 'console', 'smarttv',
  // 'wearable', 'embedded', or undefined (for desktop browsers)
  const viewport = device.type || 'desktop'
 
  url.searchParams.set('viewport', viewport)
  return NextResponse.rewrite(url)
}
```

---

## How to preview content with Draft Mode in Next.js

**URL:** https://nextjs.org/docs/app/guides/draft-mode

**Contents:**
- How to preview content with Draft Mode in Next.js
- Step 1: Create a Route Handler
- Step 2: Access the Route Handler from your Headless CMS
- Step 3: Preview the Draft Content
- Next Steps
  - draftMode

Draft Mode allows you to preview draft content from your headless CMS in your Next.js application. This is useful for static pages that are generated at build time as it allows you to switch to dynamic rendering and see the draft changes without having to rebuild your entire site.

This page walks through how to enable and use Draft Mode.

Create a Route Handler. It can have any name, for example, app/api/draft/route.ts.

Then, import the draftMode function and call the enable() method.

This will set a cookie to enable draft mode. Subsequent requests containing this cookie will trigger draft mode and change the behavior of statically generated pages.

You can test this manually by visiting /api/draft and looking at your browserâ€™s developer tools. Notice the Set-Cookie response header with a cookie named __prerender_bypass.

These steps assume that the headless CMS youâ€™re using supports setting custom draft URLs. If it doesnâ€™t, you can still use this method to secure your draft URLs, but youâ€™ll need to construct and access the draft URL manually. The specific steps will vary depending on which headless CMS youâ€™re using.

To securely access the Route Handler from your headless CMS:

Your headless CMS might allow you to include a variable in the draft URL so that <path> can be set dynamically based on the CMSâ€™s data like so: &slug=/posts/{entry.fields.slug}

If it succeeds, then the browser will be redirected to the path you want to view with the draft mode cookie.

The next step is to update your page to check the value of draftMode().isEnabled.

If you request a page which has the cookie set, then data will be fetched at request time (instead of at build time).

Furthermore, the value of isEnabled will be true.

If you access the draft Route Handler (with secret and slug) from your headless CMS or manually using the URL, you should now be able to see the draft content. And, if you update your draft without publishing, you should be able to view the draft.

**Examples:**

Example 1 (unknown):
```unknown
export async function GET(request: Request) {
  return new Response('')
}
```

Example 2 (python):
```python
import { draftMode } from 'next/headers'
 
export async function GET(request: Request) {
  const draft = await draftMode()
  draft.enable()
  return new Response('Draft mode is enabled')
}
```

Example 3 (unknown):
```unknown
https://<your-site>/api/draft?secret=<token>&slug=<path>
```

Example 4 (python):
```python
import { draftMode } from 'next/headers'
import { redirect } from 'next/navigation'
 
export async function GET(request: Request) {
  // Parse query string parameters
  const { searchParams } = new URL(request.url)
  const secret = searchParams.get('secret')
  const slug = searchParams.get('slug')
 
  // Check the secret and next parameters
  // This secret should only be known to this Route Handler and the CMS
  if (secret !== 'MY_SECRET_TOKEN' || !slug) {
    return new Response('Invalid token', { status: 401 })
  }
 
  // Fetch the headless CMS to check if the provided `slug` exists
  // getPostBySlug would implement the required fetching logic to the headless CMS
  const post = await getPostBySlug(slug)
 
  // If the slug doesn't exist prevent draft mode from being enabled
  if (!post) {
    return new Response('Invalid slug', { status: 401 })
  }
 
  // Enable Draft Mode by setting the cookie
  const draft = await draftMode()
  draft.enable()
 
  // Redirect to the path from the fetched post
  // We don't redirect to searchParams.slug as that might lead to open redirect vulnerabilities
  redirect(post.slug)
}
```

---

## bundlePagesRouterDependencies

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js/bundlePagesRouterDependencies

**Contents:**
- bundlePagesRouterDependencies
- Version History

Enable automatic server-side dependency bundling for Pages Router applications. Matches the automatic dependency bundling in App Router.

Explicitly opt-out certain packages from being bundled using the serverExternalPackages option.

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  bundlePagesRouterDependencies: true,
}
 
module.exports = nextConfig
```

---

## ESLint Plugin

**URL:** https://nextjs.org/docs/app/api-reference/config/eslint

**Contents:**
- ESLint Plugin
- Setup ESLint
- Reference
  - Rules
- Examples
  - Specifying a root directory within a monorepo
  - Disabling rules
  - With Core Web Vitals
  - With TypeScript
  - With Prettier

Next.js provides an ESLint plugin, @next/eslint-plugin-next, already bundled within the base configuration that makes it possible to catch common issues and problems in a Next.js application.

Get linting working quickly with the ESLint CLI (flat config):

Install ESLint and the Next.js config:

Create eslint.config.mjs with the Next.js config:

Recommended rule-sets from the following ESLint plugins are all used within eslint-config-next:

The full set of rules is as follows:

We recommend using an appropriate integration to view warnings and errors directly in your code editor during development.

Starting with Next.js 16, next lint is removed.

As part of the removal, the eslint option in your Next config file is no longer needed and can be safely removed.

If you're using @next/eslint-plugin-next in a project where Next.js isn't installed in your root directory (such as a monorepo), you can tell @next/eslint-plugin-next where to find your Next.js application using the settings property in your eslint.config.mjs:

rootDir can be a path (relative or absolute), a glob (i.e. "packages/*/"), or an array of paths and/or globs.

If you would like to modify or disable any rules provided by the supported plugins (react, react-hooks, next), you can directly change them using the rules property in your eslint.config.mjs:

Enable the next/core-web-vitals rule set by extending it in your ESLint config.

next/core-web-vitals updates @next/eslint-plugin-next to error on a number of rules that are warnings by default if they affect Core Web Vitals.

The next/core-web-vitals entry point is automatically included for new applications built with Create Next App.

In addition to the Next.js ESLint rules, create-next-app --typescript will also add TypeScript-specific lint rules with next/typescript to your config:

Those rules are based on plugin:@typescript-eslint/recommended. See typescript-eslint > Configs for more details.

ESLint also contains code formatting rules, which can conflict with your existing Prettier setup. We recommend including eslint-config-prettier in your ESLint config to make ESLint and Prettier work together.

First, install the dependency:

Then, add prettier to your existing ESLint config:

If you would like to use ESLint with lint-staged to run the linter on staged git files, add the following to the .lintstagedrc.js file in the root of your project:

If you already have ESLint configured in your application, we recommend extending from this plugin directly instead of including eslint-config-next unless a few conditions are met.

If the following conditions are true:

Then we recommend either removing these settings if you prefer how these properties have been configured within eslint-config-next or extending directly from the Next.js ESLint plugin instead:

The plugin can be installed normally in your project:

This eliminates the risk of collisions or errors that can occur due to importing the same plugin or parser across multiple configurations.

If you already use a separate ESLint configuration and want to include eslint-config-next, ensure that it is extended last after other configurations. For example:

The next configuration already handles setting default values for the parser, plugins and settings properties. There is no need to manually re-declare any of these properties unless you need a different configuration for your use case.

If you include any other shareable configurations, you will need to make sure that these properties are not overwritten or modified. Otherwise, we recommend removing any configurations that share behavior with the next configuration or extending directly from the Next.js ESLint plugin as mentioned above.

**Examples:**

Example 1 (unknown):
```unknown
pnpm add -D eslint eslint-config-next
```

Example 2 (python):
```python
import { defineConfig, globalIgnores } from 'eslint/config'
import nextVitals from 'eslint-config-next/core-web-vitals'
 
const eslintConfig = defineConfig([
  ...nextVitals,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    '.next/**',
    'out/**',
    'build/**',
    'next-env.d.ts',
  ]),
])
 
export default eslintConfig
```

Example 3 (unknown):
```unknown
pnpm exec eslint .
```

Example 4 (python):
```python
import { defineConfig } from 'eslint/config'
import eslintNextPlugin from '@next/eslint-plugin-next'
 
const eslintConfig = defineConfig([
  {
    plugins: {
      next: eslintNextPlugin,
    },
    settings: {
      next: {
        rootDir: 'packages/my-app/',
      },
    },
    files: [
      // ...files
    ],
    ignores: [
      // ...ignores
    ],
  },
])
 
export default eslintConfig
```

---

## next CLI

**URL:** https://nextjs.org/docs/pages/api-reference/cli/next

**Contents:**
- next CLI
- Reference
  - Commands
  - next dev options
  - next build options
  - next start options
  - next info options
  - next telemetry options
  - next typegen options
- Examples

The Next.js CLI allows you to develop, build, start your application, and more.

The following options are available:

The following commands are available:

Good to know: Running next without a command is an alias for next dev.

next dev starts the application in development mode with Hot Module Reloading (HMR), error reporting, and more. The following options are available when running next dev:

next build creates an optimized production build of your application. The output displays information about each route. For example:

The following options are available for the next build command:

next start starts the application in production mode. The application should be compiled with next build first.

The following options are available for the next start command:

next info prints relevant details about the current system which can be used to report Next.js bugs when opening a GitHub issue. This information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next, react, react-dom), and more.

The output should look like this:

The following options are available for the next info command:

Next.js collects completely anonymous telemetry data about general usage. Participation in this anonymous program is optional, and you can opt-out if you prefer not to share information.

The following options are available for the next telemetry command:

Learn more about Telemetry.

next typegen generates TypeScript definitions for your application's routes without performing a full build. This is useful for IDE autocomplete and CI type-checking of route usage.

Previously, route types were only generated during next dev or next build, which meant running tsc --noEmit directly wouldn't validate your route types. Now you can generate types independently and validate them externally:

The following options are available for the next typegen command:

Output files are written to <distDir>/types (typically: .next/dev/types or .next/types, see isolatedDevBuild):

Additionally, next typegen generates a next-env.d.ts file. We recommend adding next-env.d.ts to your .gitignore file.

The next-env.d.ts file is included into your tsconfig.json file, to make Next.js types available to your project.

To ensure next-env.d.ts is present before type-checking run next typegen. The commands next dev and next build also generate the next-env.d.ts file, but it is often undesirable to run these just to type-check, for example in CI/CD environments.

Good to know: next typegen loads your Next.js config (next.config.js, next.config.mjs, or next.config.ts) using the production build phase. Ensure any required environment variables and dependencies are available so the config can load correctly.

If you encounter prerendering errors during next build, you can pass the --debug-prerender flag to get more detailed output:

This enables several experimental options to make debugging easier:

This helps surface more readable stack traces and code frames in the build output.

Warning: --debug-prerender is for debugging in development only. Do not deploy builds generated with --debug-prerender to production, as it may impact performance.

You can build only specific routes in the App and Pages Routers using the --debug-build-paths option. This is useful for faster debugging when working with large applications. The --debug-build-paths option accepts comma-separated file paths and supports glob patterns:

By default, Next.js uses http://localhost:3000 during development and with next start. The default port can be changed with the -p option, like so:

Or using the PORT environment variable:

Good to know: PORT cannot be set in .env as booting up the HTTP server happens before any other code is initialized.

For certain use cases like webhooks or authentication, you can use HTTPS to have a secure environment on localhost. Next.js can generate a self-signed certificate with next dev using the --experimental-https flag:

With the generated certificate, the Next.js development server will exist at https://localhost:3000. The default port 3000 is used unless a port is specified with -p, --port, or PORT.

You can also provide a custom certificate and key with --experimental-https-key and --experimental-https-cert. Optionally, you can provide a custom CA certificate with --experimental-https-ca as well.

next dev --experimental-https is only intended for development and creates a locally trusted certificate with mkcert. In production, use properly issued certificates from trusted authorities.

When deploying Next.js behind a downstream proxy (e.g. a load-balancer like AWS ELB/ALB), it's important to configure Next's underlying HTTP server with keep-alive timeouts that are larger than the downstream proxy's timeouts. Otherwise, once a keep-alive timeout is reached for a given TCP connection, Node.js will immediately terminate that connection without notifying the downstream proxy. This results in a proxy error whenever it attempts to reuse a connection that Node.js has already terminated.

To configure the timeout values for the production Next.js server, pass --keepAliveTimeout (in milliseconds) to next start, like so:

You can pass any node arguments to next commands. For example:

**Examples:**

Example 1 (unknown):
```unknown
npx next [command] [options]
```

Example 2 (unknown):
```unknown
Route (app)
â”Œ â—‹ /_not-found
â”” Æ’ /products/[id]
 
â—‹  (Static)   prerendered as static content
Æ’  (Dynamic)  server-rendered on demand
```

Example 3 (unknown):
```unknown
Operating System:
  Platform: darwin
  Arch: arm64
  Version: Darwin Kernel Version 23.6.0
  Available memory (MB): 65536
  Available CPU cores: 10
Binaries:
  Node: 20.12.0
  npm: 10.5.0
  Yarn: 1.22.19
  pnpm: 9.6.0
Relevant Packages:
  next: 15.0.0-canary.115 // Latest available version is detected (15.0.0-canary.115).
  eslint-config-next: 14.2.5
  react: 19.0.0-rc
  react-dom: 19.0.0
  typescript: 5.5.4
Next.js Config:
  output: N/A
```

Example 4 (unknown):
```unknown
# Generate route types first, then validate with TypeScript
next typegen && tsc --noEmit
 
# Or in CI workflows for type checking without building
next typegen && npm run type-check
```

---

## productionBrowserSourceMaps

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/productionBrowserSourceMaps

**Contents:**
- productionBrowserSourceMaps

Source Maps are enabled by default during development. During production builds, they are disabled to prevent you leaking your source on the client, unless you specifically opt-in with the configuration flag.

Next.js provides a configuration flag you can use to enable browser source map generation during the production build:

When the productionBrowserSourceMaps option is enabled, the source maps will be output in the same directory as the JavaScript files. Next.js will automatically serve these files when requested.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  productionBrowserSourceMaps: true,
}
```

---

## Font Module

**URL:** https://nextjs.org/docs/app/api-reference/components/font

**Contents:**
- Font Module
- Reference
  - src
  - weight
  - style
  - subsets
  - axes
  - display
  - preload
  - fallback

next/font automatically optimizes your fonts (including custom fonts) and removes external network requests for improved privacy and performance.

It includes built-in automatic self-hosting for any font file. This means you can optimally load web fonts with no layout shift.

You can also conveniently use all Google Fonts. CSS and font files are downloaded at build time and self-hosted with the rest of your static assets. No requests are sent to Google by the browser.

ðŸŽ¥ Watch: Learn more about using next/font â†’ YouTube (6 minutes).

The path of the font file as a string or an array of objects (with type Array<{path: string, weight?: string, style?: string}>) relative to the directory where the font loader function is called.

Used in next/font/local

The font weight with the following possibilities:

Used in next/font/google and next/font/local

The font style with the following possibilities:

Used in next/font/google and next/font/local

The font subsets defined by an array of string values with the names of each subset you would like to be preloaded. Fonts specified via subsets will have a link preload tag injected into the head when the preload option is true, which is the default.

Used in next/font/google

You can find a list of all subsets on the Google Fonts page for your font.

Some variable fonts have extra axes that can be included. By default, only the font weight is included to keep the file size down. The possible values of axes depend on the specific font.

Used in next/font/google

The font display with possible string values of 'auto', 'block', 'swap', 'fallback' or 'optional' with default value of 'swap'.

Used in next/font/google and next/font/local

A boolean value that specifies whether the font should be preloaded or not. The default is true.

Used in next/font/google and next/font/local

The fallback font to use if the font cannot be loaded. An array of strings of fallback fonts with no default.

Used in next/font/google and next/font/local

Used in next/font/google and next/font/local

A string value to define the CSS variable name to be used if the style is applied with the CSS variable method.

Used in next/font/google and next/font/local

An array of font face descriptor key-value pairs that define the generated @font-face further.

Used in next/font/local

To use a Google font, import it from next/font/google as a function. We recommend using variable fonts for the best performance and flexibility.

If you can't use a variable font, you will need to specify a weight:

You can specify multiple weights and/or styles by using an array:

Good to know: Use an underscore (_) for font names with multiple words. E.g. Roboto Mono should be imported as Roboto_Mono.

Google Fonts are automatically subset. This reduces the size of the font file and improves performance. You'll need to define which of these subsets you want to preload. Failing to specify any subsets while preload is true will result in a warning.

This can be done by adding it to the function call:

View the Font API Reference for more information.

You can import and use multiple fonts in your application. There are two approaches you can take.

The first approach is to create a utility function that exports a font, imports it, and applies its className where needed. This ensures the font is preloaded only when it's rendered:

In the example above, Inter will be applied globally, and Roboto Mono can be imported and applied as needed.

Alternatively, you can create a CSS variable and use it with your preferred CSS solution:

In the example above, Inter will be applied globally, and any <h1> tags will be styled with Roboto Mono.

Recommendation: Use multiple fonts conservatively since each new font is an additional resource the client has to download.

Import next/font/local and specify the src of your local font file. We recommend using variable fonts for the best performance and flexibility.

If you want to use multiple files for a single font family, src can be an array:

View the Font API Reference for more information.

next/font integrates seamlessly with Tailwind CSS using CSS variables.

In the example below, we use the Inter and Roboto_Mono fonts from next/font/google (you can use any Google Font or Local Font). Use the variable option to define a CSS variable name, such as inter and roboto_mono for these fonts, respectively. Then, apply inter.variable and roboto_mono.variable to include the CSS variables in your HTML document.

Good to know: You can add these variables to the <html> or <body> tag, depending on your preference, styling needs or project requirements.

Finally, add the CSS variable to your Tailwind CSS config:

You can now use the font-sans and font-mono utility classes to apply the font to your elements.

You can apply the font styles in three ways:

Returns a read-only CSS className for the loaded font to be passed to an HTML element.

Returns a read-only CSS style object for the loaded font to be passed to an HTML element, including style.fontFamily to access the font family name and fallback fonts.

If you would like to set your styles in an external style sheet and specify additional options there, use the CSS variable method.

In addition to importing the font, also import the CSS file where the CSS variable is defined and set the variable option of the font loader object as follows:

To use the font, set the className of the parent container of the text you would like to style to the font loader's variable value and the className of the text to the styles property from the external CSS file.

Define the text selector class in the component.module.css CSS file as follows:

In the example above, the text Hello World is styled using the Inter font and the generated font fallback with font-weight: 200 and font-style: italic.

Every time you call the localFont or Google font function, that font will be hosted as one instance in your application. Therefore, if you need to use the same font in multiple places, you should load it in one place and import the related font object where you need it. This is done using a font definitions file.

For example, create a fonts.ts file in a styles folder at the root of your app directory.

Then, specify your font definitions as follows:

You can now use these definitions in your code as follows:

To make it easier to access the font definitions in your code, you can define a path alias in your tsconfig.json or jsconfig.json files as follows:

You can now import any font definition as follows:

When a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only preloaded on the related routes based on the type of file where it is used:

**Examples:**

Example 1 (python):
```python
import { Inter } from 'next/font/google'
 
// If loading a variable font, you don't need to specify the font weight
const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
})
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={inter.className}>
      <body>{children}</body>
    </html>
  )
}
```

Example 2 (python):
```python
import { Inter } from 'next/font/google'
 
// If loading a variable font, you don't need to specify the font weight
const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
})
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={inter.className}>
      <body>{children}</body>
    </html>
  )
}
```

Example 3 (python):
```python
import { Roboto } from 'next/font/google'
 
const roboto = Roboto({
  weight: '400',
  subsets: ['latin'],
  display: 'swap',
})
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={roboto.className}>
      <body>{children}</body>
    </html>
  )
}
```

Example 4 (javascript):
```javascript
const roboto = Roboto({
  weight: ['400', '700'],
  style: ['normal', 'italic'],
  subsets: ['latin'],
  display: 'swap',
})
```

---

## How to use environment variables in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/environment-variables

**Contents:**
- How to use environment variables in Next.js
- Loading Environment Variables
  - Loading Environment Variables with @next/env
  - Referencing Other Variables
- Bundling Environment Variables for the Browser
  - Runtime Environment Variables
- Test Environment Variables
- Environment Variable Load Order
- Good to know
- Version History

Next.js comes with built-in support for environment variables, which allows you to do the following:

Warning: The default create-next-app template ensures all .env files are added to your .gitignore. You almost never want to commit these files to your repository.

Next.js has built-in support for loading environment variables from .env* files into process.env.

Note: Next.js also supports multiline variables inside of your .env* files:

Note: If you are using a /src folder, please note that Next.js will load the .env files only from the parent folder and not from the /src folder. This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Route Handlers.

If you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the @next/env package.

This package is used internally by Next.js to load environment variables from .env* files.

To use it, install the package and use the loadEnvConfig function to load the environment variables:

Then, you can import the configuration where needed. For example:

Next.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This allows you to reference other secrets. For example:

In the above example, process.env.TWITTER_URL would be set to https://x.com/nextjs.

Good to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \$.

Non-NEXT_PUBLIC_ environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment).

In order to make the value of an environment variable accessible in the browser, Next.js can "inline" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXT_PUBLIC_. For example:

This will tell Next.js to replace all references to process.env.NEXT_PUBLIC_ANALYTICS_ID in the Node.js environment with the value from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.

Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all NEXT_PUBLIC_ variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).

Note that dynamic lookups will not be inlined, such as:

Next.js can support both build time and runtime environment variables.

By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.

You can safely read environment variables on the server during dynamic rendering:

This allows you to use a singular Docker image that can be promoted through multiple environments with different values.

Apart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Next.js will not load environment variables from .env.development or .env.production in the testing environment.

This one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don't need to do this manually as testing tools will address it for you.

There is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set).

Good to know: similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env*.local are intended to be ignored through .gitignore.

While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the loadEnvConfig function from the @next/env package.

Environment variables are looked up in the following places, in order, stopping once the variable is found.

For example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used.

Good to know: The allowed values for NODE_ENV are production, development and test.

**Examples:**

Example 1 (unknown):
```unknown
DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
```

Example 2 (unknown):
```unknown
# .env
 
# you can write with line breaks
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
...
Kh9NV...
...
-----END DSA PRIVATE KEY-----"
 
# or with `\n` inside double quotes
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\nKh9NV...\n-----END DSA PRIVATE KEY-----\n"
```

Example 3 (javascript):
```javascript
export async function GET() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
  })
  // ...
}
```

Example 4 (unknown):
```unknown
npm install @next/env
```

---

## How to upgrade to version 15

**URL:** https://nextjs.org/docs/app/guides/upgrading/version-15

**Contents:**
- How to upgrade to version 15
- Upgrading from 14 to 15
- React 19
- Async Request APIs (Breaking change)
  - cookies
    - Recommended Async Usage
    - Temporary Synchronous Usage
  - headers
    - Recommended Async Usage
    - Temporary Synchronous Usage

To update to Next.js version 15, you can use the upgrade codemod:

If you prefer to do it manually, ensure that you're installing the latest Next & React versions:

Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions.

Previously synchronous Dynamic APIs that rely on runtime information are now asynchronous:

To ease the burden of migration, a codemod is available to automate the process and the APIs can temporarily be accessed synchronously.

The runtime segment configuration previously supported a value of experimental-edge in addition to edge. Both configurations refer to the same thing, and to simplify the options, we will now error if experimental-edge is used. To fix this, update your runtime configuration to edge. A codemod is available to automatically do this.

fetch requests are no longer cached by default.

To opt specific fetch requests into caching, you can pass the cache: 'force-cache' option.

To opt all fetch requests in a layout or page into caching, you can use the export const fetchCache = 'default-cache' segment config option. If individual fetch requests specify a cache option, that will be used instead.

GET functions in Route Handlers are no longer cached by default. To opt GET methods into caching, you can use a route config option such as export const dynamic = 'force-static' in your Route Handler file.

When navigating between pages via <Link> or useRouter, page segments are no longer reused from the client-side router cache. However, they are still reused during browser backward and forward navigation and for shared layouts.

To opt page segments into caching, you can use the staleTimes config option:

Layouts and loading states are still cached and reused on navigation.

The @next/font package has been removed in favor of the built-in next/font. A codemod is available to safely and automatically rename your imports.

experimental.bundlePagesExternals is now stable and renamed to bundlePagesRouterDependencies.

experimental.serverComponentsExternalPackages is now stable and renamed to serverExternalPackages.

Auto instrumentation for Speed Insights was removed in Next.js 15.

To continue using Speed Insights, follow the Vercel Speed Insights Quickstart guide.

The geo and ip properties on NextRequest have been removed as these values are provided by your hosting provider. A codemod is available to automate this migration.

If you are using Vercel, you can alternatively use the geolocation and ipAddress functions from @vercel/functions instead:

**Examples:**

Example 1 (unknown):
```unknown
npx @next/codemod@canary upgrade latest
```

Example 2 (unknown):
```unknown
npm i next@latest react@latest react-dom@latest eslint-config-next@latest
```

Example 3 (python):
```python
import { cookies } from 'next/headers'
 
// Before
const cookieStore = cookies()
const token = cookieStore.get('token')
 
// After
const cookieStore = await cookies()
const token = cookieStore.get('token')
```

Example 4 (python):
```python
import { cookies, type UnsafeUnwrappedCookies } from 'next/headers'
 
// Before
const cookieStore = cookies()
const token = cookieStore.get('token')
 
// After
const cookieStore = cookies() as unknown as UnsafeUnwrappedCookies
// will log a warning in dev
const token = cookieStore.get('token')
```

---

## Turbopack

**URL:** https://nextjs.org/docs/app/api-reference/turbopack

**Contents:**
- Turbopack
- Why Turbopack?
- Getting started
  - Using Webpack instead
- Supported features
  - Language features
  - Framework and React features
  - CSS and styling
  - Assets
  - Module resolution

Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. You can use Turbopack with both the Pages and App Router for a much faster local development experience.

We built Turbopack to push the performance of Next.js, including:

Turbopack is now the default bundler in Next.js. No configuration is needed to use Turbopack:

If you need to use Webpack instead of Turbopack, you can opt-in with the --webpack flag:

Turbopack in Next.js has zero-configuration for the common use cases. Below is a summary of what is supported out of the box, plus some references to how you can configure Turbopack further when needed.

There are a number of non-trivial behavior differences between webpack and Turbopack that are important to be aware of when migrating an application. Generally, these are less of a concern for new applications.

Turbopack will follow JS import order to order CSS modules which are not otherwise ordered. For example:

In this example, Turbopack will ensure that utils.module.css will appear before button.module.css in the produced CSS chunk, following the import order

Webpack generally does this as well, but there are cases where it will ignore JS inferred ordering, for example if it infers the JS file is side-effect-free.

This can lead to subtle rendering changes when adopting Turbopack, if applications have come to rely on an arbitrary ordering. Generally, the solution is easy, e.g. have button.module.css @import utils.module.css to force the ordering, or identify the conflicting rules and change them to not target the same properties.

Turbopack supports importing node_modules Sass files out of the box. Webpack supports a legacy tilde ~ syntax for this, which is not supported by Turbopack.

If you can't update the imports, you can add a turbopack.resolveAlias configuration to map the ~ syntax to the actual path:

From our testing on production applications, we observed that Turbopack generally produces bundles that are similar in size to Webpack. However, the comparison can be difficult since turbopack tends to produce fewer but larger chunks. Our advice is to focus on higher level metrics like Core Web Vitals or your own application level metrics to compare performance across the two bundlers. We are however aware of one gap that can occasionally cause a large regression.

Turbopack does not yet have an equivalent to the Inner Graph Optimization in webpack which is enabled by default. This optimization is useful to tree shake large modules. For example:

If an application only uses CONSTANT_VALUE Turbopack will detect this and delete the usesHeavy export but not the corresponding import. However, with the Inner Graph Optimization, webpack can delete the import too which can drop the dependency as well.

We are planning to offer an equivalent to the Inner Graph Optimization in Turbopack but it is still under development. If you are affected by this gap, consider manually splitting modules.

Webpack supports disk build caching to improve build performance. Turbopack provides a similar opt-in feature, currently in beta. Starting with Next 16, you can enable Turbopackâ€™s filesystem cache by setting the following experimental flags:

Good to know: For this reason, when comparing webpack and Turbopack performance, make sure to delete the .next folder between builds to see a fair comparison or enable the turbopack filesystem cache feature.

Turbopack does not support webpack plugins. This affects third-party tools that rely on webpack's plugin system for integration. We do support webpack loaders. If you depend on webpack plugins, you'll need to find Turbopack-compatible alternatives or continue using webpack until equivalent functionality is available.

Some features are not yet implemented or not planned:

For a full, detailed breakdown of each feature flag and its status, see the Turbopack API Reference.

Turbopack can be configured via next.config.js (or next.config.ts) under the turbopack key. Configuration options include:

For more in-depth configuration examples, see the Turbopack config documentation.

If you encounter performance or memory issues and want to help the Next.js team diagnose them, you can generate a trace file by appending NEXT_TURBOPACK_TRACING=1 to your dev command:

This will produce a .next/dev/trace-turbopack file. Include that file when creating a GitHub issue on the Next.js repo to help us investigate.

By default the development server outputs to .next/dev. Read more about isolatedDevBuild.

Turbopack is a Rust-based, incremental bundler designed to make local development and builds fastâ€”especially for large applications. It is integrated into Next.js, offering zero-config CSS, React, and TypeScript support.

**Examples:**

Example 1 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

Example 2 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev --webpack",
    "build": "next build --webpack",
    "start": "next start"
  }
}
```

Example 3 (python):
```python
import utilStyles from './utils.module.css'
import buttonStyles from './button.module.css'
export default function BlogPost() {
  return (
    <div className={utilStyles.container}>
      <button className={buttonStyles.primary}>Click me</button>
    </div>
  )
}
```

Example 4 (unknown):
```unknown
@import '~bootstrap/dist/css/bootstrap.min.css';
```

---

## reactMaxHeadersLength

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/reactMaxHeadersLength

**Contents:**
- reactMaxHeadersLength

During static rendering, React can emit headers that can be added to the response. These can be used to improve performance by allowing the browser to preload resources like fonts, scripts, and stylesheets. The default value is 6000, but you can override this value by configuring the reactMaxHeadersLength option in next.config.js:

Good to know: This option is only available in App Router.

Depending on the type of proxy between the browser and the server, the headers can be truncated. For example, if you are using a reverse proxy that doesn't support long headers, you should set a lower value to ensure that the headers are not truncated.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  reactMaxHeadersLength: 1000,
}
```

---

## reactStrictMode

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/reactStrictMode

**Contents:**
- reactStrictMode

Good to know: Since Next.js 13.5.1, Strict Mode is true by default with app router, so the above configuration is only necessary for pages. You can still disable Strict Mode by setting reactStrictMode: false.

Suggested: We strongly suggest you enable Strict Mode in your Next.js application to better prepare your application for the future of React.

React's Strict Mode is a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe lifecycles, legacy API usage, and a number of other features.

The Next.js runtime is Strict Mode-compliant. To opt-in to Strict Mode, configure the following option in your next.config.js:

If you or your team are not ready to use Strict Mode in your entire application, that's OK! You can incrementally migrate on a page-by-page basis using <React.StrictMode>.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  reactStrictMode: true,
}
```

---

## Font Module

**URL:** https://nextjs.org/docs/pages/api-reference/components/font

**Contents:**
- Font Module
- Reference
  - src
  - weight
  - style
  - subsets
  - axes
  - display
  - preload
  - fallback

next/font automatically optimizes your fonts (including custom fonts) and removes external network requests for improved privacy and performance.

It includes built-in automatic self-hosting for any font file. This means you can optimally load web fonts with no layout shift.

You can also conveniently use all Google Fonts. CSS and font files are downloaded at build time and self-hosted with the rest of your static assets. No requests are sent to Google by the browser.

To use the font in all your pages, add it to _app.js file under /pages as shown below:

ðŸŽ¥ Watch: Learn more about using next/font â†’ YouTube (6 minutes).

The path of the font file as a string or an array of objects (with type Array<{path: string, weight?: string, style?: string}>) relative to the directory where the font loader function is called.

Used in next/font/local

The font weight with the following possibilities:

Used in next/font/google and next/font/local

The font style with the following possibilities:

Used in next/font/google and next/font/local

The font subsets defined by an array of string values with the names of each subset you would like to be preloaded. Fonts specified via subsets will have a link preload tag injected into the head when the preload option is true, which is the default.

Used in next/font/google

You can find a list of all subsets on the Google Fonts page for your font.

Some variable fonts have extra axes that can be included. By default, only the font weight is included to keep the file size down. The possible values of axes depend on the specific font.

Used in next/font/google

The font display with possible string values of 'auto', 'block', 'swap', 'fallback' or 'optional' with default value of 'swap'.

Used in next/font/google and next/font/local

A boolean value that specifies whether the font should be preloaded or not. The default is true.

Used in next/font/google and next/font/local

The fallback font to use if the font cannot be loaded. An array of strings of fallback fonts with no default.

Used in next/font/google and next/font/local

Used in next/font/google and next/font/local

A string value to define the CSS variable name to be used if the style is applied with the CSS variable method.

Used in next/font/google and next/font/local

An array of font face descriptor key-value pairs that define the generated @font-face further.

Used in next/font/local

To use a Google font, import it from next/font/google as a function. We recommend using variable fonts for the best performance and flexibility.

To use the font in all your pages, add it to _app.js file under /pages as shown below:

If you can't use a variable font, you will need to specify a weight:

You can specify multiple weights and/or styles by using an array:

Good to know: Use an underscore (_) for font names with multiple words. E.g. Roboto Mono should be imported as Roboto_Mono.

You can also use the font without a wrapper and className by injecting it inside the <head> as follows:

To use the font on a single page, add it to the specific page as shown below:

Google Fonts are automatically subset. This reduces the size of the font file and improves performance. You'll need to define which of these subsets you want to preload. Failing to specify any subsets while preload is true will result in a warning.

This can be done by adding it to the function call:

View the Font API Reference for more information.

You can import and use multiple fonts in your application. There are two approaches you can take.

The first approach is to create a utility function that exports a font, imports it, and applies its className where needed. This ensures the font is preloaded only when it's rendered:

In the example above, Inter will be applied globally, and Roboto Mono can be imported and applied as needed.

Alternatively, you can create a CSS variable and use it with your preferred CSS solution:

In the example above, Inter will be applied globally, and any <h1> tags will be styled with Roboto Mono.

Recommendation: Use multiple fonts conservatively since each new font is an additional resource the client has to download.

Import next/font/local and specify the src of your local font file. We recommend using variable fonts for the best performance and flexibility.

If you want to use multiple files for a single font family, src can be an array:

View the Font API Reference for more information.

next/font integrates seamlessly with Tailwind CSS using CSS variables.

In the example below, we use the Inter and Roboto_Mono fonts from next/font/google (you can use any Google Font or Local Font). Use the variable option to define a CSS variable name, such as inter and roboto_mono for these fonts, respectively. Then, apply inter.variable and roboto_mono.variable to include the CSS variables in your HTML document.

Good to know: You can add these variables to the <html> or <body> tag, depending on your preference, styling needs or project requirements.

Finally, add the CSS variable to your Tailwind CSS config:

You can now use the font-sans and font-mono utility classes to apply the font to your elements.

You can apply the font styles in three ways:

Returns a read-only CSS className for the loaded font to be passed to an HTML element.

Returns a read-only CSS style object for the loaded font to be passed to an HTML element, including style.fontFamily to access the font family name and fallback fonts.

If you would like to set your styles in an external style sheet and specify additional options there, use the CSS variable method.

In addition to importing the font, also import the CSS file where the CSS variable is defined and set the variable option of the font loader object as follows:

To use the font, set the className of the parent container of the text you would like to style to the font loader's variable value and the className of the text to the styles property from the external CSS file.

Define the text selector class in the component.module.css CSS file as follows:

In the example above, the text Hello World is styled using the Inter font and the generated font fallback with font-weight: 200 and font-style: italic.

Every time you call the localFont or Google font function, that font will be hosted as one instance in your application. Therefore, if you need to use the same font in multiple places, you should load it in one place and import the related font object where you need it. This is done using a font definitions file.

For example, create a fonts.ts file in a styles folder at the root of your app directory.

Then, specify your font definitions as follows:

You can now use these definitions in your code as follows:

To make it easier to access the font definitions in your code, you can define a path alias in your tsconfig.json or jsconfig.json files as follows:

You can now import any font definition as follows:

When a font function is called on a page of your site, it is not globally available and preloaded on all routes. Rather, the font is only preloaded on the related route/s based on the type of file where it is used:

**Examples:**

Example 1 (python):
```python
import { Inter } from 'next/font/google'
 
// If loading a variable font, you don't need to specify the font weight
const inter = Inter({ subsets: ['latin'] })
 
export default function MyApp({ Component, pageProps }) {
  return (
    <main className={inter.className}>
      <Component {...pageProps} />
    </main>
  )
}
```

Example 2 (python):
```python
import { Inter } from 'next/font/google'
 
// If loading a variable font, you don't need to specify the font weight
const inter = Inter({ subsets: ['latin'] })
 
export default function MyApp({ Component, pageProps }) {
  return (
    <main className={inter.className}>
      <Component {...pageProps} />
    </main>
  )
}
```

Example 3 (python):
```python
import { Roboto } from 'next/font/google'
 
const roboto = Roboto({
  weight: '400',
  subsets: ['latin'],
})
 
export default function MyApp({ Component, pageProps }) {
  return (
    <main className={roboto.className}>
      <Component {...pageProps} />
    </main>
  )
}
```

Example 4 (javascript):
```javascript
const roboto = Roboto({
  weight: ['400', '700'],
  style: ['normal', 'italic'],
  subsets: ['latin'],
  display: 'swap',
})
```

---

## useRouter

**URL:** https://nextjs.org/docs/app/api-reference/functions/use-router

**Contents:**
- useRouter
- useRouter()
  - Migrating from next/router
- Examples
  - Router events
  - Disabling scroll to top
- Version History

The useRouter hook allows you to programmatically change routes inside Client Components.

Recommendation: Use the <Link> component for navigation unless you have a specific requirement for using useRouter.

View the full migration guide.

You can listen for page changes by composing other Client Component hooks like usePathname and useSearchParams.

Which can be imported into a layout.

Good to know: <NavigationEvents> is wrapped in a Suspense boundary becauseuseSearchParams() causes client-side rendering up to the closest Suspense boundary during static rendering. Learn more.

By default, Next.js will scroll to the top of the page when navigating to a new route. You can disable this behavior by passing scroll: false to router.push() or router.replace().

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useRouter } from 'next/navigation'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

Example 2 (python):
```python
'use client'
 
import { useEffect } from 'react'
import { usePathname, useSearchParams } from 'next/navigation'
 
export function NavigationEvents() {
  const pathname = usePathname()
  const searchParams = useSearchParams()
 
  useEffect(() => {
    const url = `${pathname}?${searchParams}`
    console.log(url)
    // You can now use the current URL
    // ...
  }, [pathname, searchParams])
 
  return '...'
}
```

Example 3 (python):
```python
import { Suspense } from 'react'
import { NavigationEvents } from './components/navigation-events'
 
export default function Layout({ children }) {
  return (
    <html lang="en">
      <body>
        {children}
 
        <Suspense fallback={null}>
          <NavigationEvents />
        </Suspense>
      </body>
    </html>
  )
}
```

Example 4 (python):
```python
'use client'
 
import { useRouter } from 'next/navigation'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button
      type="button"
      onClick={() => router.push('/dashboard', { scroll: false })}
    >
      Dashboard
    </button>
  )
}
```

---

## crossOrigin

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/crossOrigin

**Contents:**
- crossOrigin
- Options

Use the crossOrigin option to add a crossOrigin attribute in all <script> tags generated by the next/script component , and define how cross-origin requests should be handled.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  crossOrigin: 'anonymous',
}
```

---

## API Routes

**URL:** https://nextjs.org/docs/pages/building-your-application/routing/api-routes

**Contents:**
- API Routes
- Parameters
- HTTP Methods
- Request Helpers
  - Custom config
- Response Helpers
  - Setting the status code of a response
  - Sending a JSON response
  - Sending a HTTP response
  - Redirects to a specified path or URL

Good to know: If you are using the App Router, you can use Server Components or Route Handlers instead of API Routes.

API routes provide a solution to build a public API with Next.js.

Any file inside the folder pages/api is mapped to /api/* and will be treated as an API endpoint instead of a page. They are server-side only bundles and won't increase your client-side bundle size.

For example, the following API route returns a JSON response with a status code of 200:

To handle different HTTP methods in an API route, you can use req.method in your request handler, like so:

API Routes provide built-in request helpers which parse the incoming request (req):

Every API Route can export a config object to change the default configuration, which is the following:

bodyParser is automatically enabled. If you want to consume the body as a Stream or with raw-body, you can set this to false.

One use case for disabling the automatic bodyParsing is to allow you to verify the raw body of a webhook request, for example from GitHub.

bodyParser.sizeLimit is the maximum size allowed for the parsed body, in any format supported by bytes, like so:

externalResolver is an explicit flag that tells the server that this route is being handled by an external resolver like express or connect. Enabling this option disables warnings for unresolved requests.

responseLimit is automatically enabled, warning when an API Routes' response body is over 4MB.

If you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated media host, you can set this limit to false.

responseLimit can also take the number of bytes or any string format supported by bytes, for example 1000, '500kb' or '3mb'. This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above)

The Server Response object, (often abbreviated as res) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints.

The included helpers are:

When sending a response back to the client, you can set the status code of the response.

The following example sets the status code of the response to 200 (OK) and returns a message property with the value of Hello from Next.js! as a JSON response:

When sending a response back to the client you can send a JSON response, this must be a serializable object. In a real world application you might want to let the client know the status of the request depending on the result of the requested endpoint.

The following example sends a JSON response with the status code 200 (OK) and the result of the async operation. It's contained in a try catch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the client:

Sending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be a string, an object or a Buffer.

The following example sends a HTTP response with the status code 200 (OK) and the result of the async operation.

Taking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form.

The following example redirects the client to the / path if the form is successfully submitted:

You can make your API Routes more type-safe by importing the NextApiRequest and NextApiResponse types from next, in addition to those, you can also type your response data:

Good to know: The body of NextApiRequest is any because the client may include any payload. You should validate the type/shape of the body at runtime before using it.

API Routes support dynamic routes, and follow the same file naming rules used for pages/.

Now, a request to /api/post/abc will respond with the text: Post: abc.

API Routes can be extended to catch all paths by adding three dots (...) inside the brackets. For example:

Good to know: You can use names other than slug, such as: [...param]

Matched parameters will be sent as a query parameter (slug in the example) to the page, and it will always be an array, so, the path /api/post/a will have the following query object:

And in the case of /api/post/a/b, and any other matching path, new parameters will be added to the array, like so:

Now, a request to /api/post/a/b/c will respond with the text: Post: a, b, c.

Catch all routes can be made optional by including the parameter in double brackets ([[...slug]]).

For example, pages/api/post/[[...slug]].js will match /api/post, /api/post/a, /api/post/a/b, and so on.

The main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched (/api/post in the example above).

The query objects are as follows:

While the Pages Router does support streaming responses with API Routes, we recommend incrementally adopting the App Router and using Route Handlers if you are on Next.js 14+.

Here's how you can stream a response from an API Route with writeHead:

**Examples:**

Example 1 (python):
```python
import type { NextApiRequest, NextApiResponse } from 'next'
 
type ResponseData = {
  message: string
}
 
export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>
) {
  res.status(200).json({ message: 'Hello from Next.js!' })
}
```

Example 2 (unknown):
```unknown
export default function handler(req: NextApiRequest, res: NextApiResponse) {
  // ...
}
```

Example 3 (python):
```python
import type { NextApiRequest, NextApiResponse } from 'next'
 
export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    // Process a POST request
  } else {
    // Handle any other HTTP method
  }
}
```

Example 4 (javascript):
```javascript
export const config = {
  api: {
    bodyParser: {
      sizeLimit: '1mb',
    },
  },
  // Specifies the maximum allowed duration for this function to execute (in seconds)
  maxDuration: 5,
}
```

---

## opengraph-image and twitter-image

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image

**Contents:**
- opengraph-image and twitter-image
- Image files (.jpg, .png, .gif)
  - opengraph-image
  - twitter-image
  - opengraph-image.alt.txt
  - twitter-image.alt.txt
- Generate images using code (.js, .ts, .tsx)
  - Props
    - params (optional)
  - Returns

The opengraph-image and twitter-image file conventions allow you to set Open Graph and Twitter images for a route segment.

They are useful for setting the images that appear on social networks and messaging apps when a user shares a link to your site.

There are two ways to set Open Graph and Twitter images:

Use an image file to set a route segment's shared image by placing an opengraph-image or twitter-image image file in the segment.

Next.js will evaluate the file and automatically add the appropriate tags to your app's <head> element.

The twitter-image file size must not exceed 5MB, and the opengraph-image file size must not exceed 8MB. If the image file size exceeds these limits, the build will fail.

Add an opengraph-image.(jpg|jpeg|png|gif) image file to any route segment.

Add a twitter-image.(jpg|jpeg|png|gif) image file to any route segment.

Add an accompanying opengraph-image.alt.txt file in the same route segment as the opengraph-image.(jpg|jpeg|png|gif) image it's alt text.

Add an accompanying twitter-image.alt.txt file in the same route segment as the twitter-image.(jpg|jpeg|png|gif) image it's alt text.

In addition to using literal image files, you can programmatically generate images using code.

Generate a route segment's shared image by creating an opengraph-image or twitter-image route that default exports a function.

The easiest way to generate an image is to use the ImageResponse API from next/og.

The default export function receives the following props:

A promise that resolves to an object containing the dynamic route parameters object from the root segment down to the segment opengraph-image or twitter-image is colocated in.

Good to know: If you use generateImageMetadata, the function will also receive an id prop that is a promise resolving to the id value from one of the items returned by generateImageMetadata.

The default export function should return a Blob | ArrayBuffer | TypedArray | DataView | ReadableStream | Response.

Good to know: ImageResponse satisfies this return type.

You can optionally configure the image's metadata by exporting alt, size, and contentType variables from opengraph-image or twitter-image route.

opengraph-image and twitter-image are specialized Route Handlers that can use the same route segment configuration options as Pages and Layouts.

This example uses the params object and external data to generate the image.

Good to know: By default, this generated image will be statically optimized. You can configure the individual fetch options or route segments options to change this behavior.

These examples use the Node.js runtime to fetch a local image from the file system and pass it to the <img> src attribute, either as a base64 string or an ArrayBuffer. Place the local asset relative to the project root, not the example source file.

Passing an ArrayBuffer to the src attribute of an <img> element is not part of the HTML spec. The rendering engine used by next/og supports it, but because TypeScript definitions follow the spec, you need a @ts-expect-error directive or similar to use this feature.

**Examples:**

Example 1 (unknown):
```unknown
<meta property="og:image" content="<generated>" />
<meta property="og:image:type" content="<generated>" />
<meta property="og:image:width" content="<generated>" />
<meta property="og:image:height" content="<generated>" />
```

Example 2 (unknown):
```unknown
<meta name="twitter:image" content="<generated>" />
<meta name="twitter:image:type" content="<generated>" />
<meta name="twitter:image:width" content="<generated>" />
<meta name="twitter:image:height" content="<generated>" />
```

Example 3 (unknown):
```unknown
<meta property="og:image:alt" content="About Acme" />
```

Example 4 (unknown):
```unknown
<meta property="twitter:image:alt" content="About Acme" />
```

---

## How to use Sass

**URL:** https://nextjs.org/docs/app/guides/sass

**Contents:**
- How to use Sass
  - Customizing Sass Options
    - Implementation
  - Sass Variables

Next.js has built-in support for integrating with Sass after the package is installed using both the .scss and .sass extensions. You can use component-level Sass via CSS Modules and the .module.scssor .module.sass extension.

Sass supports two different syntaxes, each with their own extension. The .scss extension requires you use the SCSS syntax, while the .sass extension requires you use the Indented Syntax ("Sass").

If you're not sure which to choose, start with the .scss extension which is a superset of CSS, and doesn't require you learn the Indented Syntax ("Sass").

If you want to configure your Sass options, use sassOptions in next.config.

You can use the implementation property to specify the Sass implementation to use. By default, Next.js uses the sass package.

Next.js supports Sass variables exported from CSS Module files.

For example, using the exported primaryColor Sass variable:

**Examples:**

Example 1 (unknown):
```unknown
npm install --save-dev sass
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  sassOptions: {
    additionalData: `$var: red;`,
  },
}
 
export default nextConfig
```

Example 3 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  sassOptions: {
    implementation: 'sass-embedded',
  },
}
 
export default nextConfig
```

Example 4 (unknown):
```unknown
$primary-color: #64ff00;
 
:export {
  primaryColor: $primary-color;
}
```

---

## src Folder

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/src-folder

**Contents:**
- src Folder
- Next Steps
  - Project Structure

As an alternative to having the special Next.js app or pages directories in the root of your project, Next.js also supports the common pattern of placing application code under the src folder.

This separates application code from project configuration files which mostly live in the root of a project, which is preferred by some individuals and teams.

To use the src folder, move the app Router folder or pages Router folder to src/app or src/pages respectively.

---

## pageExtensions

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/pageExtensions

**Contents:**
- pageExtensions

By default, Next.js accepts files with the following extensions: .tsx, .ts, .jsx, .js. This can be modified to allow other extensions like markdown (.md, .mdx).

**Examples:**

Example 1 (javascript):
```javascript
const withMDX = require('@next/mdx')()
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],
}
 
module.exports = withMDX(nextConfig)
```

---

## redirect

**URL:** https://nextjs.org/docs/app/api-reference/functions/redirect

**Contents:**
- redirect
- Reference
  - Parameters
  - Returns
- Behavior
- Example
  - Server Component
  - Client Component
- FAQ
  - Why does redirect use 307 and 308?

The redirect function allows you to redirect the user to another URL. redirect can be used while rendering in Server and Client Components, Route Handlers, and Server Actions.

When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 307 HTTP redirect response to the caller.

If a resource doesn't exist, you can use the notFound function instead.

The redirect function accepts two arguments:

By default, redirect will use push (adding a new entry to the browser history stack) in Server Actions and replace (replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type parameter.

The RedirectType object contains the available options for the type parameter.

The type parameter has no effect when used in Server Components.

redirect does not return a value.

Invoking the redirect() function throws a NEXT_REDIRECT error and terminates rendering of the route segment in which it was thrown.

Good to know: redirect does not require you to use return redirect() as it uses the TypeScript never type.

redirect can be directly used in a Client Component.

Good to know: When using redirect in a Client Component on initial page load during Server-Side Rendering (SSR), it will perform a server-side redirect.

redirect can be used in a Client Component through a Server Action. If you need to use an event handler to redirect the user, you can use the useRouter hook.

When using redirect() you may notice that the status codes used are 307 for a temporary redirect, and 308 for a permanent redirect. While traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, many browsers changed the request method of the redirect, from a POST to GET request when using a 302, regardless of the origins request method.

Taking the following example of a redirect from /users to /people, if you make a POST request to /users to create a new user, and are conforming to a 302 temporary redirect, the request method will be changed from a POST to a GET request. This doesn't make sense, as to create a new user, you should be making a POST request to /people, and not a GET request.

The introduction of the 307 status code means that the request method is preserved as POST.

The redirect() method uses a 307 by default, instead of a 302 temporary redirect, meaning your requests will always be preserved as POST requests.

Learn more about HTTP Redirects.

**Examples:**

Example 1 (unknown):
```unknown
redirect(path, type)
```

Example 2 (python):
```python
import { redirect, RedirectType } from 'next/navigation'
 
redirect('/redirect-to', RedirectType.replace)
// or
redirect('/redirect-to', RedirectType.push)
```

Example 3 (python):
```python
import { redirect } from 'next/navigation'
 
async function fetchTeam(id: string) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const team = await fetchTeam(id)
 
  if (!team) {
    redirect('/login')
  }
 
  // ...
}
```

Example 4 (python):
```python
'use client'
 
import { redirect, usePathname } from 'next/navigation'
 
export function ClientRedirect() {
  const pathname = usePathname()
 
  if (pathname.startsWith('/admin') && !pathname.includes('/login')) {
    redirect('/admin/login')
  }
 
  return <div>Login Page</div>
}
```

---

## How to load and optimize scripts

**URL:** https://nextjs.org/docs/15/app/guides/scripts

**Contents:**
- How to load and optimize scripts
  - Layout Scripts
  - Application Scripts
  - Strategy
  - Offloading Scripts To A Web Worker (experimental)
  - Inline Scripts
  - Executing Additional Code
  - Additional Attributes
- API Reference
  - Script Component

To load a third-party script for multiple routes, import next/script and include the script directly in your layout component:

The third-party script is fetched when the folder route (e.g. dashboard/page.js) or any nested route (e.g. dashboard/settings/page.js) is accessed by the user. Next.js will ensure the script will only load once, even if a user navigates between multiple routes in the same layout.

To load a third-party script for all routes, import next/script and include the script directly in your root layout:

This script will load and execute when any route in your application is accessed. Next.js will ensure the script will only load once, even if a user navigates between multiple pages.

Recommendation: We recommend only including third-party scripts in specific pages or layouts in order to minimize any unnecessary impact to performance.

Although the default behavior of next/script allows you to load third-party scripts in any page or layout, you can fine-tune its loading behavior by using the strategy property:

Refer to the next/script API reference documentation to learn more about each strategy and their use cases.

Warning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution.

Scripts that use the worker strategy are offloaded and executed in a web worker with Partytown. This can improve the performance of your site by dedicating the main thread to the rest of your application code.

This strategy is still experimental and can only be used if the nextScriptWorkers flag is enabled in next.config.js:

Then, run next (normally npm run dev or yarn dev) and Next.js will guide you through the installation of the required packages to finish the setup:

You'll see instructions like these: Please install Partytown by running npm install @builder.io/partytown

Once setup is complete, defining strategy="worker" will automatically instantiate Partytown in your application and offload the script to a web worker.

There are a number of trade-offs that need to be considered when loading a third-party script in a web worker. Please see Partytown's tradeoffs documentation for more information.

Inline scripts, or scripts not loaded from an external file, are also supported by the Script component. They can be written by placing the JavaScript within curly braces:

Or by using the dangerouslySetInnerHTML property:

Warning: An id property must be assigned for inline scripts in order for Next.js to track and optimize the script.

Event handlers can be used with the Script component to execute additional code after a certain event occurs:

These handlers will only work when next/script is imported and used inside of a Client Component where "use client" is defined as the first line of code:

Refer to the next/script API reference to learn more about each event handler and view examples.

There are many DOM attributes that can be assigned to a <script> element that are not used by the Script component, like nonce or custom data attributes. Including any additional attributes will automatically forward it to the final, optimized <script> element that is included in the HTML.

**Examples:**

Example 1 (python):
```python
import Script from 'next/script'
 
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <>
      <section>{children}</section>
      <Script src="https://example.com/script.js" />
    </>
  )
}
```

Example 2 (python):
```python
import Script from 'next/script'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
      <Script src="https://example.com/script.js" />
    </html>
  )
}
```

Example 3 (unknown):
```unknown
module.exports = {
  experimental: {
    nextScriptWorkers: true,
  },
}
```

Example 4 (unknown):
```unknown
npm run dev
```

---

## use client

**URL:** https://nextjs.org/docs/app/api-reference/directives/use-client

**Contents:**
- use client
- Usage
- Nesting Client Components within Server Components
- Reference

The 'use client' directive declares an entry point for the components to be rendered on the client side and should be used when creating interactive user interfaces (UI) that require client-side JavaScript capabilities, such as state management, event handling, and access to browser APIs. This is a React feature.

You do not need to add the 'use client' directive to every file that contains Client Components. You only need to add it to the files whose components you want to render directly within Server Components. The 'use client' directive defines the client-server boundary, and the components exported from such a file serve as entry points to the client.

To declare an entry point for the Client Components, add the 'use client' directive at the top of the file, before any imports:

When using the 'use client' directive, the props of the Client Components must be serializable. This means the props need to be in a format that React can serialize when sending data from the server to the client.

Combining Server and Client Components allows you to build applications that are both performant and interactive:

In the following example:

See the React documentation for more information on 'use client'.

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useState } from 'react'
 
export default function Counter() {
  const [count, setCount] = useState(0)
 
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  )
}
```

Example 2 (unknown):
```unknown
'use client'
 
export default function Counter({
  onClick /* âŒ Function is not serializable */,
}) {
  return (
    <div>
      <button onClick={onClick}>Increment</button>
    </div>
  )
}
```

Example 3 (python):
```python
import Header from './header'
import Counter from './counter' // This is a Client Component
 
export default function Page() {
  return (
    <div>
      <Header />
      <Counter />
    </div>
  )
}
```

---

## Link Component

**URL:** https://nextjs.org/docs/app/api-reference/components/link

**Contents:**
- Link Component
- Reference
  - href (required)
  - replace
  - scroll
  - prefetch
  - onNavigate
- Examples
  - Linking to dynamic route segments
  - Checking active links

<Link> is a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.

The following props can be passed to the <Link> component:

Good to know: <a> tag attributes such as className or target="_blank" can be added to <Link> as props and will be passed to the underlying <a> element.

The path or URL to navigate to.

Defaults to false. When true, next/link will replace the current history state instead of adding a new URL into the browser's history stack.

Defaults to true. The default scrolling behavior of <Link> in Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element.

When scroll = {false}, Next.js will not attempt to scroll to the first Page element.

Good to know: Next.js checks if scroll: false before managing scroll behavior. If scrolling is enabled, it identifies the relevant DOM node for navigation and inspects each top-level element. All non-scrollable elements and those without rendered HTML are bypassed, this includes sticky or fixed positioned elements, and non-visible elements such as those calculated with getBoundingClientRect. Next.js then continues through siblings until it identifies a scrollable element that is visible in the viewport.

Prefetching happens when a <Link /> component enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by the href) and its data in the background to improve the performance of client-side navigations. If the prefetched data has expired by the time the user hovers over a <Link />, Next.js will attempt to prefetch it again. Prefetching is only enabled in production.

The following values can be passed to the prefetch prop:

An event handler called during client-side navigation. The handler receives an event object that includes a preventDefault() method, allowing you to cancel the navigation if needed.

Good to know: While onClick and onNavigate may seem similar, they serve different purposes. onClick executes for all click events, while onNavigate only runs during client-side navigation. Some key differences:

The following examples demonstrate how to use the <Link> component in different scenarios.

When linking to dynamic segments, you can use template literals and interpolation to generate a list of links. For example, to generate a list of blog posts:

You can use usePathname() to determine if a link is active. For example, to add a class to the active link, you can check if the current pathname matches the href of the link:

If you'd like to scroll to a specific id on navigation, you can append your URL with a # hash link or just pass a hash link to the href prop. This is possible since <Link> renders to an <a> element.

The default behavior of the Link component is to push a new URL into the history stack. You can use the replace prop to prevent adding a new entry, as in the following example:

The default scrolling behavior of <Link> in Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport.

However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element. If you'd like to disable this behavior, you can pass scroll={false} to the <Link> component, or scroll: false to router.push() or router.replace().

Using router.push() or router.replace():

It's common to use Proxy for authentication or other purposes that involve rewriting the user to a different page. In order for the <Link /> component to properly prefetch links with rewrites via Proxy, you need to tell Next.js both the URL to display and the URL to prefetch. This is required to avoid un-necessary fetches to proxy to know the correct route to prefetch.

For example, if you want to serve a /dashboard route that has authenticated and visitor views, you can add the following in your Proxy to redirect the user to the correct page:

In this case, you would want to use the following code in your <Link /> component:

You can use the onNavigate prop to block navigation when certain conditions are met, such as when a form has unsaved changes. When you need to block navigation across multiple components in your app (like preventing navigation from any link while a form is being edited), React Context provides a clean way to share this blocking state. First, create a context to track the navigation blocking state:

Create a form component that uses the context:

Create a custom Link component that blocks navigation:

Create a navigation component:

Finally, wrap your app with the NavigationBlockerProvider in the root layout and use the components in your page:

Then, use the Nav and Form components in your page:

When a user tries to navigate away using CustomLink while the form has unsaved changes, they'll be prompted to confirm before leaving.

**Examples:**

Example 1 (python):
```python
import Link from 'next/link'
 
export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

Example 2 (python):
```python
import Link from 'next/link'
 
// Navigate to /about?name=test
export default function Page() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

Example 3 (python):
```python
import Link from 'next/link'
 
export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

Example 4 (python):
```python
import Link from 'next/link'
 
export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

---

## Components

**URL:** https://nextjs.org/docs/15/app/api-reference/components

**Contents:**
- Components
  - Font
  - Form Component
  - Image Component
  - Link Component
  - Script Component

---

## use server

**URL:** https://nextjs.org/docs/app/api-reference/directives/use-server

**Contents:**
- use server
- Using use server at the top of a file
  - Using Server Functions in a Client Component
- Using use server inline
- Security considerations
  - Authentication and authorization
- Reference

The use server directive designates a function or file to be executed on the server side. It can be used at the top of a file to indicate that all functions in the file are server-side, or inline at the top of a function to mark the function as a Server Function. This is a React feature.

The following example shows a file with a use server directive at the top. All functions in the file are executed on the server.

To use Server Functions in Client Components you need to create your Server Functions in a dedicated file using the use server directive at the top of the file. These Server Functions can then be imported into Client and Server Components and executed.

Assuming you have a fetchUsers Server Function in actions.ts:

Then you can import the fetchUsers Server Function into a Client Component and execute it on the client-side.

In the following example, use server is used inline at the top of a function to mark it as a Server Function:

When using the use server directive, it's important to ensure that all server-side logic is secure and that sensitive data remains protected.

Always authenticate and authorize users before performing sensitive server-side operations.

See the React documentation for more information on use server.

**Examples:**

Example 1 (python):
```python
'use server'
import { db } from '@/lib/db' // Your database client
 
export async function createUser(data: { name: string; email: string }) {
  const user = await db.user.create({ data })
  return user
}
```

Example 2 (python):
```python
'use server'
import { db } from '@/lib/db' // Your database client
 
export async function fetchUsers() {
  const users = await db.user.findMany()
  return users
}
```

Example 3 (python):
```python
'use client'
import { fetchUsers } from '../actions'
 
export default function MyButton() {
  return <button onClick={() => fetchUsers()}>Fetch Users</button>
}
```

Example 4 (python):
```python
import { EditPost } from './edit-post'
import { revalidatePath } from 'next/cache'
 
export default async function PostPage({ params }: { params: { id: string } }) {
  const post = await getPost(params.id)
 
  async function updatePost(formData: FormData) {
    'use server'
    await savePost(params.id, formData)
    revalidatePath(`/posts/${params.id}`)
  }
 
  return <EditPost updatePostAction={updatePost} post={post} />
}
```

---

## How to create forms with API Routes

**URL:** https://nextjs.org/docs/pages/guides/forms

**Contents:**
- How to create forms with API Routes
- Server Forms
- Form validation
  - Error handling
- Displaying loading state
  - Redirecting

Forms enable you to create and update data in web applications. Next.js provides a powerful way to handle data mutations using API Routes. This guide will walk you through how to handle form submission on the server.

To handle form submissions on the server, create an API endpoint that securely mutates data.

Then, call the API Route from the client with an event handler:

We recommend using HTML validation like required and type="email" for basic client-side form validation.

For more advanced server-side validation, you can use a schema validation library like zod to validate the form fields before mutating the data:

You can use React state to show an error message when a form submission fails:

You can use React state to show a loading state when a form is submitting on the server:

If you would like to redirect the user to a different route after a mutation, you can redirect to any absolute or relative URL:

**Examples:**

Example 1 (python):
```python
import type { NextApiRequest, NextApiResponse } from 'next'
 
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const data = req.body
  const id = await createItem(data)
  res.status(200).json({ id })
}
```

Example 2 (python):
```python
import { FormEvent } from 'react'
 
export default function Page() {
  async function onSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()
 
    const formData = new FormData(event.currentTarget)
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: formData,
    })
 
    // Handle response if necessary
    const data = await response.json()
    // ...
  }
 
  return (
    <form onSubmit={onSubmit}>
      <input type="text" name="name" />
      <button type="submit">Submit</button>
    </form>
  )
}
```

Example 3 (python):
```python
import type { NextApiRequest, NextApiResponse } from 'next'
import { z } from 'zod'
 
const schema = z.object({
  // ...
})
 
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const parsed = schema.parse(req.body)
  // ...
}
```

Example 4 (python):
```python
import React, { useState, FormEvent } from 'react'
 
export default function Page() {
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)
 
  async function onSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()
    setIsLoading(true)
    setError(null) // Clear previous errors when a new request starts
 
    try {
      const formData = new FormData(event.currentTarget)
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: formData,
      })
 
      if (!response.ok) {
        throw new Error('Failed to submit the data. Please try again.')
      }
 
      // Handle response if necessary
      const data = await response.json()
      // ...
    } catch (error) {
      // Capture the error message to display to the user
      setError(error.message)
      console.error(error)
    } finally {
      setIsLoading(false)
    }
  }
 
  return (
    <div>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={onSubmit}>
        <input type="text" name="name" />
        <button type="submit" disabled={isLoading}>
          {isLoading ? 'Loading...' : 'Submit'}
        </button>
      </form>
    </div>
  )
}
```

---

## Internationalization

**URL:** https://nextjs.org/docs/app/guides/internationalization

**Contents:**
- Internationalization
- Terminology
- Routing Overview
- Localization
- Static Rendering
- Resources

Next.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to different locales includes translated content (localization) and internationalized routes.

Itâ€™s recommended to use the userâ€™s language preferences in the browser to select which locale to use. Changing your preferred language will modify the incoming Accept-Language header to your application.

For example, using the following libraries, you can look at an incoming Request to determine which locale to select, based on the Headers, locales you plan to support, and the default locale.

Routing can be internationalized by either the sub-path (/fr/products) or domain (my-site.fr/products). With this information, you can now redirect the user based on the locale inside Proxy.

Finally, ensure all special files inside app/ are nested under app/[lang]. This enables the Next.js router to dynamically handle different locales in the route, and forward the lang parameter to every layout and page. For example:

The root layout can also be nested in the new folder (e.g. app/[lang]/layout.js).

Changing displayed content based on the userâ€™s preferred locale, or localization, is not something specific to Next.js. The patterns described below would work the same with any web application.

Letâ€™s assume we want to support both English and Dutch content inside our application. We might maintain two different â€œdictionariesâ€, which are objects that give us a mapping from some key to a localized string. For example:

We can then create a getDictionary function to load the translations for the requested locale:

Given the currently selected language, we can fetch the dictionary inside of a layout or page.

Because all layouts and pages in the app/ directory default to Server Components, we do not need to worry about the size of the translation files affecting our client-side JavaScript bundle size. This code will only run on the server, and only the resulting HTML will be sent to the browser.

To generate static routes for a given set of locales, we can use generateStaticParams with any page or layout. This can be global, for example, in the root layout:

**Examples:**

Example 1 (python):
```python
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'
 
let headers = { 'accept-language': 'en-US,en;q=0.5' }
let languages = new Negotiator({ headers }).languages()
let locales = ['en-US', 'nl-NL', 'nl']
let defaultLocale = 'en-US'
 
match(languages, locales, defaultLocale) // -> 'en-US'
```

Example 2 (python):
```python
import { NextResponse } from "next/server";
 
let locales = ['en-US', 'nl-NL', 'nl']
 
// Get the preferred locale, similar to the above or using a library
function getLocale(request) { ... }
 
export function proxy(request) {
  // Check if there is any supported locale in the pathname
  const { pathname } = request.nextUrl
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )
 
  if (pathnameHasLocale) return
 
  // Redirect if there is no locale
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`
  // e.g. incoming request is /products
  // The new URL is now /en-US/products
  return NextResponse.redirect(request.nextUrl)
}
 
export const config = {
  matcher: [
    // Skip all internal paths (_next)
    '/((?!_next).*)',
    // Optional: only run on root (/) URL
    // '/'
  ],
}
```

Example 3 (javascript):
```javascript
// You now have access to the current locale
// e.g. /en-US/products -> `lang` is "en-US"
export default async function Page({
  params,
}: {
  params: Promise<{ lang: string }>
}) {
  const { lang } = await params
  return ...
}
```

Example 4 (unknown):
```unknown
{
  "products": {
    "cart": "Add to Cart"
  }
}
```

---

## How to add analytics to your Next.js application

**URL:** https://nextjs.org/docs/15/app/guides/analytics

**Contents:**
- How to add analytics to your Next.js application
- Client Instrumentation
- Build Your Own
- Web Vitals
- Sending results to external systems

Next.js has built-in support for measuring and reporting performance metrics. You can either use the useReportWebVitals hook to manage reporting yourself, or alternatively, Vercel provides a managed service to automatically collect and visualize metrics for you.

For more advanced analytics and monitoring needs, Next.js provides a instrumentation-client.js|ts file that runs before your application's frontend code starts executing. This is ideal for setting up global analytics, error tracking, or performance monitoring tools.

To use it, create an instrumentation-client.js or instrumentation-client.ts file in your application's root directory:

Since the useReportWebVitals hook requires the 'use client' directive, the most performant approach is to create a separate component that the root layout imports. This confines the client boundary exclusively to the WebVitals component.

View the API Reference for more information.

Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:

You can handle all the results of these metrics using the name property.

You can send results to any endpoint to measure and track real user performance on your site. For example:

Good to know: If you use Google Analytics, using the id value can allow you to construct metric distributions manually (to calculate percentiles, etc.)

Read more about sending results to Google Analytics.

**Examples:**

Example 1 (javascript):
```javascript
// Initialize analytics before the app starts
console.log('Analytics initialized')
 
// Set up global error tracking
window.addEventListener('error', (event) => {
  // Send to your error tracking service
  reportError(event.error)
})
```

Example 2 (python):
```python
'use client'
 
import { useReportWebVitals } from 'next/web-vitals'
 
export function WebVitals() {
  useReportWebVitals((metric) => {
    console.log(metric)
  })
}
```

Example 3 (python):
```python
import { WebVitals } from './_components/web-vitals'
 
export default function Layout({ children }) {
  return (
    <html>
      <body>
        <WebVitals />
        {children}
      </body>
    </html>
  )
}
```

Example 4 (python):
```python
'use client'
 
import { useReportWebVitals } from 'next/web-vitals'
 
export function WebVitals() {
  useReportWebVitals((metric) => {
    switch (metric.name) {
      case 'FCP': {
        // handle FCP results
      }
      case 'LCP': {
        // handle LCP results
      }
      // ...
    }
  })
}
```

---

## fetch

**URL:** https://nextjs.org/docs/app/api-reference/functions/fetch

**Contents:**
- fetch
- fetch(url, options)
  - options.cache
  - options.next.revalidate
  - options.next.tags
- Troubleshooting
  - Fetch default auto no store and cache: 'no-store' not showing fresh data in development
  - Hard refresh and caching in development
- Version History

Next.js extends the Web fetch() API to allow each request on the server to set its own persistent caching and revalidation semantics.

In the browser, the cache option indicates how a fetch request will interact with the browser's HTTP cache. With this extension, cache indicates how a server-side fetch request will interact with the framework's persistent Data Cache.

You can call fetch with async and await directly within Server Components.

Since Next.js extends the Web fetch() API, you can use any of the native options available.

Configure how the request should interact with Next.js Data Cache.

Set the cache lifetime of a resource (in seconds). Data Cache.

Set the cache tags of a resource. Data can then be revalidated on-demand using revalidateTag. The max length for a custom tag is 256 characters and the max tag items is 128.

Next.js caches fetch responses in Server Components across Hot Module Replacement (HMR) in local development for faster responses and to reduce costs for billed API calls.

By default, the HMR cache applies to all fetch requests, including those with the default auto no cache and cache: 'no-store' option. This means uncached requests will not show fresh data between HMR refreshes. However, the cache will be cleared on navigation or full-page reloads.

See the serverComponentsHmrCache docs for more information.

In development mode, if the request includes the cache-control: no-cache header, options.cache, options.next.revalidate, and options.next.tags are ignored, and the fetch request is served from the source.

Browsers typically include cache-control: no-cache when the cache is disabled in developer tools or during a hard refresh.

**Examples:**

Example 1 (javascript):
```javascript
export default async function Page() {
  let data = await fetch('https://api.vercel.app/blog')
  let posts = await data.json()
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

Example 2 (unknown):
```unknown
fetch(`https://...`, { cache: 'force-cache' | 'no-store' })
```

Example 3 (unknown):
```unknown
fetch(`https://...`, { next: { revalidate: false | 0 | number } })
```

Example 4 (unknown):
```unknown
fetch(`https://...`, { next: { tags: ['collection'] } })
```

---

## taint

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/taint

**Contents:**
- taint
- Usage
- Caveats
- Examples
  - Tainting an object reference
  - Tainting a unique value

The taint option enables support for experimental React APIs for tainting objects and values. This feature helps prevent sensitive data from being accidentally passed to the client. When enabled, you can use:

Good to know: Activating this flag also enables the React experimental channel for app directory.

Warning: Do not rely on the taint API as your only mechanism to prevent exposing sensitive data to the client. See our security recommendations.

The taint APIs allows you to be defensive, by declaratively and explicitly marking data that is not allowed to pass through the Server-Client boundary. When an object or value, is passed through the Server-Client boundary, React throws an error.

This is helpful for cases where:

It is recommended to model your data and APIs so that sensitive data is not returned to contexts where it is not needed.

In this case, the getUserDetails function returns data about a given user. We taint the user object reference, so that it cannot cross a Server-Client boundary. For example, assuming UserCard is a Client Component.

We can still access individual fields from the tainted userDetails object.

Now, passing the entire object to the Client Component will throw an error.

In this case, we can access the server configuration by awaiting calls to config.getConfigDetails. However, the system configuration contains the SERVICE_API_KEY that we don't want to expose to clients.

We can taint the config.SERVICE_API_KEY value.

We can still access other properties of the systemConfig object.

However, passing SERVICE_API_KEY to ClientDashboard throws an error.

Note that, even though, systemConfig.SERVICE_API_KEY is reassigned to a new variable. Passing it to a Client Component still throws an error.

Whereas, a value derived from a tainted unique value, will be exposed to the client.

A better approach is to remove SERVICE_API_KEY from the data returned by getSystemConfig.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    taint: true,
  },
}
 
export default nextConfig
```

Example 2 (python):
```python
import { experimental_taintObjectReference } from 'react'
 
function getUserDetails(id: string): UserDetails {
  const user = await db.queryUserById(id)
 
  experimental_taintObjectReference(
    'Do not use the entire user info object. Instead, select only the fields you need.',
    user
  )
 
  return user
}
```

Example 3 (javascript):
```javascript
export async function ContactPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const userDetails = await getUserDetails(id)
 
  return (
    <UserCard
      firstName={userDetails.firstName}
      lastName={userDetails.lastName}
    />
  )
}
```

Example 4 (javascript):
```javascript
export async function ContactPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const userDetails = await getUserDetails(id)
 
  // Throws an error
  return <UserCard user={userDetails} />
}
```

---

## notFound

**URL:** https://nextjs.org/docs/app/api-reference/functions/not-found

**Contents:**
- notFound
- notFound()
- Version History

The notFound function allows you to render the not-found file within a route segment as well as inject a <meta name="robots" content="noindex" /> tag.

Invoking the notFound() function throws a NEXT_HTTP_ERROR_FALLBACK;404 error and terminates rendering of the route segment in which it was thrown. Specifying a not-found file allows you to gracefully handle such errors by rendering a Not Found UI within the segment.

Good to know: notFound() does not require you to use return notFound() due to using the TypeScript never type.

**Examples:**

Example 1 (python):
```python
import { notFound } from 'next/navigation'
 
async function fetchUser(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({ params }) {
  const { id } = await params
  const user = await fetchUser(id)
 
  if (!user) {
    notFound()
  }
 
  // ...
}
```

---

## revalidateTag

**URL:** https://nextjs.org/docs/app/api-reference/functions/revalidateTag

**Contents:**
- revalidateTag
- Usage
  - Revalidation Behavior
- Parameters
- Returns
- Relationship with revalidatePath
- Examples
  - Server Action
  - Route Handler

revalidateTag allows you to invalidate cached data on-demand for a specific cache tag.

This function is ideal for content where a slight delay in updates is acceptable, such as blog posts, product catalogs, or documentation. Users receive stale content while fresh data loads in the background.

revalidateTag can be called in Server Functions and Route Handlers.

revalidateTag cannot be called in Client Components or Proxy, as it only works in server environments.

The revalidation behavior depends on whether you provide the second argument:

Good to know: When using profile="max", revalidateTag marks tagged data as stale, but fresh data is only fetched when pages using that tag are next visited. This means calling revalidateTag will not immediately trigger many revalidations at once. The invalidation only happens when any page using that tag is next visited.

Tags must first be assigned to cached data. You can do this in two ways:

Good to know: The single-argument form revalidateTag(tag) is deprecated. It currently works if TypeScript errors are suppressed, but this behavior may be removed in a future version. Update to the two-argument signature.

revalidateTag does not return a value.

revalidateTag invalidates data with specific tags across all pages that use those tags, while revalidatePath invalidates specific page or layout paths.

Good to know: These functions serve different purposes and may need to be used together for comprehensive data consistency. For detailed examples and considerations, see relationship with revalidateTag and updateTag for more information.

The following examples demonstrate how to use revalidateTag in different contexts. In both cases, we're using profile="max" to mark data as stale and use stale-while-revalidate semantics, which is the recommended approach for most use cases.

Good to know: For webhooks or third-party services that need immediate expiration, you can pass { expire: 0 } as the second argument: revalidateTag(tag, { expire: 0 }). This pattern is necessary when external systems call your Route Handlers and require data to expire immediately. For all other cases, it's recommended to use updateTag in Server Actions for immediate updates instead.

**Examples:**

Example 1 (unknown):
```unknown
revalidateTag(tag: string, profile: string | { expire?: number }): void;
```

Example 2 (unknown):
```unknown
fetch(url, { next: { tags: ['posts'] } })
```

Example 3 (python):
```python
import { cacheTag } from 'next/cache'
 
async function getData() {
  'use cache'
  cacheTag('posts')
  // ...
}
```

Example 4 (python):
```python
'use server'
 
import { revalidateTag } from 'next/cache'
 
export default async function submit() {
  await addPost()
  revalidateTag('posts', 'max')
}
```

---

## How to create a static export of your Next.js application

**URL:** https://nextjs.org/docs/15/app/guides/static-exports

**Contents:**
- How to create a static export of your Next.js application
- Configuration
- Supported Features
  - Server Components
  - Client Components
  - Image Optimization
  - Route Handlers
  - Browser APIs
- Unsupported Features
- Deploying

Next.js enables starting as a static site or Single-Page Application (SPA), then later optionally upgrading to use features that require a server.

When running next build, Next.js generates an HTML file per route. By breaking a strict SPA into individual HTML files, Next.js can avoid loading unnecessary JavaScript code on the client-side, reducing the bundle size and enabling faster page loads.

Since Next.js supports this static export, it can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.

To enable a static export, change the output mode inside next.config.js:

After running next build, Next.js will create an out folder with the HTML/CSS/JS assets for your application.

The core of Next.js has been designed to support static exports.

When you run next build to generate a static export, Server Components consumed inside the app directory will run during the build, similar to traditional static-site generation.

The resulting component will be rendered into static HTML for the initial page load and a static payload for client navigation between routes. No changes are required for your Server Components when using the static export, unless they consume dynamic server functions.

If you want to perform data fetching on the client, you can use a Client Component with SWR to memoize requests.

Since route transitions happen client-side, this behaves like a traditional SPA. For example, the following index route allows you to navigate to different posts on the client:

Image Optimization through next/image can be used with a static export by defining a custom image loader in next.config.js. For example, you can optimize images with a service like Cloudinary:

This custom loader will define how to fetch images from a remote source. For example, the following loader will construct the URL for Cloudinary:

You can then use next/image in your application, defining relative paths to the image in Cloudinary:

Route Handlers will render a static response when running next build. Only the GET HTTP verb is supported. This can be used to generate static HTML, JSON, TXT, or other files from cached or uncached data. For example:

The above file app/data.json/route.ts will render to a static file during next build, producing data.json containing { name: 'Lee' }.

If you need to read dynamic values from the incoming request, you cannot use a static export.

Client Components are pre-rendered to HTML during next build. Because Web APIs like window, localStorage, and navigator are not available on the server, you need to safely access these APIs only when running in the browser. For example:

Features that require a Node.js server, or dynamic logic that cannot be computed during the build process, are not supported:

Attempting to use any of these features with next dev will result in an error, similar to setting the dynamic option to error in the root layout.

With a static export, Next.js can be deployed and hosted on any web server that can serve HTML/CSS/JS static assets.

When running next build, Next.js generates the static export into the out folder. For example, let's say you have the following routes:

After running next build, Next.js will generate the following files:

If you are using a static host like Nginx, you can configure rewrites from incoming requests to the correct files:

**Examples:**

Example 1 (javascript):
```javascript
/**
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  output: 'export',
 
  // Optional: Change links `/me` -> `/me/` and emit `/me.html` -> `/me/index.html`
  // trailingSlash: true,
 
  // Optional: Prevent automatic `/me` -> `/me/`, instead preserve `href`
  // skipTrailingSlashRedirect: true,
 
  // Optional: Change the output directory `out` -> `dist`
  // distDir: 'dist',
}
 
module.exports = nextConfig
```

Example 2 (javascript):
```javascript
export default async function Page() {
  // This fetch will run on the server during `next build`
  const res = await fetch('https://api.example.com/...')
  const data = await res.json()
 
  return <main>...</main>
}
```

Example 3 (python):
```python
'use client'
 
import useSWR from 'swr'
 
const fetcher = (url: string) => fetch(url).then((r) => r.json())
 
export default function Page() {
  const { data, error } = useSWR(
    `https://jsonplaceholder.typicode.com/posts/1`,
    fetcher
  )
  if (error) return 'Failed to load'
  if (!data) return 'Loading...'
 
  return data.title
}
```

Example 4 (python):
```python
import Link from 'next/link'
 
export default function Page() {
  return (
    <>
      <h1>Index Page</h1>
      <hr />
      <ul>
        <li>
          <Link href="/post/1">Post 1</Link>
        </li>
        <li>
          <Link href="/post/2">Post 2</Link>
        </li>
      </ul>
    </>
  )
}
```

---

## authInterrupts

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/authInterrupts

**Contents:**
- authInterrupts
- Next Steps
  - forbidden
  - unauthorized
  - forbidden.js
  - unauthorized.js

The authInterrupts configuration option allows you to use forbidden and unauthorized APIs in your application. While these functions are experimental, you must enable the authInterrupts option in your next.config.js file to use them:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    authInterrupts: true,
  },
}
 
export default nextConfig
```

---

## API Reference

**URL:** https://nextjs.org/docs/15/app/api-reference

**Contents:**
- API Reference
  - Directives
  - Components
  - File-system conventions
  - Functions
  - Configuration
  - CLI
  - Edge Runtime
  - Turbopack

---

## No Duplicate Head

**URL:** https://nextjs.org/docs/messages/no-duplicate-head

**Contents:**
- No Duplicate Head
- Why This Error Occurred
- Possible Ways to Fix It
- Useful Links

Prevent duplicate usage of <Head> in pages/_document.js.

More than a single instance of the <Head /> component was used in a single custom document. This can cause unexpected behavior in your application.

Only use a single <Head /> component in your custom document in pages/_document.js.

**Examples:**

Example 1 (python):
```python
import Document, { Html, Head, Main, NextScript } from 'next/document'
 
class MyDocument extends Document {
  static async getInitialProps(ctx) {
    //...
  }
 
  render() {
    return (
      <Html>
        <Head />
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    )
  }
}
 
export default MyDocument
```

---

## Functions

**URL:** https://nextjs.org/docs/15/app/api-reference/functions

**Contents:**
- Functions
  - after
  - cacheLife
  - cacheTag
  - connection
  - cookies
  - draftMode
  - fetch
  - forbidden
  - generateImageMetadata

---

## How to implement authentication in Next.js

**URL:** https://nextjs.org/docs/pages/guides/authentication

**Contents:**
- How to implement authentication in Next.js
- Authentication
- Session Management
  - Stateless Sessions
    - Setting and deleting cookies
  - Database Sessions
- Authorization
  - Optimistic checks with Proxy (Optional)
  - Creating a Data Access Layer (DAL)
    - Protecting API Routes

Understanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth.

Before starting, it helps to break down the process into three concepts:

This diagram shows the authentication flow using React and Next.js features:

The examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the Auth Libraries section.

Here are the steps to implement a sign-up and/or login form:

Consider a login form where users can input their credentials:

The form above has two input fields for capturing the user's email and password. On submission, it triggers a function that sends a POST request to an API route (/api/auth/login).

You can then call your Authentication Provider's API in the API route to handle authentication:

Session management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens.

There are two types of sessions:

Good to know: While you can use either method, or both, we recommend using a session management library such as iron-session or Jose.

You can use API Routes to set the session as a cookie on the server:

To create and manage database sessions, you'll need to follow these steps:

Creating a Session on the Server:

Once a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application.

There are two main types of authorization checks:

For both cases, we recommend:

There are some cases where you may want to use Proxy and redirect users based on permissions:

However, since Proxy runs on every route, including prefetched routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues.

While Proxy can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information.

API Routes in Next.js are essential for handling server-side logic and data management. It's crucial to secure these routes to ensure that only authorized users can access specific functionalities. This typically involves verifying the user's authentication status and their role-based permissions.

Here's an example of securing an API Route:

This example demonstrates an API Route with a two-tier security check for authentication and authorization. It first checks for an active session, and then verifies if the logged-in user is an 'admin'. This approach ensures secure access, limited to authenticated and authorized users, maintaining robust security for request processing.

Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:

To continue learning about authentication and security, check out the following resources:

**Examples:**

Example 1 (python):
```python
import { FormEvent } from 'react'
import { useRouter } from 'next/router'
 
export default function LoginPage() {
  const router = useRouter()
 
  async function handleSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()
 
    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    const password = formData.get('password')
 
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    })
 
    if (response.ok) {
      router.push('/profile')
    } else {
      // Handle errors
    }
  }
 
  return (
    <form onSubmit={handleSubmit}>
      <input type="email" name="email" placeholder="Email" required />
      <input type="password" name="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
  )
}
```

Example 2 (python):
```python
import type { NextApiRequest, NextApiResponse } from 'next'
import { signIn } from '@/auth'
 
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { email, password } = req.body
    await signIn('credentials', { email, password })
 
    res.status(200).json({ success: true })
  } catch (error) {
    if (error.type === 'CredentialsSignin') {
      res.status(401).json({ error: 'Invalid credentials.' })
    } else {
      res.status(500).json({ error: 'Something went wrong.' })
    }
  }
}
```

Example 3 (python):
```python
import { serialize } from 'cookie'
import type { NextApiRequest, NextApiResponse } from 'next'
import { encrypt } from '@/app/lib/session'
 
export default function handler(req: NextApiRequest, res: NextApiResponse) {
  const sessionData = req.body
  const encryptedSessionData = encrypt(sessionData)
 
  const cookie = serialize('session', encryptedSessionData, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    maxAge: 60 * 60 * 24 * 7, // One week
    path: '/',
  })
  res.setHeader('Set-Cookie', cookie)
  res.status(200).json({ message: 'Successfully set cookie!' })
}
```

Example 4 (python):
```python
import db from '../../lib/db'
import type { NextApiRequest, NextApiResponse } from 'next'
 
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const user = req.body
    const sessionId = generateSessionId()
    await db.insertSession({
      sessionId,
      userId: user.id,
      createdAt: new Date(),
    })
 
    res.status(200).json({ sessionId })
  } catch (error) {
    res.status(500).json({ error: 'Internal Server Error' })
  }
}
```

---

## How to optimize third-party libraries

**URL:** https://nextjs.org/docs/15/app/guides/third-party-libraries

**Contents:**
- How to optimize third-party libraries
- Getting Started
- Google Third-Parties
  - Google Tag Manager
    - Sending Events
    - Server-side Tagging
    - Options
  - Google Analytics
    - Sending Events
    - Tracking Pageviews

@next/third-parties is a library that provides a collection of components and utilities that improve the performance and developer experience of loading popular third-party libraries in your Next.js application.

All third-party integrations provided by @next/third-parties have been optimized for performance and ease of use.

To get started, install the @next/third-parties library:

@next/third-parties is currently an experimental library under active development. We recommend installing it with the latest or canary flags while we work on adding more third-party integrations.

All supported third-party libraries from Google can be imported from @next/third-parties/google.

The GoogleTagManager component can be used to instantiate a Google Tag Manager container to your page. By default, it fetches the original inline script after hydration occurs on the page.

To load Google Tag Manager for all routes, include the component directly in your root layout and pass in your GTM container ID:

To load Google Tag Manager for a single route, include the component in your page file:

The sendGTMEvent function can be used to track user interactions on your page by sending events using the dataLayer object. For this function to work, the <GoogleTagManager /> component must be included in either a parent layout, page, or component, or directly in the same file.

Refer to the Tag Manager developer documentation to learn about the different variables and events that can be passed into the function.

If you're using a server-side tag manager and serving gtm.js scripts from your tagging server you can use gtmScriptUrl option to specify the URL of the script.

Options to pass to the Google Tag Manager. For a full list of options, read the Google Tag Manager docs.

The GoogleAnalytics component can be used to include Google Analytics 4 to your page via the Google tag (gtag.js). By default, it fetches the original scripts after hydration occurs on the page.

Recommendation: If Google Tag Manager is already included in your application, you can configure Google Analytics directly using it, rather than including Google Analytics as a separate component. Refer to the documentation to learn more about the differences between Tag Manager and gtag.js.

To load Google Analytics for all routes, include the component directly in your root layout and pass in your measurement ID:

To load Google Analytics for a single route, include the component in your page file:

The sendGAEvent function can be used to measure user interactions on your page by sending events using the dataLayer object. For this function to work, the <GoogleAnalytics /> component must be included in either a parent layout, page, or component, or directly in the same file.

Refer to the Google Analytics developer documentation to learn more about event parameters.

Google Analytics automatically tracks pageviews when the browser history state changes. This means that client-side navigations between Next.js routes will send pageview data without any configuration.

To ensure that client-side navigations are being measured correctly, verify that the â€œEnhanced Measurementâ€ property is enabled in your Admin panel and the â€œPage changes based on browser history eventsâ€ checkbox is selected.

Note: If you decide to manually send pageview events, make sure to disable the default pageview measurement to avoid having duplicate data. Refer to the Google Analytics developer documentation to learn more.

Options to pass to the <GoogleAnalytics> component.

The GoogleMapsEmbed component can be used to add a Google Maps Embed to your page. By default, it uses the loading attribute to lazy-load the embed below the fold.

Options to pass to the Google Maps Embed. For a full list of options, read the Google Map Embed docs.

The YouTubeEmbed component can be used to load and display a YouTube embed. This component loads faster by using lite-youtube-embed under the hood.

**Examples:**

Example 1 (unknown):
```unknown
npm install @next/third-parties@latest next@latest
```

Example 2 (python):
```python
import { GoogleTagManager } from '@next/third-parties/google'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <GoogleTagManager gtmId="GTM-XYZ" />
      <body>{children}</body>
    </html>
  )
}
```

Example 3 (python):
```python
import { GoogleTagManager } from '@next/third-parties/google'
 
export default function Page() {
  return <GoogleTagManager gtmId="GTM-XYZ" />
}
```

Example 4 (python):
```python
'use client'
 
import { sendGTMEvent } from '@next/third-parties/google'
 
export function EventButton() {
  return (
    <div>
      <button
        onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}
      >
        Send Event
      </button>
    </div>
  )
}
```

---

## How to set up Cypress with Next.js

**URL:** https://nextjs.org/docs/app/guides/testing/cypress

**Contents:**
- How to set up Cypress with Next.js
- Quickstart
- Manual setup
- Creating your first Cypress E2E test
  - Running E2E Tests
- Creating your first Cypress component test
  - Running Component Tests
- Continuous Integration (CI)

Cypress is a test runner used for End-to-End (E2E) and Component Testing. This page will show you how to set up Cypress with Next.js and write your first tests.

You can use create-next-app with the with-cypress example to quickly get started.

To manually set up Cypress, install cypress as a dev dependency:

Add the Cypress open command to the package.json scripts field:

Run Cypress for the first time to open the Cypress testing suite:

You can choose to configure E2E Testing and/or Component Testing. Selecting any of these options will automatically create a cypress.config.js file and a cypress folder in your project.

Ensure your cypress.config file has the following configuration:

Then, create two new Next.js files:

Add a test to check your navigation is working correctly:

Cypress will simulate a user navigating your application, this requires your Next.js server to be running. We recommend running your tests against your production code to more closely resemble how your application will behave.

Run npm run build && npm run start to build your Next.js application, then run npm run cypress:open in another terminal window to start Cypress and run your E2E Testing suite.

Component tests build and mount a specific component without having to bundle your whole application or start a server.

Select Component Testing in the Cypress app, then select Next.js as your front-end framework. A cypress/component folder will be created in your project, and a cypress.config.js file will be updated to enable Component Testing.

Ensure your cypress.config file has the following configuration:

Assuming the same components from the previous section, add a test to validate a component is rendering the expected output:

Run npm run cypress:open in your terminal to start Cypress and run your Component Testing suite.

In addition to interactive testing, you can also run Cypress headlessly using the cypress run command, which is better suited for CI environments:

You can learn more about Cypress and Continuous Integration from these resources:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --example with-cypress with-cypress-app
```

Example 2 (unknown):
```unknown
npm install -D cypress
# or
yarn add -D cypress
# or
pnpm install -D cypress
```

Example 3 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "cypress:open": "cypress open"
  }
}
```

Example 4 (unknown):
```unknown
npm run cypress:open
```

---

## Client-side Fetching

**URL:** https://nextjs.org/docs/pages/building-your-application/data-fetching/client-side

**Contents:**
- Client-side Fetching
- Client-side data fetching with useEffect
- Client-side data fetching with SWR

Client-side data fetching is useful when your page doesn't require SEO indexing, when you don't need to pre-render your data, or when the content of your pages needs to update frequently. Unlike the server-side rendering APIs, you can use client-side data fetching at the component level.

If done at the page level, the data is fetched at runtime, and the content of the page is updated as the data changes. When used at the component level, the data is fetched at the time of the component mount, and the content of the component is updated as the data changes.

It's important to note that using client-side data fetching can affect the performance of your application and the load speed of your pages. This is because the data fetching is done at the time of the component or pages mount, and the data is not cached.

The following example shows how you can fetch data on the client side using the useEffect hook.

The team behind Next.js has created a React Hook library for data fetching called SWR. It is highly recommended if you are fetching data on the client-side. It handles caching, revalidation, focus tracking, refetching on intervals, and more.

Using the same example as above, we can now use SWR to fetch the profile data. SWR will automatically cache the data for us and will revalidate the data if it becomes stale.

For more information on using SWR, check out the SWR docs.

**Examples:**

Example 1 (python):
```python
import { useState, useEffect } from 'react'
 
function Profile() {
  const [data, setData] = useState(null)
  const [isLoading, setLoading] = useState(true)
 
  useEffect(() => {
    fetch('/api/profile-data')
      .then((res) => res.json())
      .then((data) => {
        setData(data)
        setLoading(false)
      })
  }, [])
 
  if (isLoading) return <p>Loading...</p>
  if (!data) return <p>No profile data</p>
 
  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.bio}</p>
    </div>
  )
}
```

Example 2 (python):
```python
import useSWR from 'swr'
 
const fetcher = (...args) => fetch(...args).then((res) => res.json())
 
function Profile() {
  const { data, error } = useSWR('/api/profile-data', fetcher)
 
  if (error) return <div>Failed to load</div>
  if (!data) return <div>Loading...</div>
 
  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.bio}</p>
    </div>
  )
}
```

---

## generateViewport

**URL:** https://nextjs.org/docs/app/api-reference/functions/generate-viewport

**Contents:**
- generateViewport
- The viewport object
- generateViewport function
- Viewport Fields
  - themeColor
  - width, initialScale, maximumScale and userScalable
  - colorScheme
- Types
  - viewport object
  - generateViewport function

You can customize the initial viewport of the page with the static viewport object or the dynamic generateViewport function.

To define the viewport options, export a viewport object from a layout.jsx or page.jsx file.

generateViewport should return a Viewport object containing one or more viewport fields.

In TypeScript, the params argument can be typed via PageProps<'/route'> or LayoutProps<'/route'> depending on where generateViewport is defined.

Learn more about theme-color.

Good to know: The viewport meta tag is automatically set, and manual configuration is usually unnecessary as the default is sufficient. However, the information is provided for completeness.

Learn more about color-scheme.

You can add type safety to your viewport object by using the Viewport type. If you are using the built-in TypeScript plugin in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want.

For JavaScript projects, you can use JSDoc to add type safety.

**Examples:**

Example 1 (python):
```python
import type { Viewport } from 'next'
 
export const viewport: Viewport = {
  themeColor: 'black',
}
 
export default function Page() {}
```

Example 2 (unknown):
```unknown
export function generateViewport({ params }) {
  return {
    themeColor: '...',
  }
}
```

Example 3 (python):
```python
import type { Viewport } from 'next'
 
export const viewport: Viewport = {
  themeColor: 'black',
}
```

Example 4 (unknown):
```unknown
<meta name="theme-color" content="black" />
```

---

## How to optimize your Next.js application for production

**URL:** https://nextjs.org/docs/15/app/guides/production-checklist

**Contents:**
- How to optimize your Next.js application for production
- Automatic optimizations
- During development
  - Routing and rendering
  - Data fetching and caching
  - UI and accessibility
  - Security
  - Metadata and SEO
  - Type safety
- Before going to production

Before taking your Next.js application to production, there are some optimizations and patterns you should consider implementing for the best user experience, performance, and security.

This page provides best practices that you can use as a reference when building your application and before going to production, as well as the automatic Next.js optimizations you should be aware of.

These Next.js optimizations are enabled by default and require no configuration:

These defaults aim to improve your application's performance, and reduce the cost and amount of data transferred on each network request.

While building your application, we recommend using the following features to ensure the best performance and user experience:

Good to know: Partial Prerendering (experimental) will allow parts of a route to be dynamic without opting the whole route into dynamic rendering.

Before going to production, you can run next build to build your application locally and catch any build errors, then run next start to measure the performance of your application in a production-like environment.

Use the @next/bundle-analyzer plugin to analyze the size of your JavaScript bundles and identify large modules and dependencies that might be impacting your application's performance.

Additionally, the following tools can help you understand the impact of adding new dependencies to your application:

---

## How to create forms with API Routes

**URL:** https://nextjs.org/docs/pages/building-your-application/data-fetching/forms-and-mutations

**Contents:**
- How to create forms with API Routes
- Server Forms
- Form validation
  - Error handling
- Displaying loading state
  - Redirecting

Forms enable you to create and update data in web applications. Next.js provides a powerful way to handle data mutations using API Routes. This guide will walk you through how to handle form submission on the server.

To handle form submissions on the server, create an API endpoint that securely mutates data.

Then, call the API Route from the client with an event handler:

We recommend using HTML validation like required and type="email" for basic client-side form validation.

For more advanced server-side validation, you can use a schema validation library like zod to validate the form fields before mutating the data:

You can use React state to show an error message when a form submission fails:

You can use React state to show a loading state when a form is submitting on the server:

If you would like to redirect the user to a different route after a mutation, you can redirect to any absolute or relative URL:

**Examples:**

Example 1 (python):
```python
import type { NextApiRequest, NextApiResponse } from 'next'
 
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const data = req.body
  const id = await createItem(data)
  res.status(200).json({ id })
}
```

Example 2 (python):
```python
import { FormEvent } from 'react'
 
export default function Page() {
  async function onSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()
 
    const formData = new FormData(event.currentTarget)
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: formData,
    })
 
    // Handle response if necessary
    const data = await response.json()
    // ...
  }
 
  return (
    <form onSubmit={onSubmit}>
      <input type="text" name="name" />
      <button type="submit">Submit</button>
    </form>
  )
}
```

Example 3 (python):
```python
import type { NextApiRequest, NextApiResponse } from 'next'
import { z } from 'zod'
 
const schema = z.object({
  // ...
})
 
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const parsed = schema.parse(req.body)
  // ...
}
```

Example 4 (python):
```python
import React, { useState, FormEvent } from 'react'
 
export default function Page() {
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)
 
  async function onSubmit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault()
    setIsLoading(true)
    setError(null) // Clear previous errors when a new request starts
 
    try {
      const formData = new FormData(event.currentTarget)
      const response = await fetch('/api/submit', {
        method: 'POST',
        body: formData,
      })
 
      if (!response.ok) {
        throw new Error('Failed to submit the data. Please try again.')
      }
 
      // Handle response if necessary
      const data = await response.json()
      // ...
    } catch (error) {
      // Capture the error message to display to the user
      setError(error.message)
      console.error(error)
    } finally {
      setIsLoading(false)
    }
  }
 
  return (
    <div>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={onSubmit}>
        <input type="text" name="name" />
        <button type="submit" disabled={isLoading}>
          {isLoading ? 'Loading...' : 'Submit'}
        </button>
      </form>
    </div>
  )
}
```

---

## How to build multi-tenant apps in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/multi-tenant

**Contents:**
- How to build multi-tenant apps in Next.js

If you are looking to build a single Next.js application that serves multiple tenants, we have built an example showing our recommended architecture.

---

## draftMode

**URL:** https://nextjs.org/docs/app/api-reference/functions/draft-mode

**Contents:**
- draftMode
- Reference
- Good to know
- Examples
  - Enabling Draft Mode
  - Disabling Draft Mode
  - Checking if Draft Mode is enabled
- Version History
- Next Steps
  - Draft Mode

draftMode is an async function allows you to enable and disable Draft Mode, as well as check if Draft Mode is enabled in a Server Component.

The following methods and properties are available:

To enable Draft Mode, create a new Route Handler and call the enable() method:

By default, the Draft Mode session ends when the browser is closed.

To disable Draft Mode manually, call the disable() method in your Route Handler:

Then, send a request to invoke the Route Handler. If calling the route using the <Link> component, you must pass prefetch={false} to prevent accidentally deleting the cookie on prefetch.

You can check if Draft Mode is enabled in a Server Component with the isEnabled property:

**Examples:**

Example 1 (python):
```python
import { draftMode } from 'next/headers'
 
export default async function Page() {
  const { isEnabled } = await draftMode()
}
```

Example 2 (python):
```python
import { draftMode } from 'next/headers'
 
export async function GET(request: Request) {
  const draft = await draftMode()
  draft.enable()
  return new Response('Draft mode is enabled')
}
```

Example 3 (python):
```python
import { draftMode } from 'next/headers'
 
export async function GET(request: Request) {
  const draft = await draftMode()
  draft.disable()
  return new Response('Draft mode is disabled')
}
```

Example 4 (python):
```python
import { draftMode } from 'next/headers'
 
export default async function Page() {
  const { isEnabled } = await draftMode()
  return (
    <main>
      <h1>My Blog Post</h1>
      <p>Draft Mode is currently {isEnabled ? 'Enabled' : 'Disabled'}</p>
    </main>
  )
}
```

---

## How to configure Babel in Next.js

**URL:** https://nextjs.org/docs/pages/guides/babel

**Contents:**
- How to configure Babel in Next.js
- Adding Presets and Plugins
- Customizing Presets and Plugins

Next.js includes the next/babel preset to your app, which includes everything needed to compile React applications and server-side code. But if you want to extend the default Babel configs, it's also possible.

To start, you only need to define a .babelrc file (or babel.config.js) in the root directory of your project. If such a file is found, it will be considered as the source of truth, and therefore it needs to define what Next.js needs as well, which is the next/babel preset.

Here's an example .babelrc file:

You can take a look at this file to learn about the presets included by next/babel.

To add presets/plugins without configuring them, you can do it this way:

To add presets/plugins with custom configuration, do it on the next/babel preset like so:

To learn more about the available options for each config, visit babel's documentation site.

**Examples:**

Example 1 (unknown):
```unknown
{
  "presets": ["next/babel"],
  "plugins": []
}
```

Example 2 (unknown):
```unknown
{
  "presets": ["next/babel"],
  "plugins": ["@babel/plugin-proposal-do-expressions"]
}
```

Example 3 (unknown):
```unknown
{
  "presets": [
    [
      "next/babel",
      {
        "preset-env": {},
        "transform-runtime": {},
        "styled-jsx": {},
        "class-properties": {}
      }
    ]
  ],
  "plugins": []
}
```

---

## Route Segment Config

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config

**Contents:**
- Route Segment Config
- Options
  - dynamic
  - dynamicParams
  - revalidate
    - Revalidation Frequency
  - fetchCache
    - Cross-route segment behavior
  - runtime
  - preferredRegion

The Route Segment options allows you to configure the behavior of a Page, Layout, or Route Handler by directly exporting the following variables:

Change the dynamic behavior of a layout or page to fully static or fully dynamic.

Good to know: The new model in the app directory favors granular caching control at the fetch request level over the binary all-or-nothing model of getServerSideProps and getStaticProps at the page-level in the pages directory. The dynamic option is a way to opt back in to the previous model as a convenience and provides a simpler migration path.

'auto' (default): The default option to cache as much as possible without preventing any components from opting into dynamic behavior.

'force-dynamic': Force dynamic rendering, which will result in routes being rendered for each user at request time. This option is equivalent to:

'error': Force static rendering and cache the data of a layout or page by causing an error if any components use Dynamic APIs or uncached data. This option is equivalent to:

'force-static': Force static rendering and cache the data of a layout or page by forcing cookies, headers() and useSearchParams() to return empty values. It is possible to revalidate, revalidatePath, or revalidateTag, in pages or layouts rendered with force-static.

Control what happens when a dynamic segment is visited that was not generated with generateStaticParams.

Set the default revalidation time for a layout or page. This option does not override the revalidate value set by individual fetch requests.

By default, Next.js will cache any fetch() requests that are reachable before any Dynamic APIs are used and will not cache fetch requests that are discovered after Dynamic APIs are used.

fetchCache allows you to override the default cache option of all fetch requests in a layout or page.

We recommend using the Node.js runtime for rendering your application. This option cannot be used in Proxy.

Good to know: Using runtime: 'edge' is not supported for Cache Components.

Support for preferredRegion, and regions supported, is dependent on your deployment platform.

By default, Next.js does not limit the execution of server-side logic (rendering a page or handling an API). Deployment platforms can use maxDuration from the Next.js build output to add specific execution limits.

Note: This setting requires Next.js 13.4.10 or higher.

The generateStaticParams function can be used in combination with dynamic route segments to define the list of route segment parameters that will be statically generated at build time instead of on-demand at request time.

See the API reference for more details.

**Examples:**

Example 1 (javascript):
```javascript
export const dynamic = 'auto'
// 'auto' | 'force-dynamic' | 'error' | 'force-static'
```

Example 2 (javascript):
```javascript
export const dynamicParams = true // true | false
```

Example 3 (javascript):
```javascript
export const revalidate = false
// false | 0 | number
```

Example 4 (javascript):
```javascript
export const fetchCache = 'auto'
// 'auto' | 'default-cache' | 'only-cache'
// 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'
```

---

## experimental.adapterPath

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/adapterPath

**Contents:**
- experimental.adapterPath
- Configuration
- Creating an Adapter
  - Basic Adapter Structure
- API Reference
  - modifyConfig(config, context)
  - onBuildComplete(context)
- Output Types
  - Pages (outputs.pages)
  - API Routes (outputs.pagesApi)

Next.js provides an experimental API that allows you to create custom adapters to hook into the build process. This is useful for deployment platforms or custom build integrations that need to modify the Next.js configuration or process the build output.

To use an adapter, specify the path to your adapter module in experimental.adapterPath:

An adapter is a module that exports an object implementing the NextAdapter interface:

Here's a minimal adapter example:

Called for any CLI command that loads the next.config to allow modification of the configuration.

Returns: The modified configuration object (can be async)

Called after the build process completes with detailed information about routes and outputs.

The outputs object contains arrays of different output types:

React pages from the pages/ directory:

API routes from pages/api/:

React pages from the app/ directory with page.{js,ts,jsx,tsx}:

API and metadata routes from app/ with route.{js,ts,jsx,tsx}:

ISR-enabled routes and static prerenders:

Static assets and auto-statically optimized pages:

Middleware function (if present):

The routes object in onBuildComplete provides complete routing information with processed patterns ready for deployment:

Each header route includes:

Each redirect route includes:

Rewrites are categorized into three phases:

Each rewrite includes source, sourceRegex, destination, has, and missing.

Generated from dynamic route segments (e.g., [slug], [...path]). Each includes:

Common use cases for adapters include:

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    adapterPath: require.resolve('./my-adapter.js'),
  },
}
 
module.exports = nextConfig
```

Example 2 (javascript):
```javascript
export interface NextAdapter {
  name: string
  modifyConfig?: (
    config: NextConfigComplete,
    ctx: {
      phase: PHASE_TYPE
    }
  ) => Promise<NextConfigComplete> | NextConfigComplete
  onBuildComplete?: (ctx: {
    routes: {
      headers: Array<ManifestHeaderRoute>
      redirects: Array<ManifestRedirectRoute>
      rewrites: {
        beforeFiles: Array<ManifestRewriteRoute>
        afterFiles: Array<ManifestRewriteRoute>
        fallback: Array<ManifestRewriteRoute>
      }
      dynamicRoutes: ReadonlyArray<ManifestRoute>
    }
    outputs: AdapterOutputs
    projectDir: string
    repoRoot: string
    distDir: string
    config: NextConfigComplete
    nextVersion: string
  }) => Promise<void> | void
}
```

Example 3 (javascript):
```javascript
/** @type {import('next').NextAdapter} */
const adapter = {
  name: 'my-custom-adapter',
 
  async modifyConfig(config, { phase }) {
    // Modify the Next.js config based on the build phase
    if (phase === 'phase-production-build') {
      return {
        ...config,
        // Add your modifications
      }
    }
    return config
  },
 
  async onBuildComplete({
    routes,
    outputs,
    projectDir,
    repoRoot,
    distDir,
    config,
    nextVersion,
  }) {
    // Process the build output
    console.log('Build completed with', outputs.pages.length, 'pages')
 
    // Access different output types
    for (const page of outputs.pages) {
      console.log('Page:', page.pathname, 'at', page.filePath)
    }
 
    for (const apiRoute of outputs.pagesApi) {
      console.log('API Route:', apiRoute.pathname, 'at', apiRoute.filePath)
    }
 
    for (const appPage of outputs.appPages) {
      console.log('App Page:', appPage.pathname, 'at', appPage.filePath)
    }
 
    for (const prerender of outputs.prerenders) {
      console.log('Prerendered:', prerender.pathname)
    }
  },
}
 
module.exports = adapter
```

Example 4 (unknown):
```unknown
{
  type: 'PAGES'
  id: string           // Route identifier
  filePath: string     // Path to the built file
  pathname: string     // URL pathname
  sourcePage: string   // Original source file path in pages/ directory
  runtime: 'nodejs' | 'edge'
  assets: Record<string, string>  // Traced dependencies (key: relative path from repo root, value: absolute path)
  wasmAssets?: Record<string, string>  // Bundled wasm files (key: name, value: absolute path)
  config: {
    maxDuration?: number
    preferredRegion?: string | string[]
    env?: Record<string, string>  // Environment variables (edge runtime only)
  }
}
```

---

## Configuring

**URL:** https://nextjs.org/docs/pages/building-your-application/configuring

**Contents:**
- Configuring
  - Error Handling

Next.js allows you to customize your project to meet specific requirements. This includes integrations with TypeScript, ESlint, and more, as well as internal configuration options such as Absolute Imports and Environment Variables.

---

## How to optimize your Next.js application for production

**URL:** https://nextjs.org/docs/pages/guides/production-checklist

**Contents:**
- How to optimize your Next.js application for production
- Automatic optimizations
- During development
  - Routing and rendering
  - Data fetching and caching
  - UI and accessibility
  - Security
  - Metadata and SEO
  - Type safety
- Before going to production

Before taking your Next.js application to production, there are some optimizations and patterns you should consider implementing for the best user experience, performance, and security.

This page provides best practices that you can use as a reference when building your application and before going to production, as well as the automatic Next.js optimizations you should be aware of.

These Next.js optimizations are enabled by default and require no configuration:

These defaults aim to improve your application's performance, and reduce the cost and amount of data transferred on each network request.

While building your application, we recommend using the following features to ensure the best performance and user experience:

Before going to production, you can run next build to build your application locally and catch any build errors, then run next start to measure the performance of your application in a production-like environment.

Use the @next/bundle-analyzer plugin to analyze the size of your JavaScript bundles and identify large modules and dependencies that might be impacting your application's performance.

Additionally, the following tools can help you understand the impact of adding new dependencies to your application:

---

## App Router

**URL:** https://nextjs.org/docs/15/app

**Contents:**
- App Router
- Next Steps
  - Installation
  - Project Structure
  - Layouts and Pages
  - Linking and Navigating
  - Server and Client Components

The App Router is a file-system based router that uses React's latest features such as Server Components, Suspense, and Server Functions.

---

## Caching in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/caching

**Contents:**
- Caching in Next.js
- Overview
- Request Memoization
  - Duration
  - Revalidating
  - Opting out
- Data Cache
  - Duration
  - Revalidating
    - Time-based Revalidation

Next.js improves your application's performance and reduces costs by caching rendering work and data requests. This page provides an in-depth look at Next.js caching mechanisms, the APIs you can use to configure them, and how they interact with each other.

Good to know: This page helps you understand how Next.js works under the hood but is not essential knowledge to be productive with Next.js. Most of Next.js' caching heuristics are determined by your API usage and have defaults for the best performance with zero or minimal configuration. If you instead want to jump to examples, start here.

Here's a high-level overview of the different caching mechanisms and their purpose:

By default, Next.js will cache as much as possible to improve performance and reduce cost. This means routes are statically rendered and data requests are cached unless you opt out. The diagram below shows the default caching behavior: when a route is statically rendered at build time and when a static route is first visited.

Caching behavior changes depending on whether the route is statically or dynamically rendered, data is cached or uncached, and whether a request is part of an initial visit or a subsequent navigation. Depending on your use case, you can configure the caching behavior for individual routes and data requests.

Fetch caching is not supported in middleware. Any fetches done inside of your middleware will be uncached.

Next.js extends the fetch API to automatically memoize requests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once.

For example, if you need to use the same data across a route (e.g. in a Layout, Page, and multiple components), you do not have to fetch data at the top of the tree, and forward props between components. Instead, you can fetch data in the components that need it without worrying about the performance implications of making multiple requests across the network for the same data.

How Request Memoization Works

The cache lasts the lifetime of a server request until the React component tree has finished rendering.

Since the memoization is not shared across server requests and only applies during rendering, there is no need to revalidate it.

Memoization only applies to the GET method in fetch requests, other methods, such as POST and DELETE, are not memoized. This default behavior is a React optimization and we do not recommend opting out of it.

To manage individual requests, you can use the signal property from AbortController.

Next.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is possible because Next.js extends the native fetch API to allow each request on the server to set its own persistent caching semantics.

Good to know: In the browser, the cache option of fetch indicates how a request will interact with the browser's HTTP cache, in Next.js, the cache option indicates how a server-side request will interact with the server's Data Cache.

You can use the cache and next.revalidate options of fetch to configure the caching behavior.

In development mode, fetch data is reused for Hot Module Replacement (HMR), and caching options are ignored for hard refreshes.

How the Data Cache Works

Differences between the Data Cache and Request Memoization

While both caching mechanisms help improve performance by re-using cached data, the Data Cache is persistent across incoming requests and deployments, whereas memoization only lasts the lifetime of a request.

The Data Cache is persistent across incoming requests and deployments unless you revalidate or opt-out.

Cached data can be revalidated in two ways, with:

To revalidate data at a timed interval, you can use the next.revalidate option of fetch to set the cache lifetime of a resource (in seconds).

Alternatively, you can use Route Segment Config options to configure all fetch requests in a segment or for cases where you're not able to use fetch.

How Time-based Revalidation Works

This is similar to stale-while-revalidate behavior.

Data can be revalidated on-demand by path (revalidatePath) or by cache tag (revalidateTag).

How On-Demand Revalidation Works

If you do not want to cache the response from fetch, you can do the following:

You may see the terms Automatic Static Optimization, Static Site Generation, or Static Rendering being used interchangeably to refer to the process of rendering and caching routes of your application at build time.

Next.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads.

To understand how the Full Route Cache works, it's helpful to look at how React handles rendering, and how Next.js caches the result:

On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual routes segments and Suspense boundaries.

Each chunk is rendered in two steps:

This means we don't have to wait for everything to render before caching the work or sending a response. Instead, we can stream a response as work is completed.

What is the React Server Component Payload?

The React Server Component Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The React Server Component Payload contains:

To learn more, see the Server Components documentation.

The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation.

At request time, on the client:

The React Server Component Payload is stored in the client-side Router Cache - a separate in-memory cache, split by individual route segment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes.

On subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server.

If the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client.

Whether a route is cached or not at build time depends on whether it's statically or dynamically rendered. Static routes are cached by default, whereas dynamic routes are rendered at request time, and not cached.

This diagram shows the difference between statically and dynamically rendered routes, with cached and uncached data:

Learn more about static and dynamic rendering.

By default, the Full Route Cache is persistent. This means that the render output is cached across user requests.

There are two ways you can invalidate the Full Route Cache:

You can opt out of the Full Route Cache, or in other words, dynamically render components for every incoming request, by:

Next.js has an in-memory client-side router cache that stores the RSC payload of route segments, split by layouts, loading states, and pages.

When a user navigates between routes, Next.js caches the visited route segments and prefetches the routes the user is likely to navigate to. This results in instant back/forward navigation, no full-page reload between navigations, and preservation of browser state and React state in shared layouts.

With the Router Cache:

Good to know: This cache specifically applies to Next.js and Server Components, and is different to the browser's bfcache, though it has a similar result.

The cache is stored in the browser's temporary memory. Two factors determine how long the router cache lasts:

While a page refresh will clear all cached segments, the automatic invalidation period only affects the individual segment from the time it was prefetched.

Good to know: The experimental staleTimes config option can be used to adjust the automatic invalidation times mentioned above.

There are two ways you can invalidate the Router Cache:

As of Next.js 15, page segments are opted out by default.

Good to know: You can also opt out of prefetching by setting the prefetch prop of the <Link> component to false.

When configuring the different caching mechanisms, it's important to understand how they interact with each other:

The following table provides an overview of how different Next.js APIs affect caching:

By default, the <Link> component automatically prefetches routes from the Full Route Cache and adds the React Server Component Payload to the Router Cache.

To disable prefetching, you can set the prefetch prop to false. But this will not skip the cache permanently, the route segment will still be cached client-side when the user visits the route.

Learn more about the <Link> component.

The prefetch option of the useRouter hook can be used to manually prefetch a route. This adds the React Server Component Payload to the Router Cache.

See the useRouter hook API reference.

The refresh option of the useRouter hook can be used to manually refresh a route. This completely clears the Router Cache, and makes a new request to the server for the current route. refresh does not affect the Data or Full Route Cache.

The rendered result will be reconciled on the client while preserving React state and browser state.

See the useRouter hook API reference.

Data returned from fetch is not automatically cached in the Data Cache.

The default caching behavior of fetch (e.g., when the cache option is not specified) is equal to setting the cache option to no-store:

See the fetch API Reference for more options.

You can opt individual fetch into caching by setting the cache option to force-cache:

See the fetch API Reference for more options.

You can use the next.revalidate option of fetch to set the revalidation period (in seconds) of an individual fetch request. This will revalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-rendered on the server.

See the fetch API reference for more options.

Next.js has a cache tagging system for fine-grained data caching and revalidation.

For example, you can set a tag when fetching data:

Then, call revalidateTag with a tag to purge the cache entry:

There are two places you can use revalidateTag, depending on what you're trying to achieve:

revalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache.

There are two places you can use revalidatePath, depending on what you're trying to achieve:

See the revalidatePath API reference for more information.

revalidatePath vs. router.refresh:

Calling router.refresh will clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Full Route Cache.

The difference is that revalidatePath purges the Data Cache and Full Route Cache, whereas router.refresh() does not change the Data Cache and Full Route Cache, as it is a client-side API.

Dynamic APIs like cookies and headers, and the searchParams prop in Pages depend on runtime incoming request information. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered.

Using cookies.set or cookies.delete in a Server Action invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. to reflect authentication changes).

See the cookies API reference.

The Route Segment Config options can be used to override the route segment defaults or when you're not able to use the fetch API (e.g. database client or 3rd party libraries).

The following Route Segment Config options will opt out of the Full Route Cache:

This config option will opt all fetches out of the Data Cache (i.e. no-store):

See the fetchCache to see more advanced options.

See the Route Segment Config documentation for more options.

For dynamic segments (e.g. app/blog/[slug]/page.js), paths provided by generateStaticParams are cached in the Full Route Cache at build time. At request time, Next.js will also cache paths that weren't known at build time the first time they're visited.

To statically render all paths at build time, supply the full list of paths to generateStaticParams:

To statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:

To statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static':

Good to know: You must return an array from generateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered.

To disable caching at request time, add the export const dynamicParams = false option in a route segment. When this config option is used, only paths provided by generateStaticParams will be served, and other routes will 404 or match (in the case of catch-all routes).

The React cache function allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once.

fetch requests using the GET or HEAD methods are automatically memoized, so you do not need to wrap it in React cache. However, for other fetch methods, or when using data fetching libraries (such as some database, CMS, or GraphQL clients) that don't inherently memoize requests, you can use cache to manually memoize data requests.

**Examples:**

Example 1 (javascript):
```javascript
async function getItem() {
  // The `fetch` function is automatically memoized and the result
  // is cached
  const res = await fetch('https://.../item/1')
  return res.json()
}
 
// This function is called twice, but only executed the first time
const item = await getItem() // cache MISS
 
// The second call could be anywhere in your route
const item = await getItem() // cache HIT
```

Example 2 (javascript):
```javascript
const { signal } = new AbortController()
fetch(url, { signal })
```

Example 3 (unknown):
```unknown
// Revalidate at most every hour
fetch('https://...', { next: { revalidate: 3600 } })
```

Example 4 (javascript):
```javascript
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

---

## How to set up analytics

**URL:** https://nextjs.org/docs/pages/guides/analytics

**Contents:**
- How to set up analytics
- Client Instrumentation
- Build Your Own
- Web Vitals
- Custom Metrics
- Sending results to external systems

Next.js has built-in support for measuring and reporting performance metrics. You can either use the useReportWebVitals hook to manage reporting yourself, or alternatively, Vercel provides a managed service to automatically collect and visualize metrics for you.

For more advanced analytics and monitoring needs, Next.js provides a instrumentation-client.js|ts file that runs before your application's frontend code starts executing. This is ideal for setting up global analytics, error tracking, or performance monitoring tools.

To use it, create an instrumentation-client.js or instrumentation-client.ts file in your application's root directory:

View the API Reference for more information.

Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:

You can handle all the results of these metrics using the name property.

In addition to the core metrics listed above, there are some additional custom metrics that measure the time it takes for the page to hydrate and render:

You can handle all the results of these metrics separately:

These metrics work in all browsers that support the User Timing API.

You can send results to any endpoint to measure and track real user performance on your site. For example:

Good to know: If you use Google Analytics, using the id value can allow you to construct metric distributions manually (to calculate percentiles, etc.)

Read more about sending results to Google Analytics.

**Examples:**

Example 1 (javascript):
```javascript
// Initialize analytics before the app starts
console.log('Analytics initialized')
 
// Set up global error tracking
window.addEventListener('error', (event) => {
  // Send to your error tracking service
  reportError(event.error)
})
```

Example 2 (python):
```python
import { useReportWebVitals } from 'next/web-vitals'
 
function MyApp({ Component, pageProps }) {
  useReportWebVitals((metric) => {
    console.log(metric)
  })
 
  return <Component {...pageProps} />
}
```

Example 3 (python):
```python
import { useReportWebVitals } from 'next/web-vitals'
 
function MyApp({ Component, pageProps }) {
  useReportWebVitals((metric) => {
    switch (metric.name) {
      case 'FCP': {
        // handle FCP results
      }
      case 'LCP': {
        // handle LCP results
      }
      // ...
    }
  })
 
  return <Component {...pageProps} />
}
```

Example 4 (unknown):
```unknown
export function reportWebVitals(metric) {
  switch (metric.name) {
    case 'Next.js-hydration':
      // handle hydration results
      break
    case 'Next.js-route-change-to-render':
      // handle route-change to render results
      break
    case 'Next.js-render':
      // handle render results
      break
    default:
      break
  }
}
```

---

## Custom Document

**URL:** https://nextjs.org/docs/pages/building-your-application/routing/custom-document

**Contents:**
- Custom Document
- Caveats
- Customizing renderPage

A custom Document can update the <html> and <body> tags used to render a Page.

To override the default Document, create the file pages/_document as shown below:

Customizing renderPage is advanced and only needed for libraries like CSS-in-JS to support server-side rendering. This is not needed for built-in styled-jsx support.

We do not recommend using this pattern. Instead, consider incrementally adopting the App Router, which allows you to more easily fetch data for pages and layouts.

**Examples:**

Example 1 (python):
```python
import { Html, Head, Main, NextScript } from 'next/document'
 
export default function Document() {
  return (
    <Html lang="en">
      <Head />
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}
```

Example 2 (python):
```python
import Document, {
  Html,
  Head,
  Main,
  NextScript,
  DocumentContext,
  DocumentInitialProps,
} from 'next/document'
 
class MyDocument extends Document {
  static async getInitialProps(
    ctx: DocumentContext
  ): Promise<DocumentInitialProps> {
    const originalRenderPage = ctx.renderPage
 
    // Run the React rendering logic synchronously
    ctx.renderPage = () =>
      originalRenderPage({
        // Useful for wrapping the whole react tree
        enhanceApp: (App) => App,
        // Useful for wrapping in a per-page basis
        enhanceComponent: (Component) => Component,
      })
 
    // Run the parent `getInitialProps`, it now includes the custom `renderPage`
    const initialProps = await Document.getInitialProps(ctx)
 
    return initialProps
  }
 
  render() {
    return (
      <Html lang="en">
        <Head />
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    )
  }
}
 
export default MyDocument
```

---

## Custom Errors

**URL:** https://nextjs.org/docs/pages/building-your-application/routing/custom-error

**Contents:**
- Custom Errors
- 404 Page
  - Customizing The 404 Page
- 500 Page
  - Customizing The 500 Page
  - More Advanced Error Page Customizing
  - Reusing the built-in error page
  - Caveats

A 404 page may be accessed very often. Server-rendering an error page for every visit increases the load of the Next.js server. This can result in increased costs and slow experiences.

To avoid the above pitfalls, Next.js provides a static 404 page by default without having to add any additional files.

To create a custom 404 page you can create a pages/404.js file. This file is statically generated at build time.

Good to know: You can use getStaticProps inside this page if you need to fetch data at build time.

Server-rendering an error page for every visit adds complexity to responding to errors. To help users get responses to errors as fast as possible, Next.js provides a static 500 page by default without having to add any additional files.

To customize the 500 page you can create a pages/500.js file. This file is statically generated at build time.

Good to know: You can use getStaticProps inside this page if you need to fetch data at build time.

500 errors are handled both client-side and server-side by the Error component. If you wish to override it, define the file pages/_error.js and add the following code:

pages/_error.js is only used in production. In development youâ€™ll get an error with the call stack to know where the error originated from.

If you want to render the built-in error page you can by importing the Error component:

The Error component also takes title as a property if you want to pass in a text message along with a statusCode.

If you have a custom Error component be sure to import that one instead. next/error exports the default component used by Next.js.

**Examples:**

Example 1 (unknown):
```unknown
export default function Custom404() {
  return <h1>404 - Page Not Found</h1>
}
```

Example 2 (unknown):
```unknown
export default function Custom500() {
  return <h1>500 - Server-side error occurred</h1>
}
```

Example 3 (javascript):
```javascript
function Error({ statusCode }) {
  return (
    <p>
      {statusCode
        ? `An error ${statusCode} occurred on server`
        : 'An error occurred on client'}
    </p>
  )
}
 
Error.getInitialProps = ({ res, err }) => {
  const statusCode = res ? res.statusCode : err ? err.statusCode : 404
  return { statusCode }
}
 
export default Error
```

Example 4 (python):
```python
import Error from 'next/error'
 
export async function getServerSideProps() {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const errorCode = res.ok ? false : res.status
  const json = await res.json()
 
  return {
    props: { errorCode, stars: json.stargazers_count },
  }
}
 
export default function Page({ errorCode, stars }) {
  if (errorCode) {
    return <Error statusCode={errorCode} />
  }
 
  return <div>Next stars: {stars}</div>
}
```

---

## How to optimize your local development environment

**URL:** https://nextjs.org/docs/app/guides/local-development

**Contents:**
- How to optimize your local development environment
- Local dev vs. production
- Improving local dev performance
  - 1. Check your computer's antivirus
  - 2. Update Next.js and use Turbopack
  - 3. Check your imports
    - Icon libraries
    - Barrel files
    - Optimize package imports
  - 4. Check your Tailwind CSS setup

Next.js is designed to provide a great developer experience. As your application grows, you might notice slower compilation times during local development. This guide will help you identify and fix common compile-time performance issues.

The development process with next dev is different than next build and next start.

next dev compiles routes in your application as you open or navigate to them. This enables you to start the dev server without waiting for every route in your application to compile, which is both faster and uses less memory. Running a production build applies other optimizations, like minifying files and creating content hashes, which are not needed for local development.

Antivirus software can slow down file access. While this is more common on Windows machines, this can be an issue for any system with an antivirus tool installed.

On Windows, you can add your project to the Microsoft Defender Antivirus exclusion list.

On macOS, you can disable Gatekeeper inside of your terminal.

If you or your employer have configured any other Antivirus solutions on your system, you should inspect the relevant settings for those products.

Make sure you're using the latest version of Next.js. Each new version often includes performance improvements.

Turbopack is now the default bundler for Next.js development and provides significant performance improvements over webpack.

If you need to use Webpack instead of Turbopack, you can opt-in:

Learn more about Turbopack. See our upgrade guides and codemods for more information.

The way you import code can greatly affect compilation and bundling time. Learn more about optimizing package bundling and explore tools like Dependency Cruiser or Madge.

Libraries like @material-ui/icons, @phosphor-icons/react, or react-icons can import thousands of icons, even if you only use a few. Try to import only the icons you need:

You can often find what import pattern to use in the documentation for the icon library you're using. This example follows @phosphor-icons/react recommendation.

Libraries like react-icons includes many different icon sets. Choose one set and stick with that set.

For example, if your application uses react-icons and imports all of these:

Combined they will be tens of thousands of modules that the compiler has to handle, even if you only use a single import from each.

"Barrel files" are files that export many items from other files. They can slow down builds because the compiler has to parse them to find if there are side-effects in the module scope by using the import.

Try to import directly from specific files when possible. Learn more about barrel files and the built-in optimizations in Next.js.

Next.js can automatically optimize imports for certain packages. If you are using packages that utilize barrel files, add them to your next.config.js:

Turbopack automatically analyzes imports and optimizes them. It does not require this configuration.

If you're using Tailwind CSS, make sure it's set up correctly.

A common mistake is configuring your content array in a way which includes node_modules or other large directories of files that should not be scanned.

Tailwind CSS version 3.4.8 or newer will warn you about settings that might slow down your build.

In your tailwind.config.js, be specific about which files to scan:

Avoid scanning unnecessary files:

If you've added custom webpack settings, they might be slowing down compilation.

Consider if you really need them for local development. You can optionally only include certain tools for production builds, or explore using the default Turbopack bundler and configuring loaders instead.

If your app is very large, it might need more memory.

Learn more about optimizing memory usage.

Changes to Server Components cause the entire page to re-render locally in order to show the new changes, which includes fetching new data for the component.

The experimental serverComponentsHmrCache option allows you to cache fetch responses in Server Components across Hot Module Replacement (HMR) refreshes in local development. This results in faster responses and reduced costs for billed API calls.

Learn more about the experimental option.

If you're using Docker for development on Mac or Windows, you may experience significantly slower performance compared to running Next.js locally.

Docker's filesystem access on Mac and Windows can cause Hot Module Replacement (HMR) to take seconds or even minutes, while the same application runs with fast HMR when developed locally.

This performance difference is due to how Docker handles filesystem operations outside of Linux environments. For the best development experience:

Learn more about Docker deployment for production use.

Use the logging.fetches option in your next.config.js file, to see more detailed information about what's happening during development:

Learn more about fetch logging.

Turbopack tracing is a tool that helps you understand the performance of your application during local development. It provides detailed information about the time taken for each module to compile and how they are related.

Make sure you have the latest version of Next.js installed.

Generate a Turbopack trace file:

Navigate around your application or make edits to files to reproduce the problem.

Stop the Next.js development server.

A file called trace-turbopack will be available in the .next/dev folder.

You can interpret the file using npx next internal trace [path-to-file]:

On versions where trace is not available, the command was named turbo-trace-server:

Once the trace server is running you can view the trace at https://trace.nextjs.org/.

By default the trace viewer will aggregate timings, in order to see each individual time you can switch from "Aggregated in order" to "Spans in order" at the top right of the viewer.

Good to know: The trace file is place under the development server directory, which defaults to .next/dev. This is controllable using the isolatedDevBuild flag in your Next config file.

Share the trace file generated in the Turbopack Tracing section and share it on GitHub Discussions or Discord.

**Examples:**

Example 1 (unknown):
```unknown
npm install next@latest
npm run dev  # Turbopack is used by default
```

Example 2 (unknown):
```unknown
npm run dev --webpack
```

Example 3 (python):
```python
// Instead of this:
import { TriangleIcon } from '@phosphor-icons/react'
 
// Do this:
import { TriangleIcon } from '@phosphor-icons/react/dist/csr/Triangle'
```

Example 4 (unknown):
```unknown
module.exports = {
  experimental: {
    optimizePackageImports: ['package-name'],
  },
}
```

---

## Turbopack

**URL:** https://nextjs.org/docs/pages/api-reference/turbopack

**Contents:**
- Turbopack
- Why Turbopack?
- Getting started
  - Using Webpack instead
- Supported features
  - Language features
  - Framework and React features
  - CSS and styling
  - Assets
  - Module resolution

Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in Rust, and built into Next.js. You can use Turbopack with both the Pages and App Router for a much faster local development experience.

We built Turbopack to push the performance of Next.js, including:

Turbopack is now the default bundler in Next.js. No configuration is needed to use Turbopack:

If you need to use Webpack instead of Turbopack, you can opt-in with the --webpack flag:

Turbopack in Next.js has zero-configuration for the common use cases. Below is a summary of what is supported out of the box, plus some references to how you can configure Turbopack further when needed.

There are a number of non-trivial behavior differences between webpack and Turbopack that are important to be aware of when migrating an application. Generally, these are less of a concern for new applications.

Turbopack will follow JS import order to order CSS modules which are not otherwise ordered. For example:

In this example, Turbopack will ensure that utils.module.css will appear before button.module.css in the produced CSS chunk, following the import order

Webpack generally does this as well, but there are cases where it will ignore JS inferred ordering, for example if it infers the JS file is side-effect-free.

This can lead to subtle rendering changes when adopting Turbopack, if applications have come to rely on an arbitrary ordering. Generally, the solution is easy, e.g. have button.module.css @import utils.module.css to force the ordering, or identify the conflicting rules and change them to not target the same properties.

Turbopack supports importing node_modules Sass files out of the box. Webpack supports a legacy tilde ~ syntax for this, which is not supported by Turbopack.

If you can't update the imports, you can add a turbopack.resolveAlias configuration to map the ~ syntax to the actual path:

From our testing on production applications, we observed that Turbopack generally produces bundles that are similar in size to Webpack. However, the comparison can be difficult since turbopack tends to produce fewer but larger chunks. Our advice is to focus on higher level metrics like Core Web Vitals or your own application level metrics to compare performance across the two bundlers. We are however aware of one gap that can occasionally cause a large regression.

Turbopack does not yet have an equivalent to the Inner Graph Optimization in webpack which is enabled by default. This optimization is useful to tree shake large modules. For example:

If an application only uses CONSTANT_VALUE Turbopack will detect this and delete the usesHeavy export but not the corresponding import. However, with the Inner Graph Optimization, webpack can delete the import too which can drop the dependency as well.

We are planning to offer an equivalent to the Inner Graph Optimization in Turbopack but it is still under development. If you are affected by this gap, consider manually splitting modules.

Webpack supports disk build caching to improve build performance. Turbopack provides a similar opt-in feature, currently in beta. Starting with Next 16, you can enable Turbopackâ€™s filesystem cache by setting the following experimental flags:

Good to know: For this reason, when comparing webpack and Turbopack performance, make sure to delete the .next folder between builds to see a fair comparison or enable the turbopack filesystem cache feature.

Turbopack does not support webpack plugins. This affects third-party tools that rely on webpack's plugin system for integration. We do support webpack loaders. If you depend on webpack plugins, you'll need to find Turbopack-compatible alternatives or continue using webpack until equivalent functionality is available.

Some features are not yet implemented or not planned:

For a full, detailed breakdown of each feature flag and its status, see the Turbopack API Reference.

Turbopack can be configured via next.config.js (or next.config.ts) under the turbopack key. Configuration options include:

For more in-depth configuration examples, see the Turbopack config documentation.

If you encounter performance or memory issues and want to help the Next.js team diagnose them, you can generate a trace file by appending NEXT_TURBOPACK_TRACING=1 to your dev command:

This will produce a .next/dev/trace-turbopack file. Include that file when creating a GitHub issue on the Next.js repo to help us investigate.

By default the development server outputs to .next/dev. Read more about isolatedDevBuild.

Turbopack is a Rust-based, incremental bundler designed to make local development and builds fastâ€”especially for large applications. It is integrated into Next.js, offering zero-config CSS, React, and TypeScript support.

**Examples:**

Example 1 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

Example 2 (unknown):
```unknown
{
  "scripts": {
    "dev": "next dev --webpack",
    "build": "next build --webpack",
    "start": "next start"
  }
}
```

Example 3 (python):
```python
import utilStyles from './utils.module.css'
import buttonStyles from './button.module.css'
export default function BlogPost() {
  return (
    <div className={utilStyles.container}>
      <button className={buttonStyles.primary}>Click me</button>
    </div>
  )
}
```

Example 4 (unknown):
```unknown
@import '~bootstrap/dist/css/bootstrap.min.css';
```

---

## appDir

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/appDir

**Contents:**
- appDir

Good to know: This option is no longer needed as of Next.js 13.4. The App Router is now stable.

The App Router (app directory) enables support for layouts, Server Components, streaming, and colocated data fetching.

Using the app directory will automatically enable React Strict Mode. Learn how to incrementally adopt app.

---

## reactCompiler

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/reactCompiler

**Contents:**
- reactCompiler
- How It Works
- Annotations

Next.js includes support for the React Compiler, a tool designed to improve performance by automatically optimizing component rendering. This reduces the need for manual memoization using useMemo and useCallback.

Next.js includes a custom performance optimization written in SWC that makes the React Compiler more efficient. Instead of running the compiler on every file, Next.js analyzes your project and only applies the React Compiler to relevant files. This avoids unnecessary work and leads to faster builds compared to using the Babel plugin on its own.

The React Compiler runs through a Babel plugin. To keep builds fast, Next.js uses a custom SWC optimization that only applies the React Compiler to relevant filesâ€”like those with JSX or React Hooks.

This avoids compiling everything and keeps the performance cost minimal. You may still see slightly slower builds compared to the default Rust-based compiler, but the impact is small and localized.

To use it, install the babel-plugin-react-compiler:

Then, add reactCompiler option in next.config.js:

You can configure the compiler to run in "opt-in" mode as follows:

Then, you can annotate specific components or hooks with the "use memo" directive from React to opt-in:

Note: You can also use the "use no memo" directive from React for the opposite effect, to opt-out a component or hook.

**Examples:**

Example 1 (unknown):
```unknown
npm install -D babel-plugin-react-compiler
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  reactCompiler: true,
}
 
export default nextConfig
```

Example 3 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  reactCompiler: {
    compilationMode: 'annotation',
  },
}
 
export default nextConfig
```

Example 4 (unknown):
```unknown
export default function Page() {
  'use memo'
  // ...
}
```

---

## How to optimize package bundling

**URL:** https://nextjs.org/docs/15/app/guides/package-bundling

**Contents:**
- How to optimize package bundling
- Analyzing JavaScript bundles
  - Installation
  - Generating a report
- Optimizing package imports
- Opting specific packages out of bundling
- Next Steps
  - Production

Bundling external packages can significantly improve the performance of your application. By default, packages imported inside Server Components and Route Handlers are automatically bundled by Next.js. This page will guide you through how to analyze and further optimize package bundling.

@next/bundle-analyzer is a plugin for Next.js that helps you manage the size of your application bundles. It generates a visual report of the size of each package and their dependencies. You can use the information to remove large dependencies, split, or lazy-load your code.

Install the plugin by running the following command:

Then, add the bundle analyzer's settings to your next.config.js.

Run the following command to analyze your bundles:

The report will open three new tabs in your browser, which you can inspect. Periodically evaluating your application's bundles can help you maintain application performance over time.

Some packages, such as icon libraries, can export hundreds of modules, which can cause performance issues in development and production.

You can optimize how these packages are imported by adding the optimizePackageImports option to your next.config.js. This option will only load the modules you actually use, while still giving you the convenience of writing import statements with many named exports.

Next.js also optimizes some libraries automatically, thus they do not need to be included in the optimizePackageImports list. See the full list.

Since packages imported inside Server Components and Route Handlers are automatically bundled by Next.js, you can opt specific packages out of bundling using the serverExternalPackages option in your next.config.js.

Next.js includes a list of popular packages that currently are working on compatibility and automatically opt-ed out. See the full list.

**Examples:**

Example 1 (unknown):
```unknown
npm i @next/bundle-analyzer
# or
yarn add @next/bundle-analyzer
# or
pnpm add @next/bundle-analyzer
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {}
 
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})
 
module.exports = withBundleAnalyzer(nextConfig)
```

Example 3 (unknown):
```unknown
ANALYZE=true npm run build
# or
ANALYZE=true yarn build
# or
ANALYZE=true pnpm build
```

Example 4 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    optimizePackageImports: ['icon-library'],
  },
}
 
module.exports = nextConfig
```

---

## Components

**URL:** https://nextjs.org/docs/pages/api-reference/components

**Contents:**
- Components
  - Font
  - Form
  - Head
  - Image
  - Image (Legacy)
  - Link
  - Script

---

## poweredByHeader

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/poweredByHeader

**Contents:**
- poweredByHeader

By default Next.js will add the x-powered-by header. To opt-out of it, open next.config.js and disable the poweredByHeader config:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  poweredByHeader: false,
}
```

---

## How to use environment variables in Next.js

**URL:** https://nextjs.org/docs/app/guides/environment-variables

**Contents:**
- How to use environment variables in Next.js
- Loading Environment Variables
  - Loading Environment Variables with @next/env
  - Referencing Other Variables
- Bundling Environment Variables for the Browser
  - Runtime Environment Variables
- Test Environment Variables
- Environment Variable Load Order
- Good to know
- Version History

Next.js comes with built-in support for environment variables, which allows you to do the following:

Warning: The default create-next-app template ensures all .env files are added to your .gitignore. You almost never want to commit these files to your repository.

Next.js has built-in support for loading environment variables from .env* files into process.env.

Note: Next.js also supports multiline variables inside of your .env* files:

Note: If you are using a /src folder, please note that Next.js will load the .env files only from the parent folder and not from the /src folder. This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Route Handlers.

If you need to load environment variables outside of the Next.js runtime, such as in a root config file for an ORM or test runner, you can use the @next/env package.

This package is used internally by Next.js to load environment variables from .env* files.

To use it, install the package and use the loadEnvConfig function to load the environment variables:

Then, you can import the configuration where needed. For example:

Next.js will automatically expand variables that use $ to reference other variables e.g. $VARIABLE inside of your .env* files. This allows you to reference other secrets. For example:

In the above example, process.env.TWITTER_URL would be set to https://x.com/nextjs.

Good to know: If you need to use variable with a $ in the actual value, it needs to be escaped e.g. \$.

Non-NEXT_PUBLIC_ environment variables are only available in the Node.js environment, meaning they aren't accessible to the browser (the client runs in a different environment).

In order to make the value of an environment variable accessible in the browser, Next.js can "inline" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with NEXT_PUBLIC_. For example:

This will tell Next.js to replace all references to process.env.NEXT_PUBLIC_ANALYTICS_ID in the Node.js environment with the value from the environment in which you run next build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser.

Note: After being built, your app will no longer respond to changes to these environment variables. For instance, if you use a Heroku pipeline to promote slugs built in one environment to another environment, or if you build and deploy a single Docker image to multiple environments, all NEXT_PUBLIC_ variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization).

Note that dynamic lookups will not be inlined, such as:

Next.js can support both build time and runtime environment variables.

By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.

You can safely read environment variables on the server during dynamic rendering:

This allows you to use a singular Docker image that can be promoted through multiple environments with different values.

Apart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Next.js will not load environment variables from .env.development or .env.production in the testing environment.

This one is useful when running tests with tools like jest or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don't need to do this manually as testing tools will address it for you.

There is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set).

Good to know: similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env*.local are intended to be ignored through .gitignore.

While running unit tests you can make sure to load your environment variables the same way Next.js does by leveraging the loadEnvConfig function from the @next/env package.

Environment variables are looked up in the following places, in order, stopping once the variable is found.

For example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used.

Good to know: The allowed values for NODE_ENV are production, development and test.

**Examples:**

Example 1 (unknown):
```unknown
DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
```

Example 2 (unknown):
```unknown
# .env
 
# you can write with line breaks
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
...
Kh9NV...
...
-----END DSA PRIVATE KEY-----"
 
# or with `\n` inside double quotes
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\nKh9NV...\n-----END DSA PRIVATE KEY-----\n"
```

Example 3 (javascript):
```javascript
export async function GET() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
  })
  // ...
}
```

Example 4 (unknown):
```unknown
npm install @next/env
```

---

## assetPrefix

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js/assetPrefix

**Contents:**
- assetPrefix
- Set up a CDN

Attention: Deploying to Vercel automatically configures a global CDN for your Next.js project. You do not need to manually setup an Asset Prefix.

Good to know: Next.js 9.5+ added support for a customizable Base Path, which is better suited for hosting your application on a sub-path like /docs. We do not suggest you use a custom Asset Prefix for this use case.

To set up a CDN, you can set up an asset prefix and configure your CDN's origin to resolve to the domain that Next.js is hosted on.

Open next.config.mjs and add the assetPrefix config based on the phase:

Next.js will automatically use your asset prefix for the JavaScript and CSS files it loads from the /_next/ path (.next/static/ folder). For example, with the above configuration, the following request for a JS chunk:

Would instead become:

The exact configuration for uploading your files to a given CDN will depend on your CDN of choice. The only folder you need to host on your CDN is the contents of .next/static/, which should be uploaded as _next/static/ as the above URL request indicates. Do not upload the rest of your .next/ folder, as you should not expose your server code and other configuration to the public.

While assetPrefix covers requests to _next/static, it does not influence the following paths:

**Examples:**

Example 1 (python):
```python
// @ts-check
import { PHASE_DEVELOPMENT_SERVER } from 'next/constants'
 
export default (phase) => {
  const isDev = phase === PHASE_DEVELOPMENT_SERVER
  /**
   * @type {import('next').NextConfig}
   */
  const nextConfig = {
    assetPrefix: isDev ? undefined : 'https://cdn.mydomain.com',
  }
  return nextConfig
}
```

Example 2 (unknown):
```unknown
/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
```

Example 3 (unknown):
```unknown
https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js
```

---

## How to use markdown and MDX in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/mdx

**Contents:**
- How to use markdown and MDX in Next.js
- Install dependencies
- Configure next.config.mjs
  - Handling .md files
- Add an mdx-components.tsx file
- Rendering MDX
  - Using file based routing
  - Using imports
  - Using dynamic imports
- Using custom styles and components

Markdown is a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to structurally valid HTML. It's commonly used for writing content on websites and blogs.

MDX is a superset of markdown that lets you write JSX directly in your markdown files. It is a powerful way to add dynamic interactivity and embed React components within your content.

Next.js can support both local MDX content inside your application, as well as remote MDX files fetched dynamically on the server. The Next.js plugin handles transforming markdown and React components into HTML, including support for usage in Server Components (the default in App Router).

Good to know: View the Portfolio Starter Kit template for a complete working example.

The @next/mdx package, and related packages, are used to configure Next.js so it can process markdown and MDX. It sources data from local files, allowing you to create pages with a .md or .mdx extension, directly in your /pages or /app directory.

Install these packages to render MDX with Next.js:

Update the next.config.mjs file at your project's root to configure it to use MDX:

This allows .mdx files to act as pages, routes, or imports in your application.

By default, next/mdx only compiles files with the .mdx extension. To handle .md files with webpack, update the extension option:

Create an mdx-components.tsx (or .js) file in the root of your project to define global MDX Components. For example, at the same level as pages or app, or inside src if applicable.

You can render MDX using Next.js's file based routing or by importing MDX files into other pages.

When using file based routing, you can use MDX pages like any other page.

In App Router apps, that includes being able to use metadata.

Create a new MDX page within the /app directory:

You can use MDX in these files, and even import React components, directly inside your MDX page:

Navigating to the /mdx-page route should display your rendered MDX page.

Create a new page within the /app directory and an MDX file wherever you'd like:

You can use MDX in these files, and even import React components, directly inside your MDX page:

Import the MDX file inside the page to display the content:

Navigating to the /mdx-page route should display your rendered MDX page.

You can import dynamic MDX components instead of using filesystem routing for MDX files.

For example, you can have a dynamic route segment which loads MDX components from a separate directory:

generateStaticParams can be used to prerender the provided routes. By marking dynamicParams as false, accessing a route not defined in generateStaticParams will 404.

Good to know: Ensure you specify the .mdx file extension in your import. While it is not required to use module path aliases (e.g., @/content), it does simplify your import path.

Markdown, when rendered, maps to native HTML elements. For example, writing the following markdown:

Generates the following HTML:

To style your markdown, you can provide custom components that map to the generated HTML elements. Styles and components can be implemented globally, locally, and with shared layouts.

Adding styles and components in mdx-components.tsx will affect all MDX files in your application.

You can apply local styles and components to specific pages by passing them into imported MDX components. These will merge with and override global styles and components.

To share a layout across MDX pages, you can use the built-in layouts support with the App Router.

If you are using Tailwind to style your application, using the @tailwindcss/typography plugin will allow you to reuse your Tailwind configuration and styles in your markdown files.

The plugin adds a set of prose classes that can be used to add typographic styles to content blocks that come from sources, like markdown.

Install Tailwind typography and use with shared layouts to add the prose you want.

Frontmatter is a YAML like key/value pairing that can be used to store data about a page. @next/mdx does not support frontmatter by default, though there are many solutions for adding frontmatter to your MDX content, such as:

@next/mdx does allow you to use exports like any other JavaScript component:

Metadata can now be referenced outside of the MDX file:

A common use case for this is when you want to iterate over a collection of MDX and extract data. For example, creating a blog index page from all blog posts. You can use packages like Node's fs module or globby to read a directory of posts and extract the metadata.

You can optionally provide remark and rehype plugins to transform the MDX content.

For example, you can use remark-gfm to support GitHub Flavored Markdown.

Since the remark and rehype ecosystem is ESM only, you'll need to use next.config.mjs or next.config.ts as the configuration file.

To use plugins with Turbopack, upgrade to the latest @next/mdx and specify plugin names using a string:

remark and rehype plugins without serializable options cannot be used yet with Turbopack, because JavaScript functions can't be passed to Rust.

If your MDX files or content lives somewhere else, you can fetch it dynamically on the server. This is useful for content stored in a CMS, database, or anywhere else. A community package for this use is next-mdx-remote-client.

Good to know: Please proceed with caution. MDX compiles to JavaScript and is executed on the server. You should only fetch MDX content from a trusted source, otherwise this can lead to remote code execution (RCE).

The following example uses next-mdx-remote-client:

Navigating to the /mdx-page-remote route should display your rendered MDX.

React does not natively understand markdown. The markdown plaintext needs to first be transformed into HTML. This can be accomplished with remark and rehype.

remark is an ecosystem of tools around markdown. rehype is the same, but for HTML. For example, the following code snippet transforms markdown into HTML:

The remark and rehype ecosystem contains plugins for syntax highlighting, linking headings, generating a table of contents, and more.

When using @next/mdx as shown above, you do not need to use remark or rehype directly, as it is handled for you. We're describing it here for a deeper understanding of what the @next/mdx package is doing underneath.

Next.js supports a new MDX compiler written in Rust. This compiler is still experimental and is not recommended for production use. To use the new compiler, you need to configure next.config.js when you pass it to withMDX:

mdxRs also accepts an object to configure how to transform mdx files.

**Examples:**

Example 1 (unknown):
```unknown
I **love** using [Next.js](https://nextjs.org/)
```

Example 2 (unknown):
```unknown
<p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>
```

Example 3 (unknown):
```unknown
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx
```

Example 4 (python):
```python
import createMDX from '@next/mdx'
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Configure `pageExtensions` to include markdown and MDX files
  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],
  // Optionally, add any other Next.js config below
}
 
const withMDX = createMDX({
  // Add markdown plugins here, as desired
})
 
// Merge MDX config with Next.js config
export default withMDX(nextConfig)
```

---

## How to create forms with Server Actions

**URL:** https://nextjs.org/docs/app/guides/forms

**Contents:**
- How to create forms with Server Actions
- How it works
- Passing additional arguments
- Form validation
- Validation errors
- Pending states
- Optimistic updates
- Nested form elements
- Programmatic form submission

React Server Actions are Server Functions that execute on the server. They can be called in Server and Client Components to handle form submissions. This guide will walk you through how to create forms in Next.js with Server Actions.

React extends the HTML <form> element to allow Server Actions to be invoked with the action attribute.

When used in a form, the function automatically receives the FormData object. You can then extract the data using the native FormData methods:

Good to know: When working with forms that have multiple fields, use JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData). Note that this object will contain extra properties prefixed with $ACTION_.

Outside of form fields, you can pass additional arguments to a Server Function using the JavaScript bind method. For example, to pass the userId argument to the updateUser Server Function:

The Server Function will receive the userId as an additional argument:

Forms can be validated on the client or server.

To display validation errors or messages, turn the component that defines the <form> into a Client Component and use React useActionState.

When using useActionState, the Server function signature will change to receive a new prevState or initialState parameter as its first argument.

You can then conditionally render the error message based on the state object.

The useActionState hook exposes a pending boolean that can be used to show a loading indicator or disable the submit button while the action is being executed.

Alternatively, you can use the useFormStatus hook to show a loading indicator while the action is being executed. When using this hook, you'll need to create a separate component to render the loading indicator. For example, to disable the button when the action is pending:

You can then nest the SubmitButton component inside the form:

Good to know: In React 19, useFormStatus includes additional keys on the returned object, like data, method, and action. If you are not using React 19, only the pending key is available.

You can use the React useOptimistic hook to optimistically update the UI before the Server Function finishes executing, rather than waiting for the response:

You can call Server Actions in elements nested inside <form> such as <button>, <input type="submit">, and <input type="image">. These elements accept the formAction prop or event handlers.

This is useful in cases where you want to call multiple Server Actions within a form. For example, you can create a specific <button> element for saving a post draft in addition to publishing it. See the React <form> docs for more information.

You can trigger a form submission programmatically using the requestSubmit() method. For example, when the user submits a form using the âŒ˜ + Enter keyboard shortcut, you can listen for the onKeyDown event:

This will trigger the submission of the nearest <form> ancestor, which will invoke the Server Function.

**Examples:**

Example 1 (javascript):
```javascript
export default function Page() {
  async function createInvoice(formData: FormData) {
    'use server'
 
    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    }
 
    // mutate data
    // revalidate the cache
  }
 
  return <form action={createInvoice}>...</form>
}
```

Example 2 (python):
```python
'use client'
 
import { updateUser } from './actions'
 
export function UserProfile({ userId }: { userId: string }) {
  const updateUserWithId = updateUser.bind(null, userId)
 
  return (
    <form action={updateUserWithId}>
      <input type="text" name="name" />
      <button type="submit">Update User Name</button>
    </form>
  )
}
```

Example 3 (unknown):
```unknown
'use server'
 
export async function updateUser(userId: string, formData: FormData) {}
```

Example 4 (python):
```python
'use server'
 
import { z } from 'zod'
 
const schema = z.object({
  email: z.string({
    invalid_type_error: 'Invalid Email',
  }),
})
 
export default async function createUser(formData: FormData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })
 
  // Return early if the form data is invalid
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }
 
  // Mutate data
}
```

---

## Directives

**URL:** https://nextjs.org/docs/app/api-reference/directives

**Contents:**
- Directives
  - use cache
  - use cache: private
  - use cache: remote
  - use client
  - use server

The following directives are available:

---

## How to configure PostCSS in Next.js

**URL:** https://nextjs.org/docs/pages/guides/post-css

**Contents:**
- How to configure PostCSS in Next.js
- Default Behavior
- Customizing Target Browsers
- CSS Modules
- Customizing Plugins

Next.js compiles CSS for its built-in CSS support using PostCSS.

Out of the box, with no configuration, Next.js compiles CSS with the following transformations:

By default, CSS Grid and Custom Properties (CSS variables) are not compiled for IE11 support.

To compile CSS Grid Layout for IE11, you can place the following comment at the top of your CSS file:

You can also enable IE11 support for CSS Grid Layout in your entire project by configuring autoprefixer with the configuration shown below (collapsed). See "Customizing Plugins" below for more information.

CSS variables are not compiled because it is not possible to safely do so. If you must use variables, consider using something like Sass variables which are compiled away by Sass.

Next.js allows you to configure the target browsers (for Autoprefixer and compiled css features) through Browserslist.

To customize browserslist, create a browserslist key in your package.json like so:

You can use the browsersl.ist tool to visualize what browsers you are targeting.

No configuration is needed to support CSS Modules. To enable CSS Modules for a file, rename the file to have the extension .module.css.

You can learn more about Next.js' CSS Module support here.

Warning: When you define a custom PostCSS configuration file, Next.js completely disables the default behavior. Be sure to manually configure all the features you need compiled, including Autoprefixer. You also need to install any plugins included in your custom configuration manually, i.e. npm install postcss-flexbugs-fixes postcss-preset-env.

To customize the PostCSS configuration, create a postcss.config.json file in the root of your project.

This is the default configuration used by Next.js:

Good to know: Next.js also allows the file to be named .postcssrc.json, or, to be read from the postcss key in package.json.

It is also possible to configure PostCSS with a postcss.config.js file, which is useful when you want to conditionally include plugins based on environment:

Good to know: Next.js also allows the file to be named .postcssrc.js.

Do not use require() to import the PostCSS Plugins. Plugins must be provided as strings.

Good to know: If your postcss.config.js needs to support other non-Next.js tools in the same project, you must use the interoperable object-based format instead:

**Examples:**

Example 1 (unknown):
```unknown
/* autoprefixer grid: autoplace */
```

Example 2 (unknown):
```unknown
{
  "plugins": [
    "postcss-flexbugs-fixes",
    [
      "postcss-preset-env",
      {
        "autoprefixer": {
          "flexbox": "no-2009",
          "grid": "autoplace"
        },
        "stage": 3,
        "features": {
          "custom-properties": false
        }
      }
    ]
  ]
}
```

Example 3 (unknown):
```unknown
{
  "browserslist": [">0.3%", "not dead", "not op_mini all"]
}
```

Example 4 (unknown):
```unknown
{
  "plugins": [
    "postcss-flexbugs-fixes",
    [
      "postcss-preset-env",
      {
        "autoprefixer": {
          "flexbox": "no-2009"
        },
        "stage": 3,
        "features": {
          "custom-properties": false
        }
      }
    ]
  ]
}
```

---

## How to install Tailwind CSS v3 in your Next.js application

**URL:** https://nextjs.org/docs/15/app/guides/tailwind-v3-css

**Contents:**
- How to install Tailwind CSS v3 in your Next.js application
- Installing Tailwind v3
- Configuring Tailwind v3
- Using classes
- Usage with Turbopack

This guide will walk you through how to install Tailwind CSS v3 in your Next.js application.

Good to know: For the latest Tailwind 4 setup, see the Tailwind CSS setup instructions.

Install Tailwind CSS and its peer dependencies, then run the init command to generate both tailwind.config.js and postcss.config.js files:

Configure your template paths in your tailwind.config.js file:

Add the Tailwind directives to your global CSS file:

Import the CSS file in your root layout:

After installing Tailwind CSS and adding the global styles, you can use Tailwind's utility classes in your application.

As of Next.js 13.1, Tailwind CSS and PostCSS are supported with Turbopack.

**Examples:**

Example 1 (unknown):
```unknown
pnpm add -D tailwindcss@^3 postcss autoprefixer
npx tailwindcss init -p
```

Example 2 (unknown):
```unknown
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

Example 3 (unknown):
```unknown
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Example 4 (unknown):
```unknown
import './globals.css'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

---

## Form Component

**URL:** https://nextjs.org/docs/app/api-reference/components/form

**Contents:**
- Form Component
- Reference
  - action (string) Props
  - action (function) Props
  - Caveats
- Examples
  - Search form that leads to a search result page
  - Mutations with Server Actions

The <Form> component extends the HTML <form> element to provide prefetching of loading UI, client-side navigation on submission, and progressive enhancement.

It's useful for forms that update URL search params as it reduces the boilerplate code needed to achieve the above.

The behavior of the <Form> component depends on whether the action prop is passed a string or function.

When action is a string, the <Form> component supports the following props:

When action is a function, the <Form> component supports the following prop:

Good to know: When action is a function, the replace and scroll props are ignored.

You can create a search form that navigates to a search results page by passing the path as an action:

When the user updates the query input field and submits the form, the form data will be encoded into the URL as search params, e.g. /search?query=abc.

Good to know: If you pass an empty string "" to action, the form will navigate to the same route with updated search params.

On the results page, you can access the query using the searchParams page.js prop and use it to fetch data from an external source.

When the <Form> becomes visible in the user's viewport, shared UI (such as layout.js and loading.js) on the /search page will be prefetched. On submission, the form will immediately navigate to the new route and show loading UI while the results are being fetched. You can design the fallback UI using loading.js:

To cover cases when shared UI hasn't yet loaded, you can show instant feedback to the user using useFormStatus.

First, create a component that displays a loading state when the form is pending:

Then, update the search form page to use the SearchButton component:

You can perform mutations by passing a function to the action prop.

After a mutation, it's common to redirect to the new resource. You can use the redirect function from next/navigation to navigate to the new post page.

Good to know: Since the "destination" of the form submission is not known until the action is executed, <Form> cannot automatically prefetch shared UI.

Then, in the new page, you can fetch data using the params prop:

See the Server Actions docs for more examples.

**Examples:**

Example 1 (python):
```python
import Form from 'next/form'
 
export default function Page() {
  return (
    <Form action="/search">
      {/* On submission, the input value will be appended to
          the URL, e.g. /search?query=abc */}
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

Example 2 (python):
```python
import Form from 'next/form'
 
export default function Page() {
  return (
    <Form action="/search">
      <input name="query" />
      <button type="submit">Submit</button>
    </Form>
  )
}
```

Example 3 (python):
```python
import { getSearchResults } from '@/lib/search'
 
export default async function SearchPage({
  searchParams,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const results = await getSearchResults((await searchParams).query)
 
  return <div>...</div>
}
```

Example 4 (unknown):
```unknown
export default function Loading() {
  return <div>Loading...</div>
}
```

---

## headers

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/headers

**Contents:**
- headers
- Header Overriding Behavior
- Path Matching
  - Wildcard Path Matching
  - Regex Path Matching
- Header, Cookie, and Query Matching
- Headers with basePath support
- Headers with i18n support
- Cache-Control
- Options

Headers allow you to set custom HTTP headers on the response to an incoming request on a given path.

To set custom HTTP headers you can use the headers key in next.config.js:

headers is an async function that expects an array to be returned holding objects with source and headers properties:

Headers are checked before the filesystem which includes pages and /public files.

If two headers match the same path and set the same header key, the last header key will override the first. Using the below headers, the path /hello will result in the header x-hello being world due to the last header value set being world.

Path matches are allowed, for example /blog/:slug will match /blog/first-post (no nested paths):

The pattern /blog/:slug matches /blog/first-post and /blog/post-1 but not a nested path like /blog/a/b. Patterns are anchored to the start, /blog/:slug will not match /archive/blog/first-post.

You can use modifiers on parameters: * (zero or more), + (one or more), ? (zero or one). For example, /blog/:slug* matches /blog, /blog/a, and /blog/a/b/c.

Read more details on path-to-regexp documentation.

To match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:

To match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\d{1,}) will match /blog/123 but not /blog/abc:

The following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\ before them:

To only apply a header when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the header to be applied.

has and missing items can have the following fields:

When leveraging basePath support with headers each source is automatically prefixed with the basePath unless you add basePath: false to the header:

When leveraging i18n support with headers each source is automatically prefixed to handle the configured locales unless you add locale: false to the header. If locale: false is used you must prefix the source with a locale for it to be matched correctly.

Next.js sets the Cache-Control header of public, max-age=31536000, immutable for truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example, Static Image Imports. You cannot set Cache-Control headers in next.config.js for these assets.

However, you can set Cache-Control headers for other responses or data.

Learn more about caching with the App Router.

Cross-Origin Resource Sharing (CORS) is a security feature that allows you to control which sites can access your resources. You can set the Access-Control-Allow-Origin header to allow a specific origin to access your Route Handlers.

This header controls DNS prefetching, allowing browsers to proactively perform domain name resolution on external links, images, CSS, JavaScript, and more. This prefetching is performed in the background, so the DNS is more likely to be resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.

This header informs browsers it should only be accessed using HTTPS, instead of using HTTP. Using the configuration below, all present and future subdomains will use HTTPS for a max-age of 2 years. This blocks access to pages or subdomains that can only be served over HTTP.

This header indicates whether the site should be allowed to be displayed within an iframe. This can prevent against clickjacking attacks.

This header has been superseded by CSP's frame-ancestors option, which has better support in modern browsers (see Content Security Policy for configuration details).

This header allows you to control which features and APIs can be used in the browser. It was previously named Feature-Policy.

This header prevents the browser from attempting to guess the type of content if the Content-Type header is not explicitly set. This can prevent XSS exploits for websites that allow users to upload and share files.

For example, a user trying to download an image, but having it treated as a different Content-Type like an executable, which could be malicious. This header also applies to downloading browser extensions. The only valid value for this header is nosniff.

This header controls how much information the browser includes when navigating from the current website (origin) to another.

Learn more about adding a Content Security Policy to your application.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  async headers() {
    return [
      {
        source: '/about',
        headers: [
          {
            key: 'x-custom-header',
            value: 'my custom header value',
          },
          {
            key: 'x-another-custom-header',
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

Example 2 (unknown):
```unknown
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'x-hello',
            value: 'there',
          },
        ],
      },
      {
        source: '/hello',
        headers: [
          {
            key: 'x-hello',
            value: 'world',
          },
        ],
      },
    ]
  },
}
```

Example 3 (unknown):
```unknown
module.exports = {
  async headers() {
    return [
      {
        source: '/blog/:slug',
        headers: [
          {
            key: 'x-slug',
            value: ':slug', // Matched parameters can be used in the value
          },
          {
            key: 'x-slug-:slug', // Matched parameters can be used in the key
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  async headers() {
    return [
      {
        source: '/blog/:slug*',
        headers: [
          {
            key: 'x-slug',
            value: ':slug*', // Matched parameters can be used in the value
          },
          {
            key: 'x-slug-:slug*', // Matched parameters can be used in the key
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

---

## How to optimize third-party libraries

**URL:** https://nextjs.org/docs/app/guides/third-party-libraries

**Contents:**
- How to optimize third-party libraries
- Getting Started
- Google Third-Parties
  - Google Tag Manager
    - Sending Events
    - Server-side Tagging
    - Options
  - Google Analytics
    - Sending Events
    - Tracking Pageviews

@next/third-parties is a library that provides a collection of components and utilities that improve the performance and developer experience of loading popular third-party libraries in your Next.js application.

All third-party integrations provided by @next/third-parties have been optimized for performance and ease of use.

To get started, install the @next/third-parties library:

@next/third-parties is currently an experimental library under active development. We recommend installing it with the latest or canary flags while we work on adding more third-party integrations.

All supported third-party libraries from Google can be imported from @next/third-parties/google.

The GoogleTagManager component can be used to instantiate a Google Tag Manager container to your page. By default, it fetches the original inline script after hydration occurs on the page.

To load Google Tag Manager for all routes, include the component directly in your root layout and pass in your GTM container ID:

To load Google Tag Manager for a single route, include the component in your page file:

The sendGTMEvent function can be used to track user interactions on your page by sending events using the dataLayer object. For this function to work, the <GoogleTagManager /> component must be included in either a parent layout, page, or component, or directly in the same file.

Refer to the Tag Manager developer documentation to learn about the different variables and events that can be passed into the function.

If you're using a server-side tag manager and serving gtm.js scripts from your tagging server you can use gtmScriptUrl option to specify the URL of the script.

Options to pass to the Google Tag Manager. For a full list of options, read the Google Tag Manager docs.

*gtmId can be omitted when gtmScriptUrl is provided to support Google tag gateway for advertisers.

The GoogleAnalytics component can be used to include Google Analytics 4 to your page via the Google tag (gtag.js). By default, it fetches the original scripts after hydration occurs on the page.

Recommendation: If Google Tag Manager is already included in your application, you can configure Google Analytics directly using it, rather than including Google Analytics as a separate component. Refer to the documentation to learn more about the differences between Tag Manager and gtag.js.

To load Google Analytics for all routes, include the component directly in your root layout and pass in your measurement ID:

To load Google Analytics for a single route, include the component in your page file:

The sendGAEvent function can be used to measure user interactions on your page by sending events using the dataLayer object. For this function to work, the <GoogleAnalytics /> component must be included in either a parent layout, page, or component, or directly in the same file.

Refer to the Google Analytics developer documentation to learn more about event parameters.

Google Analytics automatically tracks pageviews when the browser history state changes. This means that client-side navigations between Next.js routes will send pageview data without any configuration.

To ensure that client-side navigations are being measured correctly, verify that the â€œEnhanced Measurementâ€ property is enabled in your Admin panel and the â€œPage changes based on browser history eventsâ€ checkbox is selected.

Note: If you decide to manually send pageview events, make sure to disable the default pageview measurement to avoid having duplicate data. Refer to the Google Analytics developer documentation to learn more.

Options to pass to the <GoogleAnalytics> component.

The GoogleMapsEmbed component can be used to add a Google Maps Embed to your page. By default, it uses the loading attribute to lazy-load the embed below the fold.

Options to pass to the Google Maps Embed. For a full list of options, read the Google Map Embed docs.

The YouTubeEmbed component can be used to load and display a YouTube embed. This component loads faster by using lite-youtube-embed under the hood.

**Examples:**

Example 1 (unknown):
```unknown
npm install @next/third-parties@latest next@latest
```

Example 2 (python):
```python
import { GoogleTagManager } from '@next/third-parties/google'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <GoogleTagManager gtmId="GTM-XYZ" />
      <body>{children}</body>
    </html>
  )
}
```

Example 3 (python):
```python
import { GoogleTagManager } from '@next/third-parties/google'
 
export default function Page() {
  return <GoogleTagManager gtmId="GTM-XYZ" />
}
```

Example 4 (python):
```python
'use client'
 
import { sendGTMEvent } from '@next/third-parties/google'
 
export function EventButton() {
  return (
    <div>
      <button
        onClick={() => sendGTMEvent({ event: 'buttonClicked', value: 'xyz' })}
      >
        Send Event
      </button>
    </div>
  )
}
```

---

## rewrites

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js/rewrites

**Contents:**
- rewrites
- Rewrite parameters
- Path Matching
  - Wildcard Path Matching
  - Regex Path Matching
- Header, Cookie, and Query Matching
- Rewriting to an external URL
  - Incremental adoption of Next.js
  - Rewrites with basePath support
  - Rewrites with i18n support

Rewrites allow you to map an incoming request path to a different destination path.

Rewrites act as a URL proxy and mask the destination path, making it appear the user hasn't changed their location on the site. In contrast, redirects will reroute to a new page and show the URL changes.

To use rewrites you can use the rewrites key in next.config.js:

Rewrites are applied to client-side routing. In the example above, navigating to <Link href="/about"> will serve content from / while keeping the URL as /about.

rewrites is an async function that expects to return either an array or an object of arrays (see below) holding objects with source and destination properties:

When the rewrites function returns an array, rewrites are applied after checking the filesystem (pages and /public files) and before dynamic routes. When the rewrites function returns an object of arrays with a specific shape, this behavior can be changed and more finely controlled, as of v10.1 of Next.js:

Good to know: rewrites in beforeFiles do not check the filesystem/dynamic routes immediately after matching a source, they continue until all beforeFiles have been checked.

The order Next.js routes are checked is:

When using parameters in a rewrite the parameters will be passed in the query by default when none of the parameters are used in the destination.

If a parameter is used in the destination none of the parameters will be automatically passed in the query.

You can still pass the parameters manually in the query if one is already used in the destination by specifying the query in the destination.

Good to know: Static pages from Automatic Static Optimization or prerendering params from rewrites will be parsed on the client after hydration and provided in the query.

Path matches are allowed, for example /blog/:slug will match /blog/first-post (no nested paths):

The pattern /blog/:slug matches /blog/first-post and /blog/post-1 but not /blog/a/b (no nested paths). Patterns are anchored to the start: /blog/:slug will not match /archive/blog/first-post.

You can use modifiers on parameters: * (zero or more), + (one or more), ? (zero or one). For example, /blog/:slug* matches /blog, /blog/a, and /blog/a/b/c.

Read more details on path-to-regexp documentation.

To match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:

To match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\d{1,}) will match /blog/123 but not /blog/abc:

The following characters (, ), {, }, [, ], |, \, ^, ., :, *, +, -, ?, $ are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\ before them:

To only match a rewrite when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the rewrite to be applied.

has and missing items can have the following fields:

Rewrites allow you to rewrite to an external URL. This is especially useful for incrementally adopting Next.js. The following is an example rewrite for redirecting the /blog route of your main app to an external site.

If you're using trailingSlash: true, you also need to insert a trailing slash in the source parameter. If the destination server is also expecting a trailing slash it should be included in the destination parameter as well.

You can also have Next.js fall back to proxying to an existing website after checking all Next.js routes.

This way you don't have to change the rewrites configuration when migrating more pages to Next.js

When leveraging basePath support with rewrites each source and destination is automatically prefixed with the basePath unless you add basePath: false to the rewrite:

When leveraging i18n support with rewrites each source and destination is automatically prefixed to handle the configured locales unless you add locale: false to the rewrite. If locale: false is used you must prefix the source and destination with a locale for it to be matched correctly.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  async rewrites() {
    return [
      {
        source: '/about',
        destination: '/',
      },
    ]
  },
}
```

Example 2 (unknown):
```unknown
module.exports = {
  async rewrites() {
    return {
      beforeFiles: [
        // These rewrites are checked after headers/redirects
        // and before all files including _next/public files which
        // allows overriding page files
        {
          source: '/some-page',
          destination: '/somewhere-else',
          has: [{ type: 'query', key: 'overrideMe' }],
        },
      ],
      afterFiles: [
        // These rewrites are checked after pages/public files
        // are checked but before dynamic routes
        {
          source: '/non-existent',
          destination: '/somewhere-else',
        },
      ],
      fallback: [
        // These rewrites are checked after both pages/public files
        // and dynamic routes are checked
        {
          source: '/:path*',
          destination: `https://my-old-site.com/:path*`,
        },
      ],
    }
  },
}
```

Example 3 (unknown):
```unknown
module.exports = {
  async rewrites() {
    return [
      {
        source: '/old-about/:path*',
        destination: '/about', // The :path parameter isn't used here so will be automatically passed in the query
      },
    ]
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  async rewrites() {
    return [
      {
        source: '/docs/:path*',
        destination: '/:path*', // The :path parameter is used here so will not be automatically passed in the query
      },
    ]
  },
}
```

---

## How to use markdown and MDX in Next.js

**URL:** https://nextjs.org/docs/pages/guides/mdx

**Contents:**
- How to use markdown and MDX in Next.js
- Install dependencies
- Configure next.config.mjs
  - Handling .md files
- Add an mdx-components.tsx file
- Rendering MDX
  - Using file based routing
  - Using imports
- Using custom styles and components
  - Global styles and components

Markdown is a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to structurally valid HTML. It's commonly used for writing content on websites and blogs.

MDX is a superset of markdown that lets you write JSX directly in your markdown files. It is a powerful way to add dynamic interactivity and embed React components within your content.

Next.js can support both local MDX content inside your application, as well as remote MDX files fetched dynamically on the server. The Next.js plugin handles transforming markdown and React components into HTML, including support for usage in Server Components (the default in App Router).

Good to know: View the Portfolio Starter Kit template for a complete working example.

The @next/mdx package, and related packages, are used to configure Next.js so it can process markdown and MDX. It sources data from local files, allowing you to create pages with a .md or .mdx extension, directly in your /pages or /app directory.

Install these packages to render MDX with Next.js:

Update the next.config.mjs file at your project's root to configure it to use MDX:

This allows .mdx files to act as pages, routes, or imports in your application.

By default, next/mdx only compiles files with the .mdx extension. To handle .md files with webpack, update the extension option:

Create an mdx-components.tsx (or .js) file in the root of your project to define global MDX Components. For example, at the same level as pages or app, or inside src if applicable.

You can render MDX using Next.js's file based routing or by importing MDX files into other pages.

When using file based routing, you can use MDX pages like any other page.

Create a new MDX page within the /pages directory:

You can use MDX in these files, and even import React components, directly inside your MDX page:

Navigating to the /mdx-page route should display your rendered MDX page.

Create a new page within the /pages directory and an MDX file wherever you'd like:

You can use MDX in these files, and even import React components, directly inside your MDX page:

Import the MDX file inside the page to display the content:

Navigating to the /mdx-page route should display your rendered MDX page.

Markdown, when rendered, maps to native HTML elements. For example, writing the following markdown:

Generates the following HTML:

To style your markdown, you can provide custom components that map to the generated HTML elements. Styles and components can be implemented globally, locally, and with shared layouts.

Adding styles and components in mdx-components.tsx will affect all MDX files in your application.

You can apply local styles and components to specific pages by passing them into imported MDX components. These will merge with and override global styles and components.

To share a layout around MDX pages, create a layout component:

Then, import the layout component into the MDX page, wrap the MDX content in the layout, and export it:

If you are using Tailwind to style your application, using the @tailwindcss/typography plugin will allow you to reuse your Tailwind configuration and styles in your markdown files.

The plugin adds a set of prose classes that can be used to add typographic styles to content blocks that come from sources, like markdown.

Install Tailwind typography and use with shared layouts to add the prose you want.

To share a layout around MDX pages, create a layout component:

Then, import the layout component into the MDX page, wrap the MDX content in the layout, and export it:

Frontmatter is a YAML like key/value pairing that can be used to store data about a page. @next/mdx does not support frontmatter by default, though there are many solutions for adding frontmatter to your MDX content, such as:

@next/mdx does allow you to use exports like any other JavaScript component:

Metadata can now be referenced outside of the MDX file:

A common use case for this is when you want to iterate over a collection of MDX and extract data. For example, creating a blog index page from all blog posts. You can use packages like Node's fs module or globby to read a directory of posts and extract the metadata.

You can optionally provide remark and rehype plugins to transform the MDX content.

For example, you can use remark-gfm to support GitHub Flavored Markdown.

Since the remark and rehype ecosystem is ESM only, you'll need to use next.config.mjs or next.config.ts as the configuration file.

To use plugins with Turbopack, upgrade to the latest @next/mdx and specify plugin names using a string:

remark and rehype plugins without serializable options cannot be used yet with Turbopack, because JavaScript functions can't be passed to Rust.

If your MDX files or content lives somewhere else, you can fetch it dynamically on the server. This is useful for content stored in a CMS, database, or anywhere else. A community package for this use is next-mdx-remote-client.

Good to know: Please proceed with caution. MDX compiles to JavaScript and is executed on the server. You should only fetch MDX content from a trusted source, otherwise this can lead to remote code execution (RCE).

The following example uses next-mdx-remote-client:

Navigating to the /mdx-page-remote route should display your rendered MDX.

React does not natively understand markdown. The markdown plaintext needs to first be transformed into HTML. This can be accomplished with remark and rehype.

remark is an ecosystem of tools around markdown. rehype is the same, but for HTML. For example, the following code snippet transforms markdown into HTML:

The remark and rehype ecosystem contains plugins for syntax highlighting, linking headings, generating a table of contents, and more.

When using @next/mdx as shown above, you do not need to use remark or rehype directly, as it is handled for you. We're describing it here for a deeper understanding of what the @next/mdx package is doing underneath.

Next.js supports a new MDX compiler written in Rust. This compiler is still experimental and is not recommended for production use. To use the new compiler, you need to configure next.config.js when you pass it to withMDX:

mdxRs also accepts an object to configure how to transform mdx files.

**Examples:**

Example 1 (unknown):
```unknown
I **love** using [Next.js](https://nextjs.org/)
```

Example 2 (unknown):
```unknown
<p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>
```

Example 3 (unknown):
```unknown
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx
```

Example 4 (python):
```python
import createMDX from '@next/mdx'
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Configure `pageExtensions` to include markdown and MDX files
  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],
  // Optionally, add any other Next.js config below
}
 
const withMDX = createMDX({
  // Add markdown plugins here, as desired
})
 
// Merge MDX config with Next.js config
export default withMDX(nextConfig)
```

---

## How to upgrade to version 14

**URL:** https://nextjs.org/docs/app/guides/upgrading/version-14

**Contents:**
- How to upgrade to version 14
- Upgrading from 13 to 14
  - v14 Summary

To update to Next.js version 14, run the following command using your preferred package manager:

Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their latest versions.

**Examples:**

Example 1 (unknown):
```unknown
npm i next@next-14 react@18 react-dom@18 && npm i eslint-config-next@next-14 -D
```

Example 2 (unknown):
```unknown
yarn add next@next-14 react@18 react-dom@18 && yarn add eslint-config-next@next-14 -D
```

Example 3 (unknown):
```unknown
pnpm i next@next-14 react@18 react-dom@18 && pnpm i eslint-config-next@next-14 -D
```

Example 4 (unknown):
```unknown
bun add next@next-14 react@18 react-dom@18 && bun add eslint-config-next@next-14 -D
```

---

## Accessibility

**URL:** https://nextjs.org/docs/architecture/accessibility

**Contents:**
- Accessibility
- Route Announcements
- Linting
- Accessibility Resources

The Next.js team is committed to making Next.js accessible to all developers (and their end-users). By adding accessibility features to Next.js by default, we aim to make the Web more inclusive for everyone.

When transitioning between pages rendered on the server (e.g. using the <a href> tag) screen readers and other assistive technology announce the page title when the page loads so that users understand that the page has changed.

In addition to traditional page navigations, Next.js also supports client-side transitions for improved performance (using next/link). To ensure that client-side transitions are also announced to assistive technology, Next.js includes a route announcer by default.

The Next.js route announcer looks for the page name to announce by first inspecting document.title, then the <h1> element, and finally the URL pathname. For the most accessible user experience, ensure that each page in your application has a unique and descriptive title.

Next.js provides an integrated ESLint experience out of the box, including custom rules for Next.js. By default, Next.js includes eslint-plugin-jsx-a11y to help catch accessibility issues early, including warning on:

For example, this plugin helps ensure you add alt text to img tags, use correct aria-* attributes, use correct role attributes, and more.

---

## How to set a Content Security Policy (CSP) for your Next.js application

**URL:** https://nextjs.org/docs/pages/guides/content-security-policy

**Contents:**
- How to set a Content Security Policy (CSP) for your Next.js application
- Nonces
  - Why use a nonce?
  - Adding a nonce with Proxy
  - How nonces work in Next.js
  - Forcing dynamic rendering
  - Reading the nonce
- Static vs Dynamic Rendering with CSP
  - Dynamic Rendering Requirement
  - Performance Implications

Content Security Policy (CSP) is important to guard your Next.js application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks.

By using CSP, developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more.

A nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives.

CSP can block both inline and external scripts to prevent attacks. A nonce lets you safely allow specific scripts to runâ€”only if they include the matching nonce value.

If an attacker wanted to load a script into your page, they'd need to guess the nonce value. That's why the nonce must be unpredictable and unique for every request.

Proxy enables you to add headers and generate nonces before the page renders.

Every time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces.

By default, Proxy runs on all requests. You can filter Proxy to run on specific paths using a matcher.

We recommend ignoring matching prefetches (from next/link) and static assets that don't need the CSP header.

To use a nonce, your page must be dynamically rendered. This is because Next.js applies nonces during server-side rendering, based on the CSP header present in the request. Static pages are generated at build time, when no request or response headers existâ€”so no nonce can be injected.

Hereâ€™s how nonce support works in a dynamically rendered page:

Because of this automatic behavior, you donâ€™t need to manually add a nonce to each tag.

If you're using nonces, you may need to explicitly opt pages into dynamic rendering:

You can provide the nonce to your page using getServerSideProps:

You can also access the nonce in _document.tsx for Pages Router applications:

Using nonces has important implications for how your Next.js application renders:

When you use nonces in your CSP, all pages must be dynamically rendered. This means:

The shift from static to dynamic rendering affects performance:

Consider nonces when:

For applications that do not require nonces, you can set the CSP header directly in your next.config.js file:

CSP implementation differs between development and production environments:

In development, you will need to enable 'unsafe-eval' to support APIs that provide additional debugging information:

Common issues in production:

When using third-party scripts with CSP, ensure you add the necessary domains and pass the nonce:

Update your CSP to allow third-party domains:

**Examples:**

Example 1 (python):
```python
import { NextRequest, NextResponse } from 'next/server'
 
export function proxy(request: NextRequest) {
  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')
  const cspHeader = `
    default-src 'self';
    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';
    style-src 'self' 'nonce-${nonce}';
    img-src 'self' blob: data:;
    font-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
`
  // Replace newline characters and spaces
  const contentSecurityPolicyHeaderValue = cspHeader
    .replace(/\s{2,}/g, ' ')
    .trim()
 
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-nonce', nonce)
 
  requestHeaders.set(
    'Content-Security-Policy',
    contentSecurityPolicyHeaderValue
  )
 
  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })
  response.headers.set(
    'Content-Security-Policy',
    contentSecurityPolicyHeaderValue
  )
 
  return response
}
```

Example 2 (javascript):
```javascript
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    {
      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',
      missing: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },
  ],
}
```

Example 3 (python):
```python
import { connection } from 'next/server'
 
export default async function Page() {
  // wait for an incoming request to render this page
  await connection()
  // Your page content
}
```

Example 4 (python):
```python
import Script from 'next/script'
 
import type { GetServerSideProps } from 'next'
 
export default function Page({ nonce }) {
  return (
    <Script
      src="https://www.googletagmanager.com/gtag/js"
      strategy="afterInteractive"
      nonce={nonce}
    />
  )
}
 
export const getServerSideProps: GetServerSideProps = async ({ req }) => {
  const nonce = req.headers['x-nonce']
  return { props: { nonce } }
}
```

---

## Custom Webpack Config

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/webpack

**Contents:**
- Custom Webpack Config
    - nextRuntime

Good to know: changes to webpack config are not covered by semver so proceed at your own risk

Before continuing to add custom webpack configuration to your application make sure Next.js doesn't already support your use-case:

Some commonly asked for features are available as plugins:

In order to extend our usage of webpack, you can define a function that extends its config inside next.config.js, like so:

The webpack function is executed three times, twice for the server (nodejs / edge runtime) and once for the client. This allows you to distinguish between client and server configuration using the isServer property.

The second argument to the webpack function is an object with the following properties:

Example usage of defaultLoaders.babel:

Notice that isServer is true when nextRuntime is "edge" or "nodejs", nextRuntime "edge" is currently for proxy and Server Components in edge runtime only.

**Examples:**

Example 1 (javascript):
```javascript
module.exports = {
  webpack: (
    config,
    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }
  ) => {
    // Important: return the modified config
    return config
  },
}
```

Example 2 (javascript):
```javascript
// Example config for adding a loader that depends on babel-loader
// This source was taken from the @next/mdx plugin source:
// https://github.com/vercel/next.js/tree/canary/packages/next-mdx
module.exports = {
  webpack: (config, options) => {
    config.module.rules.push({
      test: /\.mdx/,
      use: [
        options.defaultLoaders.babel,
        {
          loader: '@mdx-js/loader',
          options: pluginOptions.options,
        },
      ],
    })
 
    return config
  },
}
```

---

## How to self-host your Next.js application

**URL:** https://nextjs.org/docs/app/guides/self-hosting

**Contents:**
- How to self-host your Next.js application
- Reverse Proxy
- Image Optimization
- Proxy
- Environment Variables
- Caching and ISR
  - Automatic Caching
  - Static Assets
  - Configuring Caching
- Build Cache

When deploying your Next.js app, you may want to configure how different features are handled based on your infrastructure.

ðŸŽ¥ Watch: Learn more about self-hosting Next.js â†’ YouTube (45 minutes).

When self-hosting, it's recommended to use a reverse proxy (like nginx) in front of your Next.js server rather than exposing it directly to the internet. A reverse proxy can handle malformed requests, slow connection attacks, payload size limits, rate limiting, and other security concerns, offloading these tasks from the Next.js server. This allows the server to dedicate its resources to rendering rather than request validation.

Image Optimization through next/image works self-hosted with zero configuration when deploying using next start. If you would prefer to have a separate service to optimize images, you can configure an image loader.

Image Optimization can be used with a static export by defining a custom image loader in next.config.js. Note that images are optimized at runtime, not during the build.

Proxy works self-hosted with zero configuration when deploying using next start. Since it requires access to the incoming request, it is not supported when using a static export.

Proxy uses the Edge runtime, a subset of all available Node.js APIs to help ensure low latency, since it may run in front of every route or asset in your application. If you do not want this, you can use the full Node.js runtime to run Proxy.

If you are looking to add logic (or use an external package) that requires all Node.js APIs, you might be able to move this logic to a layout as a Server Component. For example, checking headers and redirecting. You can also use headers, cookies, or query parameters to redirect or rewrite through next.config.js. If that does not work, you can also use a custom server.

Next.js can support both build time and runtime environment variables.

By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.

You safely read environment variables on the server during dynamic rendering.

This allows you to use a singular Docker image that can be promoted through multiple environments with different values.

Next.js can cache responses, generated static pages, build outputs, and other static assets like images, fonts, and scripts.

Caching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. By default, this cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-hosting using both the Pages and App Router.

You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.

If you want to host static assets on a different domain or CDN, you can use the assetPrefix configuration in next.config.js. Next.js will use this asset prefix when retrieving JavaScript or CSS files. Separating your assets to a different domain does come with the downside of extra time spent on DNS and TLS resolution.

Learn more about assetPrefix.

By default, generated cache assets will be stored in memory (defaults to 50mb) and on disk. If you are hosting Next.js using a container orchestration platform like Kubernetes, each pod will have a copy of the cache. To prevent stale data from being shown since the cache is not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching.

To configure the ISR/Data Cache location when self-hosting, you can configure a custom handler in your next.config.js file:

Then, create cache-handler.js in the root of your project, for example:

Using a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application. For instance, you can save the cached values anywhere, like Redis or AWS S3.

Next.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers.

If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use the generateBuildId command in next.config.js:

Next.js will automatically mitigate most instances of version skew and automatically reload the application to retrieve new assets when detected. For example, if there is a mismatch in the deploymentId, transitions between pages will perform a hard navigation versus using a prefetched value.

When the application is reloaded, there may be a loss of application state if it's not designed to persist between page navigations. For example, using URL state or local storage would persist state after a page refresh. However, component state like useState would be lost in such navigations.

The Next.js App Router supports streaming responses when self-hosting. If you are using nginx or a similar proxy, you will need to configure it to disable buffering to enable streaming.

For example, you can disable buffering in nginx by setting X-Accel-Buffering to no:

Cache Components works by default with Next.js and is not a CDN-only feature. This includes deployment as a Node.js server (through next start) and when used with a Docker container.

When using a CDN in front on your Next.js application, the page will include Cache-Control: private response header when dynamic APIs are accessed. This ensures that the resulting HTML page is marked as non-cacheable. If the page is fully prerendered to static, it will include Cache-Control: public to allow the page to be cached on the CDN.

If you don't need a mix of both static and dynamic components, you can make your entire route static and cache the output HTML on a CDN. This Automatic Static Optimization is the default behavior when running next build if dynamic APIs are not used.

As Partial Prerendering moves to stable, we will provide support through the Deployment Adapters API.

after is fully supported when self-hosting with next start.

When stopping the server, ensure a graceful shutdown by sending SIGINT or SIGTERM signals and waiting. This allows the Next.js server to wait until after pending callback functions or promises used inside after have finished.

**Examples:**

Example 1 (python):
```python
import { connection } from 'next/server'
 
export default async function Component() {
  await connection()
  // cookies, headers, and other Dynamic APIs
  // will also opt into dynamic rendering, meaning
  // this env variable is evaluated at runtime
  const value = process.env.MY_VALUE
  // ...
}
```

Example 2 (unknown):
```unknown
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // disable default in-memory caching
}
```

Example 3 (javascript):
```javascript
const cache = new Map()
 
module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }
 
  async get(key) {
    // This could be stored anywhere, like durable storage
    return cache.get(key)
  }
 
  async set(key, data, ctx) {
    // This could be stored anywhere, like durable storage
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }
 
  async revalidateTag(tags) {
    // tags is either a string or an array of strings
    tags = [tags].flat()
    // Iterate over all entries in the cache
    for (let [key, value] of cache) {
      // If the value's tags include the specified tag, delete this entry
      if (value.tags.some((tag) => tags.includes(tag))) {
        cache.delete(key)
      }
    }
  }
 
  // If you want to have temporary in memory cache for a single request that is reset
  // before the next request you can leverage this method
  resetRequestCache() {}
}
```

Example 4 (javascript):
```javascript
module.exports = {
  generateBuildId: async () => {
    // This could be anything, using the latest git hash
    return process.env.GIT_HASH
  },
}
```

---

## images

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/images

**Contents:**
- images
- Example Loader Configuration
  - Akamai
  - AWS CloudFront
  - Cloudinary
  - Cloudflare
  - Contentful
  - Fastly
  - Gumlet
  - ImageEngine

If you want to use a cloud provider to optimize images instead of using the Next.js built-in Image Optimization API, you can configure next.config.js with the following:

This loaderFile must point to a file relative to the root of your Next.js application. The file must export a default function that returns a string, for example:

Alternatively, you can use the loader prop to pass the function to each instance of next/image.

Good to know: Customizing the image loader file, which accepts a function, requires using Client Components to serialize the provided function.

To learn more about configuring the behavior of the built-in Image Optimization API and the Image Component, see Image Configuration Options for available options.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  images: {
    loader: 'custom',
    loaderFile: './my/image/loader.js',
  },
}
```

Example 2 (unknown):
```unknown
'use client'
 
export default function myImageLoader({ src, width, quality }) {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
```

Example 3 (unknown):
```unknown
// Docs: https://techdocs.akamai.com/ivm/reference/test-images-on-demand
export default function akamaiLoader({ src, width, quality }) {
  return `https://example.com/${src}?imwidth=${width}`
}
```

Example 4 (javascript):
```javascript
// Docs: https://aws.amazon.com/developer/application-security-performance/articles/image-optimization
export default function cloudfrontLoader({ src, width, quality }) {
  const url = new URL(`https://example.com${src}`)
  url.searchParams.set('format', 'auto')
  url.searchParams.set('width', width.toString())
  url.searchParams.set('quality', (quality || 75).toString())
  return url.href
}
```

---

## How to configure Continuous Integration (CI) build caching

**URL:** https://nextjs.org/docs/app/guides/ci-build-caching

**Contents:**
- How to configure Continuous Integration (CI) build caching
- Vercel
- CircleCI
- Travis CI
- GitLab CI
- Netlify CI
- AWS CodeBuild
- GitHub Actions
- Bitbucket Pipelines
- Heroku

To improve build performance, Next.js saves a cache to .next/cache that is shared between builds.

To take advantage of this cache in Continuous Integration (CI) environments, your CI workflow will need to be configured to correctly persist the cache between builds.

If your CI is not configured to persist .next/cache between builds, you may see a No Cache Detected error.

Here are some example cache configurations for common CI providers:

Next.js caching is automatically configured for you. There's no action required on your part. If you are using Turborepo on Vercel, learn more here.

Edit your save_cache step in .circleci/config.yml to include .next/cache:

If you do not have a save_cache key, please follow CircleCI's documentation on setting up build caching.

Add or merge the following into your .travis.yml:

Add or merge the following into your .gitlab-ci.yml:

Use Netlify Plugins with @netlify/plugin-nextjs.

Add (or merge in) the following to your buildspec.yml:

Using GitHub's actions/cache, add the following step in your workflow file:

Add or merge the following into your bitbucket-pipelines.yml at the top level (same level as pipelines):

Then reference it in the caches section of your pipeline's step:

Using Heroku's custom cache, add a cacheDirectories array in your top-level package.json:

Using Azure Pipelines' Cache task, add the following task to your pipeline yaml file somewhere prior to the task that executes next build:

Using Jenkins' Job Cacher plugin, add the following build step to your Jenkinsfile where you would normally run next build or npm install:

**Examples:**

Example 1 (unknown):
```unknown
steps:
  - save_cache:
      key: dependency-cache-{{ checksum "yarn.lock" }}
      paths:
        - ./node_modules
        - ./.next/cache
```

Example 2 (unknown):
```unknown
cache:
  directories:
    - $HOME/.cache/yarn
    - node_modules
    - .next/cache
```

Example 3 (unknown):
```unknown
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - .next/cache/
```

Example 4 (unknown):
```unknown
cache:
  paths:
    - 'node_modules/**/*' # Cache `node_modules` for faster `yarn` or `npm i`
    - '.next/cache/**/*' # Cache Next.js for faster application rebuilds
```

---

## Upgrade Guides

**URL:** https://nextjs.org/docs/app/guides/upgrading

**Contents:**
- Upgrade Guides
  - Codemods
  - Version 14
  - Version 15
  - Version 16

Learn how to upgrade to the latest versions of Next.js following the versions-specific guides:

---

## No `styled-jsx` in `_document`

**URL:** https://nextjs.org/docs/messages/no-styled-jsx-in-document

**Contents:**
- No `styled-jsx` in `_document`
- Why This Error Occurred
- Possible Ways to Fix It
- Useful Links

Prevent usage of styled-jsx in pages/_document.js.

Custom CSS like styled-jsx is not allowed in a Custom Document.

If you need shared CSS for all of your pages, take a look at the Custom App file or define a custom layout.

For example, consider the following stylesheet named styles.css:

Create a pages/_app.{js,tsx} file if not already present. Then, import the styles.css file.

These styles (styles.css) will apply to all pages and components in your application.

**Examples:**

Example 1 (unknown):
```unknown
body {
  font-family:
    'SF Pro Text', 'SF Pro Icons', 'Helvetica Neue', 'Helvetica', 'Arial',
    sans-serif;
  padding: 20px 20px 60px;
  max-width: 680px;
  margin: 0 auto;
}
```

Example 2 (unknown):
```unknown
import '../styles.css'
 
// This default export is required in a new `pages/_app.js` file.
export default function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />
}
```

---

## generateBuildId

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/generateBuildId

**Contents:**
- generateBuildId

Next.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers.

If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use the generateBuildId command in next.config.js:

**Examples:**

Example 1 (javascript):
```javascript
module.exports = {
  generateBuildId: async () => {
    // This could be anything, using the latest git hash
    return process.env.GIT_HASH
  },
}
```

---

## Configuration

**URL:** https://nextjs.org/docs/15/app/api-reference/config

**Contents:**
- Configuration
  - next.config.js
  - TypeScript
  - ESLint

---

## src Directory

**URL:** https://nextjs.org/docs/pages/api-reference/file-conventions/src-folder

**Contents:**
- src Directory

As an alternative to having the special Next.js app or pages directories in the root of your project, Next.js also supports the common pattern of placing application code under the src folder.

This separates application code from project configuration files which mostly live in the root of a project, which is preferred by some individuals and teams.

To use the src folder, move the app Router folder or pages Router folder to src/app or src/pages respectively.

---

## How to set up instrumentation with OpenTelemetry

**URL:** https://nextjs.org/docs/15/app/guides/open-telemetry

**Contents:**
- How to set up instrumentation with OpenTelemetry
- Getting Started
  - Using @vercel/otel
  - Manual OpenTelemetry configuration
- Testing your instrumentation
- Deployment
  - Using OpenTelemetry Collector
    - Deploying on Vercel
    - Self-hosting
  - Custom Exporters

Observability is crucial for understanding and optimizing the behavior and performance of your Next.js app.

As applications become more complex, it becomes increasingly difficult to identify and diagnose issues that may arise. By leveraging observability tools, such as logging and metrics, developers can gain insights into their application's behavior and identify areas for optimization. With observability, developers can proactively address issues before they become major problems and provide a better user experience. Therefore, it is highly recommended to use observability in your Next.js applications to improve performance, optimize resources, and enhance user experience.

We recommend using OpenTelemetry for instrumenting your apps. It's a platform-agnostic way to instrument apps that allows you to change your observability provider without changing your code. Read Official OpenTelemetry docs for more information about OpenTelemetry and how it works.

This documentation uses terms like Span, Trace or Exporter throughout this doc, all of which can be found in the OpenTelemetry Observability Primer.

Next.js supports OpenTelemetry instrumentation out of the box, which means that we already instrumented Next.js itself.

OpenTelemetry is extensible but setting it up properly can be quite verbose. That's why we prepared a package @vercel/otel that helps you get started quickly.

To get started, install the following packages:

Next, create a custom instrumentation.ts (or .js) file in the root directory of the project (or inside src folder if using one):

See the @vercel/otel documentation for additional configuration options.

The @vercel/otel package provides many configuration options and should serve most of common use cases. But if it doesn't suit your needs, you can configure OpenTelemetry manually.

Firstly you need to install OpenTelemetry packages:

Now you can initialize NodeSDK in your instrumentation.ts. Unlike @vercel/otel, NodeSDK is not compatible with edge runtime, so you need to make sure that you are importing them only when process.env.NEXT_RUNTIME === 'nodejs'. We recommend creating a new file instrumentation.node.ts which you conditionally import only when using node:

Doing this is equivalent to using @vercel/otel, but it's possible to modify and extend some features that are not exposed by the @vercel/otel. If edge runtime support is necessary, you will have to use @vercel/otel.

You need an OpenTelemetry collector with a compatible backend to test OpenTelemetry traces locally. We recommend using our OpenTelemetry dev environment.

If everything works well you should be able to see the root server span labeled as GET /requested/pathname. All other spans from that particular trace will be nested under it.

Next.js traces more spans than are emitted by default. To see more spans, you must set NEXT_OTEL_VERBOSE=1.

When you are deploying with OpenTelemetry Collector, you can use @vercel/otel. It will work both on Vercel and when self-hosted.

We made sure that OpenTelemetry works out of the box on Vercel.

Follow Vercel documentation to connect your project to an observability provider.

Deploying to other platforms is also straightforward. You will need to spin up your own OpenTelemetry Collector to receive and process the telemetry data from your Next.js app.

To do this, follow the OpenTelemetry Collector Getting Started guide, which will walk you through setting up the collector and configuring it to receive data from your Next.js app.

Once you have your collector up and running, you can deploy your Next.js app to your chosen platform following their respective deployment guides.

OpenTelemetry Collector is not necessary. You can use a custom OpenTelemetry exporter with @vercel/otel or manual OpenTelemetry configuration.

You can add a custom span with OpenTelemetry APIs.

The following example demonstrates a function that fetches GitHub stars and adds a custom fetchGithubStars span to track the fetch request's result:

The register function will execute before your code runs in a new environment. You can start creating new spans, and they should be correctly added to the exported trace.

Next.js automatically instruments several spans for you to provide useful insights into your application's performance.

Attributes on spans follow OpenTelemetry semantic conventions. We also add some custom attributes under the next namespace:

This span represents the root span for each incoming request to your Next.js application. It tracks the HTTP method, route, target, and status code of the request.

This span represents the process of rendering a route in the app router.

This span represents the fetch request executed in your code.

This span can be turned off by setting NEXT_OTEL_FETCH_DISABLED=1 in your environment. This is useful when you want to use a custom fetch instrumentation library.

This span represents the execution of an API Route Handler in the app router.

This span represents the execution of getServerSideProps for a specific route.

This span represents the execution of getStaticProps for a specific route.

This span represents the process of rendering the document for a specific route.

This span represents the process of generating metadata for a specific page (a single route can have multiple of these spans).

This span represents the process of resolving page components for a specific page.

This span represents loading of code modules for a layout or a page.

This zero-length span represents the time when the first byte has been sent in the response.

**Examples:**

Example 1 (unknown):
```unknown
npm install @vercel/otel @opentelemetry/sdk-logs @opentelemetry/api-logs @opentelemetry/instrumentation
```

Example 2 (python):
```python
import { registerOTel } from '@vercel/otel'
 
export function register() {
  registerOTel({ serviceName: 'next-app' })
}
```

Example 3 (unknown):
```unknown
npm install @opentelemetry/sdk-node @opentelemetry/resources @opentelemetry/semantic-conventions @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http
```

Example 4 (unknown):
```unknown
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./instrumentation.node.ts')
  }
}
```

---

## Custom Next.js Cache Handler

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/incrementalCacheHandlerPath

**Contents:**
- Custom Next.js Cache Handler
- API Reference
  - get()
  - set()
  - revalidateTag()
  - resetRequestCache()
- Platform Support
- Version History

You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.

Good to know: The cacheHandler configuration is specifically used by Next.js for server cache operations such as storing and revalidating ISR and route handler responses. It is not used by 'use cache', 'use cache: remote', nor 'use cache: private', which manage their own cache independently.

View an example of a custom cache handler and learn more about the implementation.

The cache handler can implement the following methods: get, set, revalidateTag, and resetRequestCache.

Returns the cached value or null if not found.

Returns Promise<void>.

Returns Promise<void>. Learn more about revalidating data or the revalidateTag() function.

This method resets the temporary in-memory cache for a single request before the next request.

Learn how to configure ISR when self-hosting Next.js.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // disable default in-memory caching
}
```

---

## compress

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/compress

**Contents:**
- compress
- Disabling compression

By default, Next.js uses gzip to compress rendered content and static files when using next start or a custom server. This is an optimization for applications that do not have compression configured. If compression is already configured in your application via a custom server, Next.js will not add compression.

You can check if compression is enabled and which algorithm is used by looking at the Accept-Encoding (browser accepted options) and Content-Encoding (currently used) headers in the response.

To disable compression, set the compress config option to false:

We do not recommend disabling compression unless you have compression configured on your server, as compression reduces bandwidth usage and improves the performance of your application. For example, you're using nginx and want to switch to brotli, set the compress option to false to allow nginx to handle compression.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  compress: false,
}
```

---

## How to implement authentication in Next.js

**URL:** https://nextjs.org/docs/15/app/guides/authentication

**Contents:**
- How to implement authentication in Next.js
- Authentication
  - Sign-up and login functionality
    - 1. Capture user credentials
    - 2. Validate form fields on the server
    - 3. Create a user or check user credentials
- Session Management
  - Stateless Sessions
    - 1. Generating a secret key
    - 2. Encrypting and decrypting sessions

Understanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth.

Before starting, it helps to break down the process into three concepts:

This diagram shows the authentication flow using React and Next.js features:

The examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the Auth Libraries section.

You can use the <form> element with React's Server Actions and useActionState to capture user credentials, validate form fields, and call your Authentication Provider's API or database.

Since Server Actions always execute on the server, they provide a secure environment for handling authentication logic.

Here are the steps to implement signup/login functionality:

To capture user credentials, create a form that invokes a Server Action on submission. For example, a signup form that accepts the user's name, email, and password:

Use the Server Action to validate the form fields on the server. If your authentication provider doesn't provide form validation, you can use a schema validation library like Zod or Yup.

Using Zod as an example, you can define a form schema with appropriate error messages:

To prevent unnecessary calls to your authentication provider's API or database, you can return early in the Server Action if any form fields do not match the defined schema.

Back in your <SignupForm />, you can use React's useActionState hook to display validation errors while the form is submitting:

After validating form fields, you can create a new user account or check if the user exists by calling your authentication provider's API or database.

Continuing from the previous example:

After successfully creating the user account or verifying the user credentials, you can create a session to manage the user's auth state. Depending on your session management strategy, the session can be stored in a cookie or database, or both. Continue to the Session Management section to learn more.

Session management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens.

There are two types of sessions:

Good to know: While you can use either method, or both, we recommend using a session management library such as iron-session or Jose.

To create and manage stateless sessions, there are a few steps you need to follow:

In addition to the above, consider adding functionality to update (or refresh) the session when the user returns to the application, and delete the session when the user logs out.

Good to know: Check if your auth library includes session management.

There are a few ways you can generate secret key to sign your session. For example, you may choose to use the openssl command in your terminal:

This command generates a 32-character random string that you can use as your secret key and store in your environment variables file:

You can then reference this key in your session management logic:

Next, you can use your preferred session management library to encrypt and decrypt sessions. Continuing from the previous example, we'll use Jose (compatible with the Edge Runtime) and React's server-only package to ensure that your session management logic is only executed on the server.

To store the session in a cookie, use the Next.js cookies API. The cookie should be set on the server, and include the recommended options:

Please refer to MDN for more information on each of these options.

Back in your Server Action, you can invoke the createSession() function, and use the redirect() API to redirect the user to the appropriate page:

You can also extend the session's expiration time. This is useful for keeping the user logged in after they access the application again. For example:

Tip: Check if your auth library supports refresh tokens, which can be used to extend the user's session.

To delete the session, you can delete the cookie:

Then you can reuse the deleteSession() function in your application, for example, on logout:

To create and manage database sessions, you'll need to follow these steps:

After implementing session management, you'll need to add authorization logic to control what users can access and do within your application. Continue to the Authorization section to learn more.

Once a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application.

There are two main types of authorization checks:

For both cases, we recommend:

There are some cases where you may want to use Middleware and redirect users based on permissions:

However, since Middleware runs on every route, including prefetched routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues.

While Middleware can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information.

We recommend creating a DAL to centralize your data requests and authorization logic.

The DAL should include a function that verifies the user's session as they interact with your application. At the very least, the function should check if the session is valid, then redirect or return the user information needed to make further requests.

For example, create a separate file for your DAL that includes a verifySession() function. Then use React's cache API to memoize the return value of the function during a React render pass:

You can then invoke the verifySession() function in your data requests, Server Actions, Route Handlers:

When retrieving data, it's recommended you return only the necessary data that will be used in your application, and not entire objects. For example, if you're fetching user data, you might only return the user's ID and name, rather than the entire user object which could contain passwords, phone numbers, etc.

However, if you have no control over the returned data structure, or are working in a team where you want to avoid whole objects being passed to the client, you can use strategies such as specifying what fields are safe to be exposed to the client.

By centralizing your data requests and authorization logic in a DAL and using DTOs, you can ensure that all data requests are secure and consistent, making it easier to maintain, audit, and debug as your application scales.

Auth check in Server Components are useful for role-based access. For example, to conditionally render components based on the user's role:

In the example, we use the verifySession() function from our DAL to check for 'admin', 'user', and unauthorized roles. This pattern ensures that each user interacts only with components appropriate to their role.

Due to Partial Rendering, be cautious when doing checks in Layouts as these don't re-render on navigation, meaning the user session won't be checked on every route change.

Instead, you should do the checks close to your data source or the component that'll be conditionally rendered.

For example, consider a shared layout that fetches the user data and displays the user image in a nav. Instead of doing the auth check in the layout, you should fetch the user data (getUser()) in the layout and do the auth check in your DAL.

This guarantees that wherever getUser() is called within your application, the auth check is performed, and prevents developers forgetting to check the user is authorized to access the data.

Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation.

In the example below, we check the user's role before allowing the action to proceed:

Treat Route Handlers with the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler.

The example above demonstrates a Route Handler with a two-tier security check. It first checks for an active session, and then verifies if the logged-in user is an 'admin'.

Using context providers for auth works due to interleaving. However, React context is not supported in Server Components, making them only applicable to Client Components.

This works, but any child Server Components will be rendered on the server first, and will not have access to the context providerâ€™s session data:

If session data is needed in Client Components (e.g. for client-side data fetching), use Reactâ€™s taintUniqueValue API to prevent sensitive session data from being exposed to the client.

Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:

To continue learning about authentication and security, check out the following resources:

**Examples:**

Example 1 (python):
```python
import { signup } from '@/app/actions/auth'
 
export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

Example 2 (unknown):
```unknown
export async function signup(formData: FormData) {}
```

Example 3 (python):
```python
import { z } from 'zod'
 
export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { message: 'Name must be at least 2 characters long.' })
    .trim(),
  email: z.string().email({ message: 'Please enter a valid email.' }).trim(),
  password: z
    .string()
    .min(8, { message: 'Be at least 8 characters long' })
    .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })
    .regex(/[0-9]/, { message: 'Contain at least one number.' })
    .regex(/[^a-zA-Z0-9]/, {
      message: 'Contain at least one special character.',
    })
    .trim(),
})
 
export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

Example 4 (python):
```python
import { SignupFormSchema, FormState } from '@/app/lib/definitions'
 
export async function signup(state: FormState, formData: FormData) {
  // Validate form fields
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })
 
  // If any form fields are invalid, return early
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }
 
  // Call the provider or db to create a user...
}
```

---

## next.config.js

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js

**Contents:**
- next.config.js
- ECMAScript Modules
- Configuration as a Function
  - Async Configuration
  - Phase
- TypeScript
- Unit Testing (experimental)
  - experimental.adapterPath
  - allowedDevOrigins
  - appDir

Next.js can be configured through a next.config.js file in the root of your project directory (for example, by package.json) with a default export.

next.config.js is a regular Node.js module, not a JSON file. It gets used by the Next.js server and build phases, and it's not included in the browser build.

If you need ECMAScript modules, you can use next.config.mjs:

Good to know: next.config with the .cjs or .cts extensions are currently not supported.

You can also use a function:

Since Next.js 12.1.0, you can use an async function:

phase is the current context in which the configuration is loaded. You can see the available phases. Phases can be imported from next/constants:

If you are using TypeScript in your project, you can use next.config.ts to use TypeScript in your configuration:

The commented lines are the place where you can put the configs allowed by next.config.js, which are defined in this file.

However, none of the configs are required, and it's not necessary to understand what each config does. Instead, search for the features you need to enable or modify in this section and they will show you what to do.

Avoid using new JavaScript features not available in your target Node.js version. next.config.js will not be parsed by Webpack or Babel.

This page documents all the available configuration options:

Starting in Next.js 15.1, the next/experimental/testing/server package contains utilities to help unit test next.config.js files.

The unstable_getResponseFromNextConfig function runs the headers, redirects, and rewrites functions from next.config.js with the provided request information and returns NextResponse with the results of the routing.

The response from unstable_getResponseFromNextConfig only considers next.config.js fields and does not consider proxy or filesystem routes, so the result in production may be different than the unit test.

**Examples:**

Example 1 (javascript):
```javascript
// @ts-check
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
}
 
module.exports = nextConfig
```

Example 2 (javascript):
```javascript
// @ts-check
 
/**
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  /* config options here */
}
 
export default nextConfig
```

Example 3 (javascript):
```javascript
// @ts-check
 
export default (phase, { defaultConfig }) => {
  /**
   * @type {import('next').NextConfig}
   */
  const nextConfig = {
    /* config options here */
  }
  return nextConfig
}
```

Example 4 (javascript):
```javascript
// @ts-check
 
module.exports = async (phase, { defaultConfig }) => {
  /**
   * @type {import('next').NextConfig}
   */
  const nextConfig = {
    /* config options here */
  }
  return nextConfig
}
```

---

## Error Handling

**URL:** https://nextjs.org/docs/pages/building-your-application/configuring/error-handling

**Contents:**
- Error Handling
- Handling expected errors
  - Server Functions
  - Server Components
  - Not found
- Handling uncaught exceptions
  - Nested error boundaries
  - Global errors
- API Reference
  - redirect

Errors can be divided into two categories: expected errors and uncaught exceptions. This page will walk you through how you can handle these errors in your Next.js application.

Expected errors are those that can occur during the normal operation of the application, such as those from server-side form validation or failed requests. These errors should be handled explicitly and returned to the client.

You can use the useActionState hook to handle expected errors in Server Functions.

For these errors, avoid using try/catch blocks and throw errors. Instead, model expected errors as return values.

You can pass your action to the useActionState hook and use the returned state to display an error message.

When fetching data inside of a Server Component, you can use the response to conditionally render an error message or redirect.

You can call the notFound function within a route segment and use the not-found.js file to show a 404 UI.

Uncaught exceptions are unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application. These should be handled by throwing errors, which will then be caught by error boundaries.

Next.js uses error boundaries to handle uncaught exceptions. Error boundaries catch errors in their child components and display a fallback UI instead of the component tree that crashed.

Create an error boundary by adding an error.js file inside a route segment and exporting a React component:

Errors will bubble up to the nearest parent error boundary. This allows for granular error handling by placing error.tsx files at different levels in the route hierarchy.

Error boundaries donâ€™t catch errors inside event handlers. Theyâ€™re designed to catch errors during rendering to show a fallback UI instead of crashing the whole app.

In general, errors in event handlers or async code arenâ€™t handled by error boundaries because they run after rendering.

To handle these cases, catch the error manually and store it using useState or useReducer, then update the UI to inform the user.

Note that unhandled errors inside startTransition from useTransition, will bubble up to the nearest error boundary.

While less common, you can handle errors in the root layout using the global-error.js file, located in the root app directory, even when leveraging internationalization. Global error UI must define its own <html> and <body> tags, since it is replacing the root layout or template when active.

**Examples:**

Example 1 (javascript):
```javascript
'use server'
 
export async function createPost(prevState: any, formData: FormData) {
  const title = formData.get('title')
  const content = formData.get('content')
 
  const res = await fetch('https://api.vercel.app/posts', {
    method: 'POST',
    body: { title, content },
  })
  const json = await res.json()
 
  if (!res.ok) {
    return { message: 'Failed to create post' }
  }
}
```

Example 2 (python):
```python
'use client'
 
import { useActionState } from 'react'
import { createPost } from '@/app/actions'
 
const initialState = {
  message: '',
}
 
export function Form() {
  const [state, formAction, pending] = useActionState(createPost, initialState)
 
  return (
    <form action={formAction}>
      <label htmlFor="title">Title</label>
      <input type="text" id="title" name="title" required />
      <label htmlFor="content">Content</label>
      <textarea id="content" name="content" required />
      {state?.message && <p aria-live="polite">{state.message}</p>}
      <button disabled={pending}>Create Post</button>
    </form>
  )
}
```

Example 3 (javascript):
```javascript
export default async function Page() {
  const res = await fetch(`https://...`)
  const data = await res.json()
 
  if (!res.ok) {
    return 'There was an error.'
  }
 
  return '...'
}
```

Example 4 (python):
```python
import { getPostBySlug } from '@/lib/posts'
 
export default async function Page({ params }: { params: { slug: string } }) {
  const { slug } = await params
  const post = getPostBySlug(slug)
 
  if (!post) {
    notFound()
  }
 
  return <div>{post.title}</div>
}
```

---

## exportPathMap

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/exportPathMap

**Contents:**
- exportPathMap
- Adding a trailing slash
- Customizing the output directory

This feature is exclusive to next export and currently deprecated in favor of getStaticPaths with pages or generateStaticParams with app.

exportPathMap allows you to specify a mapping of request paths to page destinations, to be used during export. Paths defined in exportPathMap will also be available when using next dev.

Let's start with an example, to create a custom exportPathMap for an app with the following pages:

Open next.config.js and add the following exportPathMap config:

Good to know: the query field in exportPathMap cannot be used with automatically statically optimized pages or getStaticProps pages as they are rendered to HTML files at build-time and additional query information cannot be provided during next export.

The pages will then be exported as HTML files, for example, /about will become /about.html.

exportPathMap is an async function that receives 2 arguments: the first one is defaultPathMap, which is the default map used by Next.js. The second argument is an object with:

The returned object is a map of pages where the key is the pathname and the value is an object that accepts the following fields:

The exported pathname can also be a filename (for example, /readme.md), but you may need to set the Content-Type header to text/html when serving its content if it is different than .html.

It is possible to configure Next.js to export pages as index.html files and require trailing slashes, /about becomes /about/index.html and is routable via /about/. This was the default behavior prior to Next.js 9.

To switch back and add a trailing slash, open next.config.js and enable the trailingSlash config:

next export will use out as the default output directory, you can customize this using the -o argument, like so:

Warning: Using exportPathMap is deprecated and is overridden by getStaticPaths inside pages. We don't recommend using them together.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  exportPathMap: async function (
    defaultPathMap,
    { dev, dir, outDir, distDir, buildId }
  ) {
    return {
      '/': { page: '/' },
      '/about': { page: '/about' },
      '/p/hello-nextjs': { page: '/post', query: { title: 'hello-nextjs' } },
      '/p/learn-nextjs': { page: '/post', query: { title: 'learn-nextjs' } },
      '/p/deploy-nextjs': { page: '/post', query: { title: 'deploy-nextjs' } },
    }
  },
}
```

Example 2 (unknown):
```unknown
module.exports = {
  trailingSlash: true,
}
```

Example 3 (unknown):
```unknown
next export -o outdir
```

---

## Turbopack FileSystem Caching

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopackFileSystemCache

**Contents:**
- Turbopack FileSystem Caching
- Usage
- Version Changes

Turbopack FileSystem Cache enables Turbopack to reduce work across next dev or next build commands. When enabled, Turbopack will save and restore data to the .next folder between builds, which can greatly speed up subsequent builds and dev sessions.

Good to know: The FileSystem Cache feature is Beta and is still under development. Users adopting should expect some stability issues. We recommend first adopting it for development.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    // Enable filesystem caching for `next dev`
    turbopackFileSystemCacheForDev: true,
    // Enable filesystem caching for `next build`
    turbopackFileSystemCacheForBuild: true,
  },
}
 
export default nextConfig
```

---

## Intercepting Routes

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/intercepting-routes

**Contents:**
- Intercepting Routes
- Convention
- Examples
  - Modals
- Next Steps
  - Parallel Routes

Intercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route without the user switching to a different context.

For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js intercepts the /photo/123 route, masks the URL, and overlays it over /feed.

However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render instead of the modal. No route interception should occur.

Intercepting routes can be defined with the (..) convention, which is similar to relative path convention ../ but for route segments.

For example, you can intercept the photo segment from within the feed segment by creating a (..)photo directory.

Good to know: The (..) convention is based on route segments, not the file-system. For example, it does not consider @slot folders in Parallel Routes.

Intercepting Routes can be used together with Parallel Routes to create modals. This allows you to solve common challenges when building modals, such as:

Consider the following UI pattern, where a user can open a photo modal from a gallery using client-side navigation, or navigate to the photo page directly from a shareable URL:

In the above example, the path to the photo segment can use the (..) matcher since @modal is a slot and not a segment. This means that the photo route is only one segment level higher, despite being two file-system levels higher.

See the Parallel Routes documentation for a step-by-step example, or see our image gallery example.

---

## Link

**URL:** https://nextjs.org/docs/pages/api-reference/components/link

**Contents:**
- Link
- Reference
  - href (required)
  - replace
  - scroll
  - prefetch
  - shallow
  - locale
  - as
  - onNavigate

<Link> is a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.

The following props can be passed to the <Link> component:

Good to know: <a> tag attributes such as className or target="_blank" can be added to <Link> as props and will be passed to the underlying <a> element.

The path or URL to navigate to.

Defaults to false. When true, next/link will replace the current history state instead of adding a new URL into the browser's history stack.

Defaults to true. The default scrolling behavior of <Link> in Next.js is to maintain scroll position, similar to how browsers handle back and forwards navigation. When you navigate to a new Page, scroll position will stay the same as long as the Page is visible in the viewport. However, if the Page is not visible in the viewport, Next.js will scroll to the top of the first Page element.

When scroll = {false}, Next.js will not attempt to scroll to the first Page element.

Good to know: Next.js checks if scroll: false before managing scroll behavior. If scrolling is enabled, it identifies the relevant DOM node for navigation and inspects each top-level element. All non-scrollable elements and those without rendered HTML are bypassed, this includes sticky or fixed positioned elements, and non-visible elements such as those calculated with getBoundingClientRect. Next.js then continues through siblings until it identifies a scrollable element that is visible in the viewport.

Prefetching happens when a <Link /> component enters the user's viewport (initially or through scroll). Next.js prefetches and loads the linked route (denoted by the href) and data in the background to improve the performance of client-side navigation's. Prefetching is only enabled in production.

The following values can be passed to the prefetch prop:

Update the path of the current page without rerunning getStaticProps, getServerSideProps or getInitialProps. Defaults to false.

The active locale is automatically prepended. locale allows for providing a different locale. When false href has to include the locale as the default behavior is disabled.

Optional decorator for the path that will be shown in the browser URL bar. Before Next.js 9.5.3 this was used for dynamic routes, check our previous docs to see how it worked.

When this path differs from the one provided in href the previous href/as behavior is used as shown in the previous docs.

An event handler called during client-side navigation. The handler receives an event object that includes a preventDefault() method, allowing you to cancel the navigation if needed.

Good to know: While onClick and onNavigate may seem similar, they serve different purposes. onClick executes for all click events, while onNavigate only runs during client-side navigation. Some key differences:

The following examples demonstrate how to use the <Link> component in different scenarios.

For dynamic route segments, it can be handy to use template literals to create the link's path.

For example, you can generate a list of links to the dynamic route pages/blog/[slug].js

If you'd like to scroll to a specific id on navigation, you can append your URL with a # hash link or just pass a hash link to the href prop. This is possible since <Link> renders to an <a> element.

Link can also receive a URL object and it will automatically format it to create the URL string:

The above example has a link to:

You can use every property as defined in the Node.js URL module documentation.

The default behavior of the Link component is to push a new URL into the history stack. You can use the replace prop to prevent adding a new entry, as in the following example:

The default behavior of Link is to scroll to the top of the page. When there is a hash defined it will scroll to the specific id, like a normal <a> tag. To prevent scrolling to the top / hash scroll={false} can be added to Link:

It's common to use Proxy for authentication or other purposes that involve rewriting the user to a different page. In order for the <Link /> component to properly prefetch links with rewrites via Proxy, you need to tell Next.js both the URL to display and the URL to prefetch. This is required to avoid un-necessary fetches to proxy to know the correct route to prefetch.

For example, if you want to serve a /dashboard route that has authenticated and visitor views, you can add the following in your Proxy to redirect the user to the correct page:

In this case, you would want to use the following code in your <Link /> component:

Good to know: If you're using Dynamic Routes, you'll need to adapt your as and href props. For example, if you have a Dynamic Route like /dashboard/authed/[user] that you want to present differently via proxy, you would write: <Link href={{ pathname: '/dashboard/authed/[user]', query: { user: username } }} as="/dashboard/[user]">Profile</Link>.

**Examples:**

Example 1 (python):
```python
import Link from 'next/link'
 
export default function Home() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

Example 2 (python):
```python
import Link from 'next/link'
 
// Navigate to /about?name=test
export default function Home() {
  return (
    <Link
      href={{
        pathname: '/about',
        query: { name: 'test' },
      }}
    >
      About
    </Link>
  )
}
```

Example 3 (python):
```python
import Link from 'next/link'
 
export default function Home() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

Example 4 (python):
```python
import Link from 'next/link'
 
export default function Home() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

---

## generateEtags

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/generateEtags

**Contents:**
- generateEtags

Next.js will generate etags for every page by default. You may want to disable etag generation for HTML pages depending on your cache strategy.

Open next.config.js and disable the generateEtags option:

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  generateEtags: false,
}
```

---

## public Folder

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/public-folder

**Contents:**
- public Folder
- Caching
- Robots, Favicons, and others

Next.js can serve static files, like images, under a folder called public in the root directory. Files inside public can then be referenced by your code starting from the base URL (/).

For example, the file public/avatars/me.png can be viewed by visiting the /avatars/me.png path. The code to display that image might look like:

Next.js cannot safely cache assets in the public folder because they may change. The default caching headers applied are:

For static metadata files, such as robots.txt, favicon.ico, etc, you should use special metadata files inside the app folder.

**Examples:**

Example 1 (python):
```python
import Image from 'next/image'
 
export function Avatar({ id, alt }) {
  return <Image src={`/avatars/${id}.png`} alt={alt} width="64" height="64" />
}
 
export function AvatarOfMe() {
  return <Avatar id="me" alt="A portrait of me" />
}
```

Example 2 (unknown):
```unknown
Cache-Control: public, max-age=0
```

---

## permanentRedirect

**URL:** https://nextjs.org/docs/app/api-reference/functions/permanentRedirect

**Contents:**
- permanentRedirect
- Parameters
- Returns
- Example
- Next Steps
  - redirect

The permanentRedirect function allows you to redirect the user to another URL. permanentRedirect can be used in Server Components, Client Components, Route Handlers, and Server Actions.

When used in a streaming context, this will insert a meta tag to emit the redirect on the client side. When used in a server action, it will serve a 303 HTTP redirect response to the caller. Otherwise, it will serve a 308 (Permanent) HTTP redirect response to the caller.

If a resource doesn't exist, you can use the notFound function instead.

Good to know: If you prefer to return a 307 (Temporary) HTTP redirect instead of 308 (Permanent), you can use the redirect function instead.

The permanentRedirect function accepts two arguments:

By default, permanentRedirect will use push (adding a new entry to the browser history stack) in Server Actions and replace (replacing the current URL in the browser history stack) everywhere else. You can override this behavior by specifying the type parameter.

The type parameter has no effect when used in Server Components.

permanentRedirect does not return a value.

Invoking the permanentRedirect() function throws a NEXT_REDIRECT error and terminates rendering of the route segment in which it was thrown.

Good to know: permanentRedirect does not require you to use return permanentRedirect() as it uses the TypeScript never type.

**Examples:**

Example 1 (unknown):
```unknown
permanentRedirect(path, type)
```

Example 2 (python):
```python
import { permanentRedirect } from 'next/navigation'
 
async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({ params }) {
  const { id } = await params
  const team = await fetchTeam(id)
  if (!team) {
    permanentRedirect('/login')
  }
 
  // ...
}
```

---

## Building Your Application

**URL:** https://nextjs.org/docs/pages/building-your-application

**Contents:**
- Building Your Application
  - Routing
  - Rendering
  - Data Fetching
  - Configuring

---

## Dynamic Route Segments

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes

**Contents:**
- Dynamic Route Segments
- Convention
  - In Client Components
  - Catch-all Segments
  - Optional Catch-all Segments
  - TypeScript
- Behavior
- Examples
  - With generateStaticParams
- Next Steps

When you don't know the exact route segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.

A Dynamic Segment can be created by wrapping a folder's name in square brackets: [folderName]. For example, a blog could include the following route app/blog/[slug]/page.js where [slug] is the Dynamic Segment for blog posts.

Dynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions.

In a Client Component page, dynamic segments from props can be accessed using the use hook.

Alternatively Client Components can use the useParams hook to access the params anywhere in the Client Component tree.

Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...folderName].

For example, app/shop/[...slug]/page.js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-shirts, and so on.

Catch-all Segments can be made optional by including the parameter in double square brackets: [[...folderName]].

For example, app/shop/[[...slug]]/page.js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts.

The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also matched (/shop in the example above).

When using TypeScript, you can add types for params depending on your configured route segment â€” use PageProps<'/route'>, LayoutProps<'/route'>, or RouteContext<'/route'> to type params in page, layout, and route respectively.

Route params values are typed as string, string[], or undefined (for optional catch-all segments), because their values aren't known until runtime. Users can enter any URL into the address bar, and these broad types help ensure that your application code handles all these possible cases.

If you're working on a route where params can only have a fixed number of valid values, such as a [locale] param with a known set of language codes, you can use runtime validation to handle any invalid params a user may enter, and let the rest of your application work with the narrower type from your known set.

The generateStaticParams function can be used to statically generate routes at build time instead of on-demand at request time.

When using fetch inside the generateStaticParams function, the requests are automatically deduplicated. This avoids multiple network calls for the same data Layouts, Pages, and other generateStaticParams functions, speeding up build time.

**Examples:**

Example 1 (javascript):
```javascript
export default async function Page({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  return <div>My Post: {slug}</div>
}
```

Example 2 (python):
```python
'use client'
import { use } from 'react'
 
export default function BlogPostPage({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = use(params)
 
  return (
    <div>
      <p>{slug}</p>
    </div>
  )
}
```

Example 3 (python):
```python
import { notFound } from 'next/navigation'
import type { Locale } from '@i18n/types'
import { isValidLocale } from '@i18n/utils'
 
function assertValidLocale(value: string): asserts value is Locale {
  if (!isValidLocale(value)) notFound()
}
 
export default async function Page(props: PageProps<'/[locale]'>) {
  const { locale } = await props.params // locale is typed as string
  assertValidLocale(locale)
  // locale is now typed as Locale
}
```

Example 4 (javascript):
```javascript
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())
 
  return posts.map((post) => ({
    slug: post.slug,
  }))
}
```

---

## Parallel Routes

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/parallel-routes

**Contents:**
- Parallel Routes
- Convention
  - Slots
  - default.js
- Behavior
- Examples
  - With useSelectedLayoutSegment(s)
  - Conditional Routes
  - Tab Groups
  - Modals

Parallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.

For example, considering a dashboard, you can use parallel routes to simultaneously render the team and analytics pages:

Parallel routes are created using named slots. Slots are defined with the @folder convention. For example, the following file structure defines two slots: @analytics and @team:

Slots are passed as props to the shared parent layout. For the example above, the component in app/layout.js now accepts the @analytics and @team slots props, and can render them in parallel alongside the children prop:

However, slots are not route segments and do not affect the URL structure. For example, for /@analytics/views, the URL will be /views since @analytics is a slot. Slots are combined with the regular Page component to form the final page associated with the route segment. Because of this, you cannot have separate static and dynamic slots at the same route segment level. If one slot is dynamic, all slots at that level must be dynamic.

You can define a default.js file to render as a fallback for unmatched slots during the initial load or full-page reload.

Consider the following folder structure. The @team slot has a /settings page, but @analytics does not.

When navigating to /settings, the @team slot will render the /settings page while maintaining the currently active page for the @analytics slot.

On refresh, Next.js will render a default.js for @analytics. If default.js doesn't exist, a 404 is rendered instead.

Additionally, since children is an implicit slot, you also need to create a default.js file to render a fallback for children when Next.js cannot recover the active state of the parent page.

By default, Next.js keeps track of the active state (or subpage) for each slot. However, the content rendered within a slot will depend on the type of navigation:

Both useSelectedLayoutSegment and useSelectedLayoutSegments accept a parallelRoutesKey parameter, which allows you to read the active route segment within a slot.

When a user navigates to app/@auth/login (or /login in the URL bar), loginSegment will be equal to the string "login".

You can use Parallel Routes to conditionally render routes based on certain conditions, such as user role. For example, to render a different dashboard page for the /admin or /user roles:

You can add a layout inside a slot to allow users to navigate the slot independently. This is useful for creating tabs.

For example, the @analytics slot has two subpages: /page-views and /visitors.

Within @analytics, create a layout file to share the tabs between the two pages:

Parallel Routes can be used together with Intercepting Routes to create modals that support deep linking. This allows you to solve common challenges when building modals, such as:

Consider the following UI pattern, where a user can open a login modal from a layout using client-side navigation, or access a separate /login page:

To implement this pattern, start by creating a /login route that renders your main login page.

Then, inside the @auth slot, add default.js file that returns null. This ensures that the modal is not rendered when it's not active.

Inside your @auth slot, intercept the /login route by importing the <Modal> component and its children into the @auth/(.)login/page.tsx file, and updating the folder name to /@auth/(.)login/page.tsx.

Now, you can leverage the Next.js router to open and close the modal. This ensures the URL is correctly updated when the modal is open, and when navigating backwards and forwards.

To open the modal, pass the @auth slot as a prop to the parent layout and render it alongside the children prop.

When the user clicks the <Link>, the modal will open instead of navigating to the /login page. However, on refresh or initial load, navigating to /login will take the user to the main login page.

You can close the modal by calling router.back() or by using the Link component.

When using the Link component to navigate away from a page that shouldn't render the @auth slot anymore, we need to make sure the parallel route matches to a component that returns null. For example, when navigating back to the root page, we create a @auth/page.tsx component:

Or if navigating to any other page (such as /foo, /foo/bar, etc), you can use a catch-all slot:

Parallel Routes can be streamed independently, allowing you to define independent error and loading states for each route:

See the Loading UI and Error Handling documentation for more information.

**Examples:**

Example 1 (unknown):
```unknown
export default function Layout({
  children,
  team,
  analytics,
}: {
  children: React.ReactNode
  analytics: React.ReactNode
  team: React.ReactNode
}) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

Example 2 (python):
```python
'use client'
 
import { useSelectedLayoutSegment } from 'next/navigation'
 
export default function Layout({ auth }: { auth: React.ReactNode }) {
  const loginSegment = useSelectedLayoutSegment('auth')
  // ...
}
```

Example 3 (python):
```python
import { checkUserRole } from '@/lib/auth'
 
export default function Layout({
  user,
  admin,
}: {
  user: React.ReactNode
  admin: React.ReactNode
}) {
  const role = checkUserRole()
  return role === 'admin' ? admin : user
}
```

Example 4 (python):
```python
import Link from 'next/link'
 
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Link href="/page-views">Page Views</Link>
        <Link href="/visitors">Visitors</Link>
      </nav>
      <div>{children}</div>
    </>
  )
}
```

---

## after

**URL:** https://nextjs.org/docs/app/api-reference/functions/after

**Contents:**
- after
- Reference
  - Parameters
  - Duration
- Good to know
- Examples
  - With request APIs
- Platform Support
- Version History

after allows you to schedule work to be executed after a response (or prerender) is finished. This is useful for tasks and other side effects that should not block the response, such as logging and analytics.

It can be used in Server Components (including generateMetadata), Server Actions, Route Handlers, and Proxy.

The function accepts a callback that will be executed after the response (or prerender) is finished:

Good to know: after is not a Dynamic API and calling it does not cause a route to become dynamic. If it's used within a static page, the callback will execute at build time, or whenever a page is revalidated.

after will run for the platform's default or configured max duration of your route. If your platform supports it, you can configure the timeout limit using the maxDuration route segment config.

You can use request APIs such as cookies and headers inside after in Server Actions and Route Handlers. This is useful for logging activity after a mutation. For example:

However, you cannot use these request APIs inside after in Server Components. This is because Next.js needs to know which part of the tree access the request APIs to support Cache Components, but after runs after React's rendering lifecycle.

Learn how to configure after when self-hosting Next.js.

Using after in a serverless context requires waiting for asynchronous tasks to finish after the response has been sent. In Next.js and Vercel, this is achieved using a primitive called waitUntil(promise), which extends the lifetime of a serverless invocation until all promises passed to waitUntil have settled.

If you want your users to be able to run after, you will have to provide your implementation of waitUntil that behaves in an analogous way.

When after is called, Next.js will access waitUntil like this:

Which means that globalThis[Symbol.for('@next/request-context')] is expected to contain an object like this:

Here is an example of the implementation.

**Examples:**

Example 1 (python):
```python
import { after } from 'next/server'
// Custom logging function
import { log } from '@/app/utils'
 
export default function Layout({ children }: { children: React.ReactNode }) {
  after(() => {
    // Execute after the layout is rendered and sent to the user
    log()
  })
  return <>{children}</>
}
```

Example 2 (python):
```python
import { after } from 'next/server'
import { cookies, headers } from 'next/headers'
import { logUserAction } from '@/app/utils'
 
export async function POST(request: Request) {
  // Perform mutation
  // ...
 
  // Log user activity for analytics
  after(async () => {
    const userAgent = (await headers().get('user-agent')) || 'unknown'
    const sessionCookie =
      (await cookies().get('session-id'))?.value || 'anonymous'
 
    logUserAction({ sessionCookie, userAgent })
  })
 
  return new Response(JSON.stringify({ status: 'success' }), {
    status: 200,
    headers: { 'Content-Type': 'application/json' },
  })
}
```

Example 3 (javascript):
```javascript
const RequestContext = globalThis[Symbol.for('@next/request-context')]
const contextValue = RequestContext?.get()
const waitUntil = contextValue?.waitUntil
```

Example 4 (javascript):
```javascript
type NextRequestContext = {
  get(): NextRequestContextValue | undefined
}
 
type NextRequestContextValue = {
  waitUntil?: (promise: Promise<any>) => void
}
```

---

## How to self-host your Next.js application

**URL:** https://nextjs.org/docs/15/app/guides/self-hosting

**Contents:**
- How to self-host your Next.js application
- Image Optimization
- Middleware
- Environment Variables
- Caching and ISR
  - Automatic Caching
  - Static Assets
  - Configuring Caching
- Build Cache
- Version Skew

When deploying your Next.js app, you may want to configure how different features are handled based on your infrastructure.

ðŸŽ¥ Watch: Learn more about self-hosting Next.js â†’ YouTube (45 minutes).

Image Optimization through next/image works self-hosted with zero configuration when deploying using next start. If you would prefer to have a separate service to optimize images, you can configure an image loader.

Image Optimization can be used with a static export by defining a custom image loader in next.config.js. Note that images are optimized at runtime, not during the build.

Middleware works self-hosted with zero configuration when deploying using next start. Since it requires access to the incoming request, it is not supported when using a static export.

Middleware uses the Edge runtime, a subset of all available Node.js APIs to help ensure low latency, since it may run in front of every route or asset in your application. If you do not want this, you can use the full Node.js runtime to run Middleware.

If you are looking to add logic (or use an external package) that requires all Node.js APIs, you might be able to move this logic to a layout as a Server Component. For example, checking headers and redirecting. You can also use headers, cookies, or query parameters to redirect or rewrite through next.config.js. If that does not work, you can also use a custom server.

Next.js can support both build time and runtime environment variables.

By default, environment variables are only available on the server. To expose an environment variable to the browser, it must be prefixed with NEXT_PUBLIC_. However, these public environment variables will be inlined into the JavaScript bundle during next build.

You safely read environment variables on the server during dynamic rendering.

This allows you to use a singular Docker image that can be promoted through multiple environments with different values.

Next.js can cache responses, generated static pages, build outputs, and other static assets like images, fonts, and scripts.

Caching and revalidating pages (with Incremental Static Regeneration) use the same shared cache. By default, this cache is stored to the filesystem (on disk) on your Next.js server. This works automatically when self-hosting using both the Pages and App Router.

You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application.

If you want to host static assets on a different domain or CDN, you can use the assetPrefix configuration in next.config.js. Next.js will use this asset prefix when retrieving JavaScript or CSS files. Separating your assets to a different domain does come with the downside of extra time spent on DNS and TLS resolution.

Learn more about assetPrefix.

By default, generated cache assets will be stored in memory (defaults to 50mb) and on disk. If you are hosting Next.js using a container orchestration platform like Kubernetes, each pod will have a copy of the cache. To prevent stale data from being shown since the cache is not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching.

To configure the ISR/Data Cache location when self-hosting, you can configure a custom handler in your next.config.js file:

Then, create cache-handler.js in the root of your project, for example:

Using a custom cache handler will allow you to ensure consistency across all pods hosting your Next.js application. For instance, you can save the cached values anywhere, like Redis or AWS S3.

Next.js generates an ID during next build to identify which version of your application is being served. The same build should be used and boot up multiple containers.

If you are rebuilding for each stage of your environment, you will need to generate a consistent build ID to use between containers. Use the generateBuildId command in next.config.js:

Next.js will automatically mitigate most instances of version skew and automatically reload the application to retrieve new assets when detected. For example, if there is a mismatch in the deploymentId, transitions between pages will perform a hard navigation versus using a prefetched value.

When the application is reloaded, there may be a loss of application state if it's not designed to persist between page navigations. For example, using URL state or local storage would persist state after a page refresh. However, component state like useState would be lost in such navigations.

The Next.js App Router supports streaming responses when self-hosting. If you are using Nginx or a similar proxy, you will need to configure it to disable buffering to enable streaming.

For example, you can disable buffering in Nginx by setting X-Accel-Buffering to no:

Partial Prerendering (experimental) works by default with Next.js and is not a CDN-only feature. This includes deployment as a Node.js server (through next start) and when used with a Docker container.

When using a CDN in front on your Next.js application, the page will include Cache-Control: private response header when dynamic APIs are accessed. This ensures that the resulting HTML page is marked as non-cacheable. If the page is fully prerendered to static, it will include Cache-Control: public to allow the page to be cached on the CDN.

If you don't need a mix of both static and dynamic components, you can make your entire route static and cache the output HTML on a CDN. This Automatic Static Optimization is the default behavior when running next build if dynamic APIs are not used.

As Partial Prerendering moves to stable, we will provide support through the Deployment Adapters API.

after is fully supported when self-hosting with next start.

When stopping the server, ensure a graceful shutdown by sending SIGINT or SIGTERM signals and waiting. This allows the Next.js server to wait until after pending callback functions or promises used inside after have finished.

**Examples:**

Example 1 (python):
```python
import { connection } from 'next/server'
 
export default async function Component() {
  await connection()
  // cookies, headers, and other Dynamic APIs
  // will also opt into dynamic rendering, meaning
  // this env variable is evaluated at runtime
  const value = process.env.MY_VALUE
  // ...
}
```

Example 2 (unknown):
```unknown
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // disable default in-memory caching
}
```

Example 3 (javascript):
```javascript
const cache = new Map()
 
module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
  }
 
  async get(key) {
    // This could be stored anywhere, like durable storage
    return cache.get(key)
  }
 
  async set(key, data, ctx) {
    // This could be stored anywhere, like durable storage
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
      tags: ctx.tags,
    })
  }
 
  async revalidateTag(tags) {
    // tags is either a string or an array of strings
    tags = [tags].flat()
    // Iterate over all entries in the cache
    for (let [key, value] of cache) {
      // If the value's tags include the specified tag, delete this entry
      if (value.tags.some((tag) => tags.includes(tag))) {
        cache.delete(key)
      }
    }
  }
 
  // If you want to have temporary in memory cache for a single request that is reset
  // before the next request you can leverage this method
  resetRequestCache() {}
}
```

Example 4 (javascript):
```javascript
module.exports = {
  generateBuildId: async () => {
    // This could be anything, using the latest git hash
    return process.env.GIT_HASH
  },
}
```

---

## How to optimize package bundling

**URL:** https://nextjs.org/docs/pages/guides/package-bundling

**Contents:**
- How to optimize package bundling
- Analyzing JavaScript bundles
  - Installation
  - Generating a report
- Optimizing package imports
- Bundling specific packages
- Bundling all packages
- Opting specific packages out of bundling
- Next Steps
  - Production

Bundling external packages can significantly improve the performance of your application. By default, packages imported into your application are not bundled. This can impact performance or might not work if external packages are not pre-bundled, for example, if imported from a monorepo or node_modules. This page will guide you through how to analyze and configure package bundling.

@next/bundle-analyzer is a plugin for Next.js that helps you manage the size of your application bundles. It generates a visual report of the size of each package and their dependencies. You can use the information to remove large dependencies, split, or lazy-load your code.

Install the plugin by running the following command:

Then, add the bundle analyzer's settings to your next.config.js.

Run the following command to analyze your bundles:

The report will open three new tabs in your browser, which you can inspect. Periodically evaluating your application's bundles can help you maintain application performance over time.

Some packages, such as icon libraries, can export hundreds of modules, which can cause performance issues in development and production.

You can optimize how these packages are imported by adding the optimizePackageImports option to your next.config.js. This option will only load the modules you actually use, while still giving you the convenience of writing import statements with many named exports.

Next.js also optimizes some libraries automatically, thus they do not need to be included in the optimizePackageImports list. See the full list.

To bundle specific packages, you can use the transpilePackages option in your next.config.js. This option is useful for bundling external packages that are not pre-bundled, for example, in a monorepo or imported from node_modules.

To automatically bundle all packages (default behavior in the App Router), you can use the bundlePagesRouterDependencies option in your next.config.js.

If you have the bundlePagesRouterDependencies option enabled, you can opt specific packages out of automatic bundling using the serverExternalPackages option in your next.config.js:

**Examples:**

Example 1 (unknown):
```unknown
npm i @next/bundle-analyzer
# or
yarn add @next/bundle-analyzer
# or
pnpm add @next/bundle-analyzer
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {}
 
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})
 
module.exports = withBundleAnalyzer(nextConfig)
```

Example 3 (unknown):
```unknown
ANALYZE=true npm run build
# or
ANALYZE=true yarn build
# or
ANALYZE=true pnpm build
```

Example 4 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    optimizePackageImports: ['icon-library'],
  },
}
 
module.exports = nextConfig
```

---

## Pages Router

**URL:** https://nextjs.org/docs/pages

**Contents:**
- Pages Router
  - Getting Started
  - Guides
  - Building Your Application
  - API Reference

You're viewing the documentation for the Pages Router. See the App Router documentation for the latest features.

The Pages Router uses an intuitive file-system router to map each file to a route.

Before Next.js 13, the Pages Router was the main way to create routes in Next.js. It's still supported in newer versions of Next.js, but we recommend migrating to the new App Router to leverage React's latest features.

---

## CLI

**URL:** https://nextjs.org/docs/app/api-reference/cli

**Contents:**
- CLI
  - create-next-app
  - next CLI

Next.js comes with two Command Line Interface (CLI) tools:

---

## expireTime

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/expireTime

**Contents:**
- expireTime

You can specify a custom stale-while-revalidate expire time for CDNs to consume in the Cache-Control header for ISR enabled pages.

Open next.config.js and add the expireTime config:

Now when sending the Cache-Control header the expire time will be calculated depending on the specific revalidate period.

For example, if you have a revalidate of 15 minutes on a path and the expire time is one hour the generated Cache-Control header will be s-maxage=900, stale-while-revalidate=2700 so that it can stay stale for 15 minutes less than the configured expire time.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  // one hour in seconds
  expireTime: 3600,
}
```

---

## App Router

**URL:** https://nextjs.org/docs/app

**Contents:**
- App Router
- Next Steps
  - Installation
  - Project Structure
  - Layouts and Pages
  - Linking and Navigating
  - Server and Client Components

The App Router is a file-system based router that uses React's latest features such as Server Components, Suspense, and Server Functions.

---

## Routing

**URL:** https://nextjs.org/docs/pages/building-your-application/routing

**Contents:**
- Routing
  - Pages and Layouts
  - Dynamic Routes
  - Linking and Navigating
  - Custom App
  - Custom Document
  - API Routes
  - Custom Errors

The Pages Router has a file-system based router built on concepts of pages. When a file is added to the pages directory it's automatically available as a route. Learn more about routing in the Pages Router:

---

## Server-side Rendering (SSR)

**URL:** https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering

**Contents:**
- Server-side Rendering (SSR)

Also referred to as "SSR" or "Dynamic Rendering".

If a page uses Server-side Rendering, the page HTML is generated on each request.

To use Server-side Rendering for a page, you need to export an async function called getServerSideProps. This function will be called by the server on every request.

For example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can write getServerSideProps which fetches this data and passes it to Page like below:

As you can see, getServerSideProps is similar to getStaticProps, but the difference is that getServerSideProps is run on every request instead of on build time.

To learn more about how getServerSideProps works, check out our Data Fetching documentation.

**Examples:**

Example 1 (javascript):
```javascript
export default function Page({ data }) {
  // Render data...
}
 
// This gets called on every request
export async function getServerSideProps() {
  // Fetch data from external API
  const res = await fetch(`https://.../data`)
  const data = await res.json()
 
  // Pass data to the page via props
  return { props: { data } }
}
```

---

## htmlLimitedBots

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/htmlLimitedBots

**Contents:**
- htmlLimitedBots
- Default list
- Disabling
- Version History

The htmlLimitedBots config allows you to specify a list of user agents that should receive blocking metadata instead of streaming metadata.

Next.js includes a default list of HTML limited bots, including:

See the full list here.

Specifying a htmlLimitedBots config will override the Next.js' default list. However, this is advanced behavior, and the default should be sufficient for most cases.

To fully disable streaming metadata:

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const config: NextConfig = {
  htmlLimitedBots: /MySpecialBot|MyAnotherSpecialBot|SimpleCrawler/,
}
 
export default config
```

Example 2 (javascript):
```javascript
const config: NextConfig = {
  htmlLimitedBots: /MySpecialBot|MyAnotherSpecialBot|SimpleCrawler/,
}
 
export default config
```

Example 3 (python):
```python
import type { NextConfig } from 'next'
 
const config: NextConfig = {
  htmlLimitedBots: /.*/,
}
 
export default config
```

---

## How to preview content with Preview Mode in Next.js

**URL:** https://nextjs.org/docs/pages/guides/preview-mode

**Contents:**
- How to preview content with Preview Mode in Next.js
- Step 1: Create and access a preview API route
  - Securely accessing it from your Headless CMS
- Step 2: Update getStaticProps
  - Fetch preview data
- More Details
  - Specify the Preview Mode duration
  - Clear the Preview Mode cookies
  - previewData size limits
  - Works with getServerSideProps

Note: This feature is superseded by Draft Mode.

In the Pages documentation and the Data Fetching documentation, we talked about how to pre-render a page at build time (Static Generation) using getStaticProps and getStaticPaths.

Static Generation is useful when your pages fetch data from a headless CMS. However, itâ€™s not ideal when youâ€™re writing a draft on your headless CMS and want to preview the draft immediately on your page. Youâ€™d want Next.js to render these pages at request time instead of build time and fetch the draft content instead of the published content. Youâ€™d want Next.js to bypass Static Generation only for this specific case.

Next.js has a feature called Preview Mode which solves this problem. Here are instructions on how to use it.

Take a look at the API Routes documentation first if youâ€™re not familiar with Next.js API Routes.

First, create a preview API route. It can have any name - e.g. pages/api/preview.js (or .ts if using TypeScript).

In this API route, you need to call setPreviewData on the response object. The argument for setPreviewData should be an object, and this can be used by getStaticProps (more on this later). For now, weâ€™ll use {}.

res.setPreviewData sets some cookies on the browser which turns on the preview mode. Any requests to Next.js containing these cookies will be considered as the preview mode, and the behavior for statically generated pages will change (more on this later).

You can test this manually by creating an API route like below and accessing it from your browser manually:

If you open your browserâ€™s developer tools and visit /api/preview, youâ€™ll notice that the __prerender_bypass and __next_preview_data cookies will be set on this request.

In practice, youâ€™d want to call this API route securely from your headless CMS. The specific steps will vary depending on which headless CMS youâ€™re using, but here are some common steps you could take.

These steps assume that the headless CMS youâ€™re using supports setting custom preview URLs. If it doesnâ€™t, you can still use this method to secure your preview URLs, but youâ€™ll need to construct and access the preview URL manually.

First, you should create a secret token string using a token generator of your choice. This secret will only be known by your Next.js app and your headless CMS. This secret prevents people who donâ€™t have access to your CMS from accessing preview URLs.

Second, if your headless CMS supports setting custom preview URLs, specify the following as the preview URL. This assumes that your preview API route is located at pages/api/preview.js.

Your headless CMS might allow you to include a variable in the preview URL so that <path> can be set dynamically based on the CMSâ€™s data like so: &slug=/posts/{entry.fields.slug}

Finally, in the preview API route:

If it succeeds, then the browser will be redirected to the path you want to preview with the preview mode cookies being set.

The next step is to update getStaticProps to support the preview mode.

If you request a page which has getStaticProps with the preview mode cookies set (via res.setPreviewData), then getStaticProps will be called at request time (instead of at build time).

Furthermore, it will be called with a context object where:

We used res.setPreviewData({}) in the preview API route, so context.previewData will be {}. You can use this to pass session information from the preview API route to getStaticProps if necessary.

If youâ€™re also using getStaticPaths, then context.params will also be available.

You can update getStaticProps to fetch different data based on context.preview and/or context.previewData.

For example, your headless CMS might have a different API endpoint for draft posts. If so, you can use context.preview to modify the API endpoint URL like below:

Thatâ€™s it! If you access the preview API route (with secret and slug) from your headless CMS or manually, you should now be able to see the preview content. And if you update your draft without publishing, you should be able to preview the draft.

Set this as the preview URL on your headless CMS or access manually, and you should be able to see the preview.

Good to know: during rendering next/router exposes an isPreview flag, see the router object docs for more info.

setPreviewData takes an optional second parameter which should be an options object. It accepts the following keys:

By default, no expiration date is set for Preview Mode cookies, so the preview session ends when the browser is closed.

To clear the Preview Mode cookies manually, create an API route that calls clearPreviewData():

Then, send a request to /api/clear-preview-mode-cookies to invoke the API Route. If calling this route using next/link, you must pass prefetch={false} to prevent calling clearPreviewData during link prefetching.

If a path was specified in the setPreviewData call, you must pass the same path to clearPreviewData:

You can pass an object to setPreviewData and have it be available in getStaticProps. However, because the data will be stored in a cookie, thereâ€™s a size limitation. Currently, preview data is limited to 2KB.

The preview mode works on getServerSideProps as well. It will also be available on the context object containing preview and previewData.

Good to know: You shouldn't set the Cache-Control header when using Preview Mode because it cannot be bypassed. Instead, we recommend using ISR.

API Routes will have access to preview and previewData under the request object. For example:

Both the bypass cookie value and the private key for encrypting the previewData change when next build is completed. This ensures that the bypass cookie canâ€™t be guessed.

Good to know: To test Preview Mode locally over HTTP your browser will need to allow third-party cookies and local storage access.

**Examples:**

Example 1 (unknown):
```unknown
export default function handler(req, res) {
  // ...
  res.setPreviewData({})
  // ...
}
```

Example 2 (unknown):
```unknown
// simple example for testing it manually from your browser.
export default function handler(req, res) {
  res.setPreviewData({})
  res.end('Preview mode enabled')
}
```

Example 3 (unknown):
```unknown
https://<your-site>/api/preview?secret=<token>&slug=<path>
```

Example 4 (javascript):
```javascript
export default async (req, res) => {
  // Check the secret and next parameters
  // This secret should only be known to this API route and the CMS
  if (req.query.secret !== 'MY_SECRET_TOKEN' || !req.query.slug) {
    return res.status(401).json({ message: 'Invalid token' })
  }
 
  // Fetch the headless CMS to check if the provided `slug` exists
  // getPostBySlug would implement the required fetching logic to the headless CMS
  const post = await getPostBySlug(req.query.slug)
 
  // If the slug doesn't exist prevent preview mode from being enabled
  if (!post) {
    return res.status(401).json({ message: 'Invalid slug' })
  }
 
  // Enable Preview Mode by setting the cookies
  res.setPreviewData({})
 
  // Redirect to the path from the fetched post
  // We don't redirect to req.query.slug as that might lead to open redirect vulnerabilities
  res.redirect(post.slug)
}
```

---

## getStaticProps

**URL:** https://nextjs.org/docs/pages/api-reference/functions/get-static-props

**Contents:**
- getStaticProps
- Context parameter
- getStaticProps return values
  - props
  - revalidate
  - notFound
  - redirect
- Reading files: Use process.cwd()
- Version History

Exporting a function called getStaticProps will pre-render a page at build time using the props returned from the function:

You can import modules in top-level scope for use in getStaticProps. Imports used will not be bundled for the client-side. This means you can write server-side code directly in getStaticProps, including fetching data from your database.

The context parameter is an object containing the following keys:

The getStaticProps function should return an object containing either props, redirect, or notFound followed by an optional revalidate property.

The props object is a key-value pair, where each value is received by the page component. It should be a serializable object so that any props passed, could be serialized with JSON.stringify.

The revalidate property is the amount in seconds after which a page re-generation can occur (defaults to false or no revalidation).

Learn more about Incremental Static Regeneration.

The cache status of a page leveraging ISR can be determined by reading the value of the x-nextjs-cache response header. The possible values are the following:

The notFound boolean allows the page to return a 404 status and 404 Page. With notFound: true, the page will return a 404 even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author. Note, notFound follows the same revalidate behavior described here.

Good to know: notFound is not needed for fallback: false mode as only paths returned from getStaticPaths will be pre-rendered.

The redirect object allows redirecting to internal or external resources. It should match the shape of { destination: string, permanent: boolean }.

In some rare cases, you might need to assign a custom status code for older HTTP clients to properly redirect. In these cases, you can use the statusCode property instead of the permanent property, but not both. You can also set basePath: false similar to redirects in next.config.js.

If the redirects are known at build-time, they should be added in next.config.js instead.

Files can be read directly from the filesystem in getStaticProps.

In order to do so you have to get the full path to a file.

Since Next.js compiles your code into a separate directory you can't use __dirname as the path it returns will be different from the Pages Router.

Instead you can use process.cwd() which gives you the directory where Next.js is being executed.

**Examples:**

Example 1 (python):
```python
import type { InferGetStaticPropsType, GetStaticProps } from 'next'
 
type Repo = {
  name: string
  stargazers_count: number
}
 
export const getStaticProps = (async (context) => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo = await res.json()
  return { props: { repo } }
}) satisfies GetStaticProps<{
  repo: Repo
}>
 
export default function Page({
  repo,
}: InferGetStaticPropsType<typeof getStaticProps>) {
  return repo.stargazers_count
}
```

Example 2 (unknown):
```unknown
export async function getStaticProps(context) {
  return {
    props: { message: `Next.js is awesome` }, // will be passed to the page component as props
  }
}
```

Example 3 (javascript):
```javascript
// This function gets called at build time on server-side.
// It may be called again, on a serverless function, if
// revalidation is enabled and a new request comes in
export async function getStaticProps() {
  const res = await fetch('https://.../posts')
  const posts = await res.json()
 
  return {
    props: {
      posts,
    },
    // Next.js will attempt to re-generate the page:
    // - When a request comes in
    // - At most once every 10 seconds
    revalidate: 10, // In seconds
  }
}
```

Example 4 (javascript):
```javascript
export async function getStaticProps(context) {
  const res = await fetch(`https://.../data`)
  const data = await res.json()
 
  if (!data) {
    return {
      notFound: true,
    }
  }
 
  return {
    props: { data }, // will be passed to the page component as props
  }
}
```

---

## API Reference

**URL:** https://nextjs.org/docs/app/api-reference

**Contents:**
- API Reference
  - Directives
  - Components
  - File-system conventions
  - Functions
  - Configuration
  - CLI
  - Edge Runtime
  - Turbopack

---

## error.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/error

**Contents:**
- error.js
- Reference
  - Props
    - error
    - error.message
    - error.digest
    - reset
- Examples
  - Global Error
  - Graceful error recovery with a custom error boundary

An error file allows you to handle unexpected runtime errors and display fallback UI.

error.js wraps a route segment and its nested children in a React Error Boundary. When an error throws within the boundary, the error component shows as the fallback UI.

An instance of an Error object forwarded to the error.js Client Component.

Good to know: During development, the Error object forwarded to the client will be serialized and include the message of the original error for easier debugging. However, this behavior is different in production to avoid leaking potentially sensitive details included in the error to the client.

An automatically generated hash of the error thrown. It can be used to match the corresponding error in server-side logs.

The cause of an error can sometimes be temporary. In these cases, trying again might resolve the issue.

An error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the error boundary's contents. If successful, the fallback error component is replaced with the result of the re-render.

While less common, you can handle errors in the root layout or template using global-error.jsx, located in the root app directory, even when leveraging internationalization. Global error UI must define its own <html> and <body> tags, global styles, fonts, or other dependencies that your error page requires. This file replaces the root layout or template when active.

Good to know: Error boundaries must be Client Components, which means that metadata and generateMetadata exports are not supported in global-error.jsx. As an alternative, you can use the React <title> component.

When rendering fails on the client, it can be useful to show the last known server rendered UI for a better user experience.

The GracefullyDegradingErrorBoundary is an example of a custom error boundary that captures and preserves the current HTML before an error occurs. If a rendering error happens, it re-renders the captured HTML and displays a persistent notification bar to inform the user.

**Examples:**

Example 1 (python):
```python
'use client' // Error boundaries must be Client Components
 
import { useEffect } from 'react'
 
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error)
  }, [error])
 
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  )
}
```

Example 2 (javascript):
```javascript
'use client' // Error boundaries must be Client Components
 
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```

Example 3 (javascript):
```javascript
'use client' // Error boundaries must be Client Components
 
export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    // global-error must include html and body tags
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  )
}
```

Example 4 (python):
```python
'use client'
 
import React, { Component, ErrorInfo, ReactNode } from 'react'
 
interface ErrorBoundaryProps {
  children: ReactNode
  onError?: (error: Error, errorInfo: ErrorInfo) => void
}
 
interface ErrorBoundaryState {
  hasError: boolean
}
 
export class GracefullyDegradingErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  private contentRef: React.RefObject<HTMLDivElement | null>
 
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false }
    this.contentRef = React.createRef()
  }
 
  static getDerivedStateFromError(_: Error): ErrorBoundaryState {
    return { hasError: true }
  }
 
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    if (this.props.onError) {
      this.props.onError(error, errorInfo)
    }
  }
 
  render() {
    if (this.state.hasError) {
      // Render the current HTML content without hydration
      return (
        <>
          <div
            ref={this.contentRef}
            suppressHydrationWarning
            dangerouslySetInnerHTML={{
              __html: this.contentRef.current?.innerHTML || '',
            }}
          />
          <div className="fixed bottom-0 left-0 right-0 bg-red-600 text-white py-4 px-6 text-center">
            <p className="font-semibold">
              An error occurred during page rendering
            </p>
          </div>
        </>
      )
    }
 
    return <div ref={this.contentRef}>{this.props.children}</div>
  }
}
 
export default GracefullyDegradingErrorBoundary
```

---

## How to use CSS-in-JS libraries

**URL:** https://nextjs.org/docs/app/guides/css-in-js

**Contents:**
- How to use CSS-in-JS libraries
- Configuring CSS-in-JS in app
  - styled-jsx
  - Styled Components

Warning: Using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React, including concurrent rendering.

The following libraries are supported in Client Components in the app directory (alphabetical):

The following are currently working on support:

Good to know: We're testing out different CSS-in-JS libraries and we'll be adding more examples for libraries that support React 18 features and/or the app directory.

Configuring CSS-in-JS is a three-step opt-in process that involves:

Using styled-jsx in Client Components requires using v5.1.0. First, create a new registry:

Then, wrap your root layout with the registry:

View an example here.

Below is an example of how to configure styled-components@6 or newer:

First, enable styled-components in next.config.js.

Then, use the styled-components API to create a global registry component to collect all CSS style rules generated during a render, and a function to return those rules. Then use the useServerInsertedHTML hook to inject the styles collected in the registry into the <head> HTML tag in the root layout.

Wrap the children of the root layout with the style registry component:

View an example here.

**Examples:**

Example 1 (python):
```python
'use client'
 
import React, { useState } from 'react'
import { useServerInsertedHTML } from 'next/navigation'
import { StyleRegistry, createStyleRegistry } from 'styled-jsx'
 
export default function StyledJsxRegistry({
  children,
}: {
  children: React.ReactNode
}) {
  // Only create stylesheet once with lazy initial state
  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state
  const [jsxStyleRegistry] = useState(() => createStyleRegistry())
 
  useServerInsertedHTML(() => {
    const styles = jsxStyleRegistry.styles()
    jsxStyleRegistry.flush()
    return <>{styles}</>
  })
 
  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>
}
```

Example 2 (python):
```python
import StyledJsxRegistry from './registry'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <StyledJsxRegistry>{children}</StyledJsxRegistry>
      </body>
    </html>
  )
}
```

Example 3 (unknown):
```unknown
module.exports = {
  compiler: {
    styledComponents: true,
  },
}
```

Example 4 (python):
```python
'use client'
 
import React, { useState } from 'react'
import { useServerInsertedHTML } from 'next/navigation'
import { ServerStyleSheet, StyleSheetManager } from 'styled-components'
 
export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode
}) {
  // Only create stylesheet once with lazy initial state
  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())
 
  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement()
    styledComponentsStyleSheet.instance.clearTag()
    return <>{styles}</>
  })
 
  if (typeof window !== 'undefined') return <>{children}</>
 
  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  )
}
```

---

## layout.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/layout

**Contents:**
- layout.js
- Reference
  - Props
    - children (required)
    - params (optional)
  - Layout Props Helper
  - Root Layout
- Caveats
  - Request Object
  - Query params

The layout file is used to define a layout in your Next.js application.

A root layout is the top-most layout in the root app directory. It is used to define the <html> and <body> tags and other globally shared UI.

Layout components should accept and use a children prop. During rendering, children will be populated with the route segments the layout is wrapping. These will primarily be the component of a child Layout (if it exists) or Page, but could also be other special files like Loading or Error when applicable.

A promise that resolves to an object containing the dynamic route parameters object from the root segment down to that layout.

You can type layouts with LayoutProps to get a strongly typed params and named slots inferred from your directory structure. LayoutProps is a globally available helper.

The app directory must include a root layout, which is the top-most layout in the root app directory. Typically, the root layout is app/layout.js.

Layouts are cached in the client during navigation to avoid unnecessary server requests.

Layouts do not rerender. They can be cached and reused to avoid unnecessary computation when navigating between pages. By restricting layouts from accessing the raw request, Next.js can prevent the execution of potentially slow or expensive user code within the layout, which could negatively impact performance.

To access the request object, you can use headers and cookies APIs in Server Components and Functions.

Layouts do not rerender on navigation, so they cannot access search params which would otherwise become stale.

To access updated query parameters, you can use the Page searchParams prop, or read them inside a Client Component using the useSearchParams hook. Since Client Components re-render on navigation, they have access to the latest query parameters.

Layouts do not re-render on navigation, so they do not access pathname which would otherwise become stale.

To access the current pathname, you can read it inside a Client Component using the usePathname hook. Since Client Components re-render during navigation, they have access to the latest pathname.

Layouts cannot pass data to their children. However, you can fetch the same data in a route more than once, and use React cache to dedupe the requests without affecting performance.

Alternatively, when using fetchin Next.js, requests are automatically deduped.

Layouts do not have access to the route segments below itself. To access all route segments, you can use useSelectedLayoutSegment or useSelectedLayoutSegments in a Client Component.

You can modify the <head> HTML elements such as title and meta using the metadata object or generateMetadata function.

Good to know: You should not manually add <head> tags such as <title> and <meta> to root layouts. Instead, use the Metadata APIs which automatically handles advanced requirements such as streaming and de-duplicating <head> elements.

You can use the usePathname hook to determine if a nav link is active.

Since usePathname is a client hook, you need to extract the nav links into a Client Component, which can be imported into your layout:

Using dynamic route segments, you can display or fetch specific content based on the params prop.

To use params in a Client Component (which cannot be async), you can use React's use function to read the promise:

**Examples:**

Example 1 (unknown):
```unknown
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```

Example 2 (unknown):
```unknown
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

Example 3 (javascript):
```javascript
export default async function Layout({
  children,
  params,
}: {
  children: React.ReactNode
  params: Promise<{ team: string }>
}) {
  const { team } = await params
}
```

Example 4 (unknown):
```unknown
export default function Layout(props: LayoutProps<'/dashboard'>) {
  return (
    <section>
      {props.children}
      {/* If you have app/dashboard/@analytics, it appears as a typed slot: */}
      {/* {props.analytics} */}
    </section>
  )
}
```

---

## redirects

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js/redirects

**Contents:**
- redirects
- Path Matching
  - Wildcard Path Matching
  - Regex Path Matching
- Header, Cookie, and Query Matching
  - Redirects with basePath support
  - Redirects with i18n support
- Other Redirects
- Version History

Redirects allow you to redirect an incoming request path to a different destination path.

To use redirects you can use the redirects key in next.config.js:

redirects is an async function that expects an array to be returned holding objects with source, destination, and permanent properties:

Why does Next.js use 307 and 308? Traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, but many browsers changed the request method of the redirect to GET, regardless of the original method. For example, if the browser made a request to POST /v1/users which returned status code 302 with location /v2/users, the subsequent request might be GET /v2/users instead of the expected POST /v2/users. Next.js uses the 307 temporary redirect, and 308 permanent redirect status codes to explicitly preserve the request method used.

Redirects are checked before the filesystem which includes pages and /public files.

When using the Pages Router, redirects are not applied to client-side routing (Link, router.push) unless Proxy is present and matches the path.

When a redirect is applied, any query values provided in the request will be passed through to the redirect destination. For example, see the following redirect configuration:

Good to know: Remember to include the forward slash / before the colon : in path parameters of the source and destination paths, otherwise the path will be treated as a literal string and you run the risk of causing infinite redirects.

When /old-blog/post-1?hello=world is requested, the client will be redirected to /blog/post-1?hello=world.

Path matches are allowed, for example /old-blog/:slug will match /old-blog/first-post (no nested paths):

The pattern /old-blog/:slug matches /old-blog/first-post and /old-blog/post-1 but not /old-blog/a/b (no nested paths). Patterns are anchored to the start: /old-blog/:slug will not match /archive/old-blog/first-post.

You can use modifiers on parameters: * (zero or more), + (one or more), ? (zero or one). For example, /blog/:slug* matches /blog, /blog/a, and /blog/a/b/c.

Read more details on path-to-regexp documentation.

To match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:

To match a regex path you can wrap the regex in parentheses after a parameter, for example /post/:slug(\\d{1,}) will match /post/123 but not /post/abc:

The following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\ before them:

To only match a redirect when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the redirect to be applied.

has and missing items can have the following fields:

When leveraging basePath support with redirects each source and destination is automatically prefixed with the basePath unless you add basePath: false to the redirect:

When leveraging i18n support with redirects each source and destination is automatically prefixed to handle the configured locales unless you add locale: false to the redirect. If locale: false is used you must prefix the source and destination with a locale for it to be matched correctly.

In some rare cases, you might need to assign a custom status code for older HTTP Clients to properly redirect. In these cases, you can use the statusCode property instead of the permanent property, but not both. To ensure IE11 compatibility, a Refresh header is automatically added for the 308 status code.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  async redirects() {
    return [
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
    ]
  },
}
```

Example 2 (unknown):
```unknown
{
  source: '/old-blog/:path*',
  destination: '/blog/:path*',
  permanent: false
}
```

Example 3 (unknown):
```unknown
module.exports = {
  async redirects() {
    return [
      {
        source: '/old-blog/:slug',
        destination: '/news/:slug', // Matched parameters can be used in the destination
        permanent: true,
      },
    ]
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  async redirects() {
    return [
      {
        source: '/blog/:slug*',
        destination: '/news/:slug*', // Matched parameters can be used in the destination
        permanent: true,
      },
    ]
  },
}
```

---

## trailingSlash

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/trailingSlash

**Contents:**
- trailingSlash
- Version History

By default Next.js will redirect URLs with trailing slashes to their counterpart without a trailing slash. For example /about/ will redirect to /about. You can configure this behavior to act the opposite way, where URLs without trailing slashes are redirected to their counterparts with trailing slashes.

Open next.config.js and add the trailingSlash config:

With this option set, URLs like /about will redirect to /about/.

When using trailingSlash: true, certain URLs are exceptions and will not have a trailing slash appended:

For example, the following URLs will remain unchanged: /file.txt, images/photos/picture.png, and .well-known/subfolder/config.json.

When used with output: "export" configuration, the /about page will output /about/index.html (instead of the default /about.html).

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  trailingSlash: true,
}
```

---

## How to implement Incremental Static Regeneration (ISR)

**URL:** https://nextjs.org/docs/pages/guides/incremental-static-regeneration

**Contents:**
- How to implement Incremental Static Regeneration (ISR)
- Reference
  - Functions
- Examples
  - On-demand validation with res.revalidate()
  - Handling uncaught exceptions
  - Customizing the cache location
- Troubleshooting
  - Debugging cached data in local development
  - Verifying correct production behavior

Incremental Static Regeneration (ISR) enables you to:

Here's a minimal example:

Here's how this example works:

For a more precise method of revalidation, use res.revalidate to generate a new page on-demand from an API Router.

For example, this API Route can be called at /api/revalidate?secret=<token> to revalidate a given blog post. Create a secret token only known by your Next.js app. This secret will be used to prevent unauthorized access to the revalidation API Route.

If you are using on-demand revalidation, you do not need to specify a revalidate time inside of getStaticProps. Next.js will use the default value of false (no revalidation) and only revalidate the page on-demand when res.revalidate() is called.

If there is an error inside getStaticProps when handling background regeneration, or you manually throw an error, the last successfully generated page will continue to show. On the next subsequent request, Next.js will retry calling getStaticProps.

You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application. Learn more.

If you are using the fetch API, you can add additional logging to understand which requests are cached or uncached. Learn more about the logging option.

To verify your pages are cached and revalidated correctly in production, you can test locally by running next build and then next start to run the production Next.js server.

This will allow you to test ISR behavior as it would work in a production environment. For further debugging, add the following environment variable to your .env file:

This will make the Next.js server console log ISR cache hits and misses. You can inspect the output to see which pages are generated during next build, as well as how pages are updated as paths are accessed on-demand.

Learn how to configure ISR when self-hosting Next.js.

**Examples:**

Example 1 (python):
```python
import type { GetStaticPaths, GetStaticProps } from 'next'
 
interface Post {
  id: string
  title: string
  content: string
}
 
interface Props {
  post: Post
}
 
export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  const paths = posts.map((post: Post) => ({
    params: { id: String(post.id) },
  }))
 
  return { paths, fallback: 'blocking' }
}
 
export const getStaticProps: GetStaticProps<Props> = async ({
  params,
}: {
  params: { id: string }
}) => {
  const post = await fetch(`https://api.vercel.app/blog/${params.id}`).then(
    (res) => res.json()
  )
 
  return {
    props: { post },
    // Next.js will invalidate the cache when a
    // request comes in, at most once every 60 seconds.
    revalidate: 60,
  }
}
 
export default function Page({ post }: Props) {
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

Example 2 (python):
```python
import type { NextApiRequest, NextApiResponse } from 'next'
 
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  // Check for secret to confirm this is a valid request
  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' })
  }
 
  try {
    // This should be the actual path not a rewritten path
    // e.g. for "/posts/[id]" this should be "/posts/1"
    await res.revalidate('/posts/1')
    return res.json({ revalidated: true })
  } catch (err) {
    // If there was an error, Next.js will continue
    // to show the last successfully generated page
    return res.status(500).send('Error revalidating')
  }
}
```

Example 3 (python):
```python
import type { GetStaticProps } from 'next'
 
interface Post {
  id: string
  title: string
  content: string
}
 
interface Props {
  post: Post
}
 
export const getStaticProps: GetStaticProps<Props> = async ({
  params,
}: {
  params: { id: string }
}) => {
  // If this request throws an uncaught error, Next.js will
  // not invalidate the currently shown page and
  // retry getStaticProps on the next request.
  const res = await fetch(`https://api.vercel.app/blog/${params.id}`)
  const post: Post = await res.json()
 
  if (!res.ok) {
    // If there is a server error, you might want to
    // throw an error instead of returning so that the cache is not updated
    // until the next successful request.
    throw new Error(`Failed to fetch posts, received status ${res.status}`)
  }
 
  return {
    props: { post },
    // Next.js will invalidate the cache when a
    // request comes in, at most once every 60 seconds.
    revalidate: 60,
  }
}
```

Example 4 (unknown):
```unknown
module.exports = {
  logging: {
    fetches: {
      fullUrl: true,
    },
  },
}
```

---

## viewTransition

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/viewTransition

**Contents:**
- viewTransition
- Usage
  - Live Demo

viewTransition is an experimental flag that enables the new View Transitions API in React. This API allows you to leverage the native View Transitions browser API to create seamless transitions between UI states.

To enable this feature, you need to set the viewTransition property to true in your next.config.js file.

Important Notice: The <ViewTransition> Component is already available in React's Canary release channel. experimental.viewTransition is only required to enable deeper integration with Next.js features e.g. automatically adding Transition types for navigations. Next.js specific transition types are not implemented yet.

You can import the <ViewTransition> Component from React in your application:

Check out our Next.js View Transition Demo to see this feature in action.

As this API evolves, we will update our documentation and share more examples. However, for now, we strongly advise against using this feature in production.

**Examples:**

Example 1 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    viewTransition: true,
  },
}
 
module.exports = nextConfig
```

Example 2 (python):
```python
import { ViewTransition } from 'react'
```

---

## Script Component

**URL:** https://nextjs.org/docs/app/api-reference/components/script

**Contents:**
- Script Component
- Props
- Required Props
  - src
- Optional Props
  - strategy
  - beforeInteractive
  - afterInteractive
  - lazyOnload
  - worker

This API reference will help you understand how to use props available for the Script Component. For features and usage, please see the Optimizing Scripts page.

Here's a summary of the props available for the Script Component:

The <Script /> component requires the following properties.

A path string specifying the URL of an external script. This can be either an absolute external URL or an internal path. The src property is required unless an inline script is used.

The <Script /> component accepts a number of additional properties beyond those which are required.

The loading strategy of the script. There are four different strategies that can be used:

Scripts that load with the beforeInteractive strategy are injected into the initial HTML from the server, downloaded before any Next.js module, and executed in the order they are placed.

Scripts denoted with this strategy are preloaded and fetched before any first-party code, but their execution does not block page hydration from occurring.

beforeInteractive scripts must be placed inside the root layout (app/layout.tsx) and are designed to load scripts that are needed by the entire site (i.e. the script will load when any page in the application has been loaded server-side).

This strategy should only be used for critical scripts that need to be fetched as soon as possible.

Good to know: Scripts with beforeInteractive will always be injected inside the head of the HTML document regardless of where it's placed in the component.

Some examples of scripts that should be fetched as soon as possible with beforeInteractive include:

Scripts that use the afterInteractive strategy are injected into the HTML client-side and will load after some (or all) hydration occurs on the page. This is the default strategy of the Script component and should be used for any script that needs to load as soon as possible but not before any first-party Next.js code.

afterInteractive scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.

Some examples of scripts that are good candidates for afterInteractive include:

Scripts that use the lazyOnload strategy are injected into the HTML client-side during browser idle time and will load after all resources on the page have been fetched. This strategy should be used for any background or low priority scripts that do not need to load early.

lazyOnload scripts can be placed inside of any page or layout and will only load and execute when that page (or group of pages) is opened in the browser.

Examples of scripts that do not need to load immediately and can be fetched with lazyOnload include:

Warning: The worker strategy is not yet stable and does not yet work with the App Router. Use with caution.

Scripts that use the worker strategy are off-loaded to a web worker in order to free up the main thread and ensure that only critical, first-party resources are processed on it. While this strategy can be used for any script, it is an advanced use case that is not guaranteed to support all third-party scripts.

To use worker as a strategy, the nextScriptWorkers flag must be enabled in next.config.js:

worker scripts can only currently be used in the pages/ directory:

Warning: onLoad does not yet work with Server Components and can only be used in Client Components. Further, onLoad can't be used with beforeInteractive â€“ consider using onReady instead.

Some third-party scripts require users to run JavaScript code once after the script has finished loading in order to instantiate content or call a function. If you are loading a script with either afterInteractive or lazyOnload as a loading strategy, you can execute code after it has loaded using the onLoad property.

Here's an example of executing a lodash method only after the library has been loaded.

Warning: onReady does not yet work with Server Components and can only be used in Client Components.

Some third-party scripts require users to run JavaScript code after the script has finished loading and every time the component is mounted (after a route navigation for example). You can execute code after the script's load event when it first loads and then after every subsequent component re-mount using the onReady property.

Here's an example of how to re-instantiate a Google Maps JS embed every time the component is mounted:

Warning: onError does not yet work with Server Components and can only be used in Client Components. onError cannot be used with the beforeInteractive loading strategy.

Sometimes it is helpful to catch when a script fails to load. These errors can be handled with the onError property:

**Examples:**

Example 1 (python):
```python
import Script from 'next/script'
 
export default function Dashboard() {
  return (
    <>
      <Script src="https://example.com/script.js" />
    </>
  )
}
```

Example 2 (python):
```python
import Script from 'next/script'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        {children}
        <Script
          src="https://example.com/script.js"
          strategy="beforeInteractive"
        />
      </body>
    </html>
  )
}
```

Example 3 (python):
```python
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="afterInteractive" />
    </>
  )
}
```

Example 4 (python):
```python
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="lazyOnload" />
    </>
  )
}
```

---

## getServerSideProps

**URL:** https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props

**Contents:**
- getServerSideProps
- Example
- When should I use getServerSideProps?
- Behavior
- Error Handling
- Edge Cases
  - Caching with Server-Side Rendering (SSR)

getServerSideProps is a Next.js function that can be used to fetch data and render the contents of a page at request time.

You can use getServerSideProps by exporting it from a Page Component. The example below shows how you can fetch data from a 3rd party API in getServerSideProps, and pass the data to the page as props:

You should use getServerSideProps if you need to render a page that relies on personalized user data, or information that can only be known at request time. For example, authorization headers or a geolocation.

If you do not need to fetch the data at request time, or would prefer to cache the data and pre-rendered HTML, we recommend using getStaticProps.

If an error is thrown inside getServerSideProps, it will show the pages/500.js file. Check out the documentation for 500 page to learn more on how to create it. During development, this file will not be used and the development error overlay will be shown instead.

You can use caching headers (Cache-Control) inside getServerSideProps to cache dynamic responses. For example, using stale-while-revalidate.

However, before reaching for cache-control, we recommend seeing if getStaticProps with ISR is a better fit for your use case.

**Examples:**

Example 1 (python):
```python
import type { InferGetServerSidePropsType, GetServerSideProps } from 'next'
 
type Repo = {
  name: string
  stargazers_count: number
}
 
export const getServerSideProps = (async () => {
  // Fetch data from external API
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo: Repo = await res.json()
  // Pass data to the page via props
  return { props: { repo } }
}) satisfies GetServerSideProps<{ repo: Repo }>
 
export default function Page({
  repo,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return (
    <main>
      <p>{repo.stargazers_count}</p>
    </main>
  )
}
```

Example 2 (unknown):
```unknown
// This value is considered fresh for ten seconds (s-maxage=10).
// If a request is repeated within the next 10 seconds, the previously
// cached value will still be fresh. If the request is repeated before 59 seconds,
// the cached value will be stale but still render (stale-while-revalidate=59).
//
// In the background, a revalidation request will be made to populate the cache
// with a fresh value. If you refresh the page, you will see the new value.
export async function getServerSideProps({ req, res }) {
  res.setHeader(
    'Cache-Control',
    'public, s-maxage=10, stale-while-revalidate=59'
  )
 
  return {
    props: {},
  }
}
```

---

## manifest.json

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/metadata/manifest

**Contents:**
- manifest.json
- Static Manifest file
- Generate a Manifest file
  - Manifest Object

Add or generate a manifest.(json|webmanifest) file that matches the Web Manifest Specification in the root of app directory to provide information about your web application for the browser.

Add a manifest.js or manifest.ts file that returns a Manifest object.

Good to know: manifest.js is special Route Handlers that is cached by default unless it uses a Dynamic API or dynamic config option.

The manifest object contains an extensive list of options that may be updated due to new web standards. For information on all the current options, refer to the MetadataRoute.Manifest type in your code editor if using TypeScript or see the MDN docs.

**Examples:**

Example 1 (unknown):
```unknown
{
  "name": "My Next.js Application",
  "short_name": "Next.js App",
  "description": "An application built with Next.js",
  "start_url": "/"
  // ...
}
```

Example 2 (python):
```python
import type { MetadataRoute } from 'next'
 
export default function manifest(): MetadataRoute.Manifest {
  return {
    name: 'Next.js App',
    short_name: 'Next.js App',
    description: 'Next.js App',
    start_url: '/',
    display: 'standalone',
    background_color: '#fff',
    theme_color: '#fff',
    icons: [
      {
        src: '/favicon.ico',
        sizes: 'any',
        type: 'image/x-icon',
      },
    ],
  }
}
```

---

## useReportWebVitals

**URL:** https://nextjs.org/docs/pages/api-reference/functions/use-report-web-vitals

**Contents:**
- useReportWebVitals
- useReportWebVitals
- Web Vitals
- Custom Metrics
- Sending results to external systems

The useReportWebVitals hook allows you to report Core Web Vitals, and can be used in combination with your analytics service.

New functions passed to useReportWebVitals are called with the available metrics up to that point. To prevent reporting duplicated data, ensure that the callback function reference does not change (as shown in the code examples below).

The metric object passed as the hook's argument consists of a number of properties:

Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. The following web vitals are all included:

You can handle all the results of these metrics using the name property.

In addition to the core metrics listed above, there are some additional custom metrics that measure the time it takes for the page to hydrate and render:

You can handle all the results of these metrics separately:

These metrics work in all browsers that support the User Timing API.

You can send results to any endpoint to measure and track real user performance on your site. For example:

Good to know: If you use Google Analytics, using the id value can allow you to construct metric distributions manually (to calculate percentiles, etc.)

Read more about sending results to Google Analytics.

**Examples:**

Example 1 (python):
```python
import { useReportWebVitals } from 'next/web-vitals'
 
const logWebVitals = (metric) => {
  console.log(metric)
}
 
function MyApp({ Component, pageProps }) {
  useReportWebVitals(logWebVitals)
 
  return <Component {...pageProps} />
}
```

Example 2 (python):
```python
import { useReportWebVitals } from 'next/web-vitals'
 
const handleWebVitals = (metric) => {
  switch (metric.name) {
    case 'FCP': {
      // handle FCP results
    }
    case 'LCP': {
      // handle LCP results
    }
    // ...
  }
}
 
function MyApp({ Component, pageProps }) {
  useReportWebVitals(handleWebVitals)
 
  return <Component {...pageProps} />
}
```

Example 3 (python):
```python
import { useReportWebVitals } from 'next/web-vitals'
 
function handleCustomMetrics(metrics) {
  switch (metric.name) {
    case 'Next.js-hydration':
      // handle hydration results
      break
    case 'Next.js-route-change-to-render':
      // handle route-change to render results
      break
    case 'Next.js-render':
      // handle render results
      break
    default:
      break
  }
}
 
function MyApp({ Component, pageProps }) {
  useReportWebVitals(handleCustomMetrics)
 
  return <Component {...pageProps} />
}
```

Example 4 (javascript):
```javascript
function postWebVitals(metrics) {
  const body = JSON.stringify(metric)
  const url = 'https://example.com/analytics'
 
  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body)
  } else {
    fetch(url, { body, method: 'POST', keepalive: true })
  }
}
 
useReportWebVitals(postWebVitals)
```

---

## Testing

**URL:** https://nextjs.org/docs/pages/guides/testing

**Contents:**
- Testing
- Types of tests
- Guides
  - Cypress
  - Jest
  - Playwright
  - Vitest

In React and Next.js, there are a few different types of tests you can write, each with its own purpose and use cases. This page provides an overview of types and commonly used tools you can use to test your application.

See the guides below to learn how to set up Next.js with these commonly used testing tools:

---

## Custom App

**URL:** https://nextjs.org/docs/pages/building-your-application/routing/custom-app

**Contents:**
- Custom App
- Usage
- getInitialProps with App

Next.js uses the App component to initialize pages. You can override it and control the page initialization and:

To override the default App, create the file pages/_app as shown below:

The Component prop is the active page, so whenever you navigate between routes, Component will change to the new page. Therefore, any props you send to Component will be received by the page.

pageProps is an object with the initial props that were preloaded for your page by one of our data fetching methods, otherwise it's an empty object.

Using getInitialProps in App will disable Automatic Static Optimization for pages without getStaticProps.

We do not recommend using this pattern. Instead, consider incrementally adopting the App Router, which allows you to more easily fetch data for pages and layouts.

**Examples:**

Example 1 (python):
```python
import type { AppProps } from 'next/app'
 
export default function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}
```

Example 2 (python):
```python
import App, { AppContext, AppInitialProps, AppProps } from 'next/app'
 
type AppOwnProps = { example: string }
 
export default function MyApp({
  Component,
  pageProps,
  example,
}: AppProps & AppOwnProps) {
  return (
    <>
      <p>Data: {example}</p>
      <Component {...pageProps} />
    </>
  )
}
 
MyApp.getInitialProps = async (
  context: AppContext
): Promise<AppOwnProps & AppInitialProps> => {
  const ctx = await App.getInitialProps(context)
 
  return { ...ctx, example: 'data' }
}
```

---

## page.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/page

**Contents:**
- page.js
- Good to know
- Reference
  - Props
    - params (optional)
    - searchParams (optional)
  - Page Props Helper
- Examples
  - Displaying content based on params
  - Handling filtering with searchParams

The page file allows you to define UI that is unique to a route. You can create a page by default exporting a component from the file:

A promise that resolves to an object containing the dynamic route parameters from the root segment down to that page.

A promise that resolves to an object containing the search parameters of the current URL. For example:

Client Component pages can also access searchParams using Reactâ€™s use hook:

You can type pages with PageProps to get strongly typed params and searchParams from the route literal. PageProps is a globally available helper.

Using dynamic route segments, you can display or fetch specific content for the page based on the params prop.

You can use the searchParams prop to handle filtering, pagination, or sorting based on the query string of the URL.

To use searchParams and params in a Client Component (which cannot be async), you can use React's use function to read the promise:

**Examples:**

Example 1 (unknown):
```unknown
export default function Page({
  params,
  searchParams,
}: {
  params: Promise<{ slug: string }>
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  return <h1>My Page</h1>
}
```

Example 2 (javascript):
```javascript
export default async function Page({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
}
```

Example 3 (javascript):
```javascript
export default async function Page({
  searchParams,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const filters = (await searchParams).filters
}
```

Example 4 (python):
```python
'use client'
import { use } from 'react'
 
export default function Page({
  searchParams,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>
}) {
  const filters = use(searchParams).filters
}
```

---

## Caching in Next.js

**URL:** https://nextjs.org/docs/app/guides/caching

**Contents:**
- Caching in Next.js
- Overview
- Rendering Strategies
  - Static Rendering
  - Dynamic Rendering
- Request Memoization
  - Duration
  - Revalidating
  - Opting out
- Data Cache

Next.js improves your application's performance and reduces costs by caching rendering work and data requests. This page provides an in-depth look at Next.js caching mechanisms, the APIs you can use to configure them, and how they interact with each other.

Good to know: This page helps you understand how Next.js works under the hood but is not essential knowledge to be productive with Next.js. Most of Next.js' caching heuristics are determined by your API usage and have defaults for the best performance with zero or minimal configuration. If you instead want to jump to examples, start here.

Here's a high-level overview of the different caching mechanisms and their purpose:

By default, Next.js will cache as much as possible to improve performance and reduce cost. This means routes are statically rendered and data requests are cached unless you opt out. The diagram below shows the default caching behavior: when a route is statically rendered at build time and when a static route is first visited.

Caching behavior changes depending on whether the route is statically or dynamically rendered, data is cached or uncached, and whether a request is part of an initial visit or a subsequent navigation. Depending on your use case, you can configure the caching behavior for individual routes and data requests.

Fetch caching is not supported in proxy. Any fetches done inside of your proxy will be uncached.

To understand how caching works in Next.js, it's helpful to understand the rendering strategies available. The rendering strategy determines when your route's HTML is generated, which directly impacts what can be cached.

With Static Rendering, routes are rendered at build time or in the background after data revalidation. The result is cached and can be reused across requests. Static routes are fully cached in the Full Route Cache.

With Dynamic Rendering, routes are rendered at request time. This happens when your route uses request-specific information like cookies, headers, or search params.

A route becomes dynamic when it uses any of these APIs:

Dynamic routes are not cached in the Full Route Cache, but can still use the Data Cache for data requests.

Good to know: You can use Cache Components to mix static and dynamic rendering within the same route.

Next.js extends the fetch API to automatically memoize requests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once.

For example, if you need to use the same data across a route (e.g. in a Layout, Page, and multiple components), you do not have to fetch data at the top of the tree, and forward props between components. Instead, you can fetch data in the components that need it without worrying about the performance implications of making multiple requests across the network for the same data.

How Request Memoization Works

The cache lasts the lifetime of a server request until the React component tree has finished rendering.

Since the memoization is not shared across server requests and only applies during rendering, there is no need to revalidate it.

Memoization only applies to the GET method in fetch requests, other methods, such as POST and DELETE, are not memoized. This default behavior is a React optimization and we do not recommend opting out of it.

To manage individual requests, you can use the signal property from AbortController.

Next.js has a built-in Data Cache that persists the result of data fetches across incoming server requests and deployments. This is possible because Next.js extends the native fetch API to allow each request on the server to set its own persistent caching semantics.

Good to know: In the browser, the cache option of fetch indicates how a request will interact with the browser's HTTP cache, in Next.js, the cache option indicates how a server-side request will interact with the server's Data Cache.

You can use the cache and next.revalidate options of fetch to configure the caching behavior.

In development mode, fetch data is reused for Hot Module Replacement (HMR), and caching options are ignored for hard refreshes.

How the Data Cache Works

Differences between the Data Cache and Request Memoization

While both caching mechanisms help improve performance by re-using cached data, the Data Cache is persistent across incoming requests and deployments, whereas memoization only lasts the lifetime of a request.

The Data Cache is persistent across incoming requests and deployments unless you revalidate or opt-out.

Cached data can be revalidated in two ways, with:

To revalidate data at a timed interval, you can use the next.revalidate option of fetch to set the cache lifetime of a resource (in seconds).

Alternatively, you can use Route Segment Config options to configure all fetch requests in a segment or for cases where you're not able to use fetch.

How Time-based Revalidation Works

This is similar to stale-while-revalidate behavior.

Data can be revalidated on-demand by path (revalidatePath) or by cache tag (revalidateTag).

How On-Demand Revalidation Works

If you do not want to cache the response from fetch, you can do the following:

You may see the terms Automatic Static Optimization, Static Site Generation, or Static Rendering being used interchangeably to refer to the process of rendering and caching routes of your application at build time.

Next.js automatically renders and caches routes at build time. This is an optimization that allows you to serve the cached route instead of rendering on the server for every request, resulting in faster page loads.

To understand how the Full Route Cache works, it's helpful to look at how React handles rendering, and how Next.js caches the result:

On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks: by individual routes segments and Suspense boundaries.

Each chunk is rendered in two steps:

This means we don't have to wait for everything to render before caching the work or sending a response. Instead, we can stream a response as work is completed.

What is the React Server Component Payload?

The React Server Component Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The React Server Component Payload contains:

To learn more, see the Server Components documentation.

The default behavior of Next.js is to cache the rendered result (React Server Component Payload and HTML) of a route on the server. This applies to statically rendered routes at build time, or during revalidation.

At request time, on the client:

The React Server Component Payload is stored in the client-side Router Cache - a separate in-memory cache, split by individual route segment. This Router Cache is used to improve the navigation experience by storing previously visited routes and prefetching future routes.

On subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in the Router Cache. If so, it will skip sending a new request to the server.

If the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client.

Whether a route is cached or not at build time depends on whether it's statically or dynamically rendered. Static routes are cached by default, whereas dynamic routes are rendered at request time, and not cached.

This diagram shows the difference between statically and dynamically rendered routes, with cached and uncached data:

Learn more about static and dynamic rendering.

By default, the Full Route Cache is persistent. This means that the render output is cached across user requests.

There are two ways you can invalidate the Full Route Cache:

You can opt out of the Full Route Cache, or in other words, dynamically render components for every incoming request, by:

Next.js has an in-memory client-side router cache that stores the RSC payload of route segments, split by layouts, loading states, and pages.

When a user navigates between routes, Next.js caches the visited route segments and prefetches the routes the user is likely to navigate to. This results in instant back/forward navigation, no full-page reload between navigations, and preservation of browser state and React state in shared layouts.

With the Router Cache:

Good to know: This cache specifically applies to Next.js and Server Components, and is different to the browser's bfcache, though it has a similar result.

The cache is stored in the browser's temporary memory. Two factors determine how long the router cache lasts:

While a page refresh will clear all cached segments, the automatic invalidation period only affects the individual segment from the time it was prefetched.

Good to know: The experimental staleTimes config option can be used to adjust the automatic invalidation times mentioned above.

There are two ways you can invalidate the Router Cache:

As of Next.js 15, page segments are opted out by default.

Good to know: You can also opt out of prefetching by setting the prefetch prop of the <Link> component to false.

When configuring the different caching mechanisms, it's important to understand how they interact with each other:

The following table provides an overview of how different Next.js APIs affect caching:

By default, the <Link> component automatically prefetches routes from the Full Route Cache and adds the React Server Component Payload to the Router Cache.

To disable prefetching, you can set the prefetch prop to false. But this will not skip the cache permanently, the route segment will still be cached client-side when the user visits the route.

Learn more about the <Link> component.

The prefetch option of the useRouter hook can be used to manually prefetch a route. This adds the React Server Component Payload to the Router Cache.

See the useRouter hook API reference.

The refresh option of the useRouter hook can be used to manually refresh a route. This completely clears the Router Cache, and makes a new request to the server for the current route. refresh does not affect the Data or Full Route Cache.

The rendered result will be reconciled on the client while preserving React state and browser state.

See the useRouter hook API reference.

Data returned from fetch is not automatically cached in the Data Cache.

By default, when no cache or next.revalidate options are provided:

See the fetch API Reference for more options.

You can opt individual fetch into caching by setting the cache option to force-cache:

See the fetch API Reference for more options.

You can use the next.revalidate option of fetch to set the revalidation period (in seconds) of an individual fetch request. This will revalidate the Data Cache, which in turn will revalidate the Full Route Cache. Fresh data will be fetched, and components will be re-rendered on the server.

See the fetch API reference for more options.

Next.js has a cache tagging system for fine-grained data caching and revalidation.

For example, you can set a tag when fetching data:

Then, call revalidateTag with a tag to purge the cache entry:

There are two places you can use revalidateTag, depending on what you're trying to achieve:

revalidatePath allows you manually revalidate data and re-render the route segments below a specific path in a single operation. Calling the revalidatePath method revalidates the Data Cache, which in turn invalidates the Full Route Cache.

There are two places you can use revalidatePath, depending on what you're trying to achieve:

See the revalidatePath API reference for more information.

revalidatePath vs. router.refresh:

Calling router.refresh will clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Full Route Cache.

The difference is that revalidatePath purges the Data Cache and Full Route Cache, whereas router.refresh() does not change the Data Cache and Full Route Cache, as it is a client-side API.

Dynamic APIs like cookies and headers, and the searchParams prop in Pages depend on runtime incoming request information. Using them will opt a route out of the Full Route Cache, in other words, the route will be dynamically rendered.

Using cookies.set or cookies.delete in a Server Action invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. to reflect authentication changes).

See the cookies API reference.

The Route Segment Config options can be used to override the route segment defaults or when you're not able to use the fetch API (e.g. database client or 3rd party libraries).

The following Route Segment Config options will opt out of the Full Route Cache:

This config option will opt all fetches out of the Data Cache (i.e. no-store):

See the fetchCache to see more advanced options.

See the Route Segment Config documentation for more options.

For dynamic segments (e.g. app/blog/[slug]/page.js), paths provided by generateStaticParams are cached in the Full Route Cache at build time. At request time, Next.js will also cache paths that weren't known at build time the first time they're visited.

To statically render all paths at build time, supply the full list of paths to generateStaticParams:

To statically render a subset of paths at build time, and the rest the first time they're visited at runtime, return a partial list of paths:

To statically render all paths the first time they're visited, return an empty array (no paths will be rendered at build time) or utilize export const dynamic = 'force-static':

Good to know: You must return an array from generateStaticParams, even if it's empty. Otherwise, the route will be dynamically rendered.

To disable caching at request time, add the export const dynamicParams = false option in a route segment. When this config option is used, only paths provided by generateStaticParams will be served, and other routes will 404 or match (in the case of catch-all routes).

The React cache function allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once.

fetch requests using the GET or HEAD methods are automatically memoized, so you do not need to wrap it in React cache. However, for other fetch methods, or when using data fetching libraries (such as some database, CMS, or GraphQL clients) that don't inherently memoize requests, you can use cache to manually memoize data requests.

**Examples:**

Example 1 (javascript):
```javascript
async function getItem() {
  // The `fetch` function is automatically memoized and the result
  // is cached
  const res = await fetch('https://.../item/1')
  return res.json()
}
 
// This function is called twice, but only executed the first time
const item = await getItem() // cache MISS
 
// The second call could be anywhere in your route
const item = await getItem() // cache HIT
```

Example 2 (javascript):
```javascript
const { signal } = new AbortController()
fetch(url, { signal })
```

Example 3 (unknown):
```unknown
// Revalidate at most every hour
fetch('https://...', { next: { revalidate: 3600 } })
```

Example 4 (javascript):
```javascript
let data = await fetch('https://api.vercel.app/blog', { cache: 'no-store' })
```

---

## How to set up Jest with Next.js

**URL:** https://nextjs.org/docs/pages/guides/testing/jest

**Contents:**
- How to set up Jest with Next.js
- Quickstart
- Manual setup
- Setting up Jest (with Babel)
  - Handling stylesheets and image imports
- Handling Fonts
- Optional: Handling Absolute Imports and Module Path Aliases
- Optional: Extend Jest with custom matchers
- Add a test script to package.json
  - Creating your first test

Jest and React Testing Library are frequently used together for Unit Testing and Snapshot Testing. This guide will show you how to set up Jest with Next.js and write your first tests.

Good to know: Since async Server Components are new to the React ecosystem, Jest currently does not support them. While you can still run unit tests for synchronous Server and Client Components, we recommend using an E2E tests for async components.

You can use create-next-app with the Next.js with-jest example to quickly get started:

Since the release of Next.js 12, Next.js now has built-in configuration for Jest.

To set up Jest, install jest and the following packages as dev dependencies:

Generate a basic Jest configuration file by running the following command:

This will take you through a series of prompts to setup Jest for your project, including automatically creating a jest.config.ts|js file.

Update your config file to use next/jest. This transformer has all the necessary configuration options for Jest to work with Next.js:

Under the hood, next/jest is automatically configuring Jest for you, including:

Good to know: To test environment variables directly, load them manually in a separate setup script or in your jest.config.ts file. For more information, please see Test Environment Variables.

If you opt out of the Next.js Compiler and use Babel instead, you will need to manually configure Jest and install babel-jest and identity-obj-proxy in addition to the packages above.

Here are the recommended options to configure Jest for Next.js:

You can learn more about each configuration option in the Jest docs. We also recommend reviewing next/jest configuration to see how Next.js configures Jest.

Stylesheets and images aren't used in the tests but importing them may cause errors, so they will need to be mocked.

Create the mock files referenced in the configuration above - fileMock.js and styleMock.js - inside a __mocks__ directory:

For more information on handling static assets, please refer to the Jest Docs.

To handle fonts, create the nextFontMock.js file inside the __mocks__ directory, and add the following configuration:

If your project is using Module Path Aliases, you will need to configure Jest to resolve the imports by matching the paths option in the jsconfig.json file with the moduleNameMapper option in the jest.config.js file. For example:

@testing-library/jest-dom includes a set of convenient custom matchers such as .toBeInTheDocument() making it easier to write tests. You can import the custom matchers for every test by adding the following option to the Jest configuration file:

Then, inside jest.setup, add the following import:

Good to know: extend-expect was removed in v6.0, so if you are using @testing-library/jest-dom before version 6, you will need to import @testing-library/jest-dom/extend-expect instead.

If you need to add more setup options before each test, you can add them to the jest.setup file above.

Finally, add a Jest test script to your package.json file:

jest --watch will re-run tests when a file is changed. For more Jest CLI options, please refer to the Jest Docs.

Your project is now ready to run tests. Create a folder called __tests__ in your project's root directory.

For example, we can add a test to check if the <Home /> component successfully renders a heading:

Optionally, add a snapshot test to keep track of any unexpected changes in your component:

Good to know: Test files should not be included inside the Pages Router because any files inside the Pages Router are considered routes.

Then, run the following command to run your tests:

For further reading, you may find these resources helpful:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --example with-jest with-jest-app
```

Example 2 (unknown):
```unknown
npm install -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest
# or
yarn add -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest
# or
pnpm install -D jest jest-environment-jsdom @testing-library/react @testing-library/dom @testing-library/jest-dom ts-node @types/jest
```

Example 3 (unknown):
```unknown
npm init jest@latest
# or
yarn create jest@latest
# or
pnpm create jest@latest
```

Example 4 (python):
```python
import type { Config } from 'jest'
import nextJest from 'next/jest.js'
 
const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
})
 
// Add any custom config to be passed to Jest
const config: Config = {
  coverageProvider: 'v8',
  testEnvironment: 'jsdom',
  // Add more setup options before each test is run
  // setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
}
 
// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
export default createJestConfig(config)
```

---

## sassOptions

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/sassOptions

**Contents:**
- sassOptions

sassOptions allow you to configure the Sass compiler.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const sassOptions = {
  additionalData: `
    $var: red;
  `,
}
 
const nextConfig: NextConfig = {
  sassOptions: {
    ...sassOptions,
    implementation: 'sass-embedded',
  },
}
 
export default nextConfig
```

---

## next CLI

**URL:** https://nextjs.org/docs/app/api-reference/cli/next

**Contents:**
- next CLI
- Reference
  - Commands
  - next dev options
  - next build options
  - next start options
  - next info options
  - next telemetry options
  - next typegen options
- Examples

The Next.js CLI allows you to develop, build, start your application, and more.

The following options are available:

The following commands are available:

Good to know: Running next without a command is an alias for next dev.

next dev starts the application in development mode with Hot Module Reloading (HMR), error reporting, and more. The following options are available when running next dev:

next build creates an optimized production build of your application. The output displays information about each route. For example:

The following options are available for the next build command:

next start starts the application in production mode. The application should be compiled with next build first.

The following options are available for the next start command:

next info prints relevant details about the current system which can be used to report Next.js bugs when opening a GitHub issue. This information includes Operating System platform/arch/version, Binaries (Node.js, npm, Yarn, pnpm), package versions (next, react, react-dom), and more.

The output should look like this:

The following options are available for the next info command:

Next.js collects completely anonymous telemetry data about general usage. Participation in this anonymous program is optional, and you can opt-out if you prefer not to share information.

The following options are available for the next telemetry command:

Learn more about Telemetry.

next typegen generates TypeScript definitions for your application's routes without performing a full build. This is useful for IDE autocomplete and CI type-checking of route usage.

Previously, route types were only generated during next dev or next build, which meant running tsc --noEmit directly wouldn't validate your route types. Now you can generate types independently and validate them externally:

The following options are available for the next typegen command:

Output files are written to <distDir>/types (typically: .next/dev/types or .next/types, see isolatedDevBuild):

Additionally, next typegen generates a next-env.d.ts file. We recommend adding next-env.d.ts to your .gitignore file.

The next-env.d.ts file is included into your tsconfig.json file, to make Next.js types available to your project.

To ensure next-env.d.ts is present before type-checking run next typegen. The commands next dev and next build also generate the next-env.d.ts file, but it is often undesirable to run these just to type-check, for example in CI/CD environments.

Good to know: next typegen loads your Next.js config (next.config.js, next.config.mjs, or next.config.ts) using the production build phase. Ensure any required environment variables and dependencies are available so the config can load correctly.

If you encounter prerendering errors during next build, you can pass the --debug-prerender flag to get more detailed output:

This enables several experimental options to make debugging easier:

This helps surface more readable stack traces and code frames in the build output.

Warning: --debug-prerender is for debugging in development only. Do not deploy builds generated with --debug-prerender to production, as it may impact performance.

You can build only specific routes in the App and Pages Routers using the --debug-build-paths option. This is useful for faster debugging when working with large applications. The --debug-build-paths option accepts comma-separated file paths and supports glob patterns:

By default, Next.js uses http://localhost:3000 during development and with next start. The default port can be changed with the -p option, like so:

Or using the PORT environment variable:

Good to know: PORT cannot be set in .env as booting up the HTTP server happens before any other code is initialized.

For certain use cases like webhooks or authentication, you can use HTTPS to have a secure environment on localhost. Next.js can generate a self-signed certificate with next dev using the --experimental-https flag:

With the generated certificate, the Next.js development server will exist at https://localhost:3000. The default port 3000 is used unless a port is specified with -p, --port, or PORT.

You can also provide a custom certificate and key with --experimental-https-key and --experimental-https-cert. Optionally, you can provide a custom CA certificate with --experimental-https-ca as well.

next dev --experimental-https is only intended for development and creates a locally trusted certificate with mkcert. In production, use properly issued certificates from trusted authorities.

When deploying Next.js behind a downstream proxy (e.g. a load-balancer like AWS ELB/ALB), it's important to configure Next's underlying HTTP server with keep-alive timeouts that are larger than the downstream proxy's timeouts. Otherwise, once a keep-alive timeout is reached for a given TCP connection, Node.js will immediately terminate that connection without notifying the downstream proxy. This results in a proxy error whenever it attempts to reuse a connection that Node.js has already terminated.

To configure the timeout values for the production Next.js server, pass --keepAliveTimeout (in milliseconds) to next start, like so:

You can pass any node arguments to next commands. For example:

**Examples:**

Example 1 (unknown):
```unknown
npx next [command] [options]
```

Example 2 (unknown):
```unknown
Route (app)
â”Œ â—‹ /_not-found
â”” Æ’ /products/[id]
 
â—‹  (Static)   prerendered as static content
Æ’  (Dynamic)  server-rendered on demand
```

Example 3 (unknown):
```unknown
Operating System:
  Platform: darwin
  Arch: arm64
  Version: Darwin Kernel Version 23.6.0
  Available memory (MB): 65536
  Available CPU cores: 10
Binaries:
  Node: 20.12.0
  npm: 10.5.0
  Yarn: 1.22.19
  pnpm: 9.6.0
Relevant Packages:
  next: 15.0.0-canary.115 // Latest available version is detected (15.0.0-canary.115).
  eslint-config-next: 14.2.5
  react: 19.0.0-rc
  react-dom: 19.0.0
  typescript: 5.5.4
Next.js Config:
  output: N/A
```

Example 4 (unknown):
```unknown
# Generate route types first, then validate with TypeScript
next typegen && tsc --noEmit
 
# Or in CI workflows for type checking without building
next typegen && npm run type-check
```

---

## devIndicators

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/devIndicators

**Contents:**
- devIndicators
- Troubleshooting
  - Indicator not marking a route as static
- Version History

devIndicators allows you to configure the on-screen indicator that gives context about the current route you're viewing during development.

Setting devIndicators to false will hide the indicator, however Next.js will continue to surface any build or runtime errors that were encountered.

If you expect a route to be static and the indicator has marked it as dynamic, it's likely the route has opted out of static rendering.

You can confirm if a route is static or dynamic by building your application using next build --debug, and checking the output in your terminal. Static (or prerendered) routes will display a â—‹ symbol, whereas dynamic routes will display a Æ’ symbol. For example:

There are two reasons a route might opt out of static rendering:

Check your route for any of these conditions, and if you are not able to statically render the route, then consider using loading.js or <Suspense /> to leverage streaming.

**Examples:**

Example 1 (unknown):
```unknown
devIndicators: false | {
    position?: 'bottom-right'
    | 'bottom-left'
    | 'top-right'
    | 'top-left', // defaults to 'bottom-left',
  },
```

Example 2 (unknown):
```unknown
Route (app)
â”Œ â—‹ /_not-found
â”” Æ’ /products/[id]
 
â—‹  (Static)   prerendered as static content
Æ’  (Dynamic)  server-rendered on demand
```

---

## How to use markdown and MDX in Next.js

**URL:** https://nextjs.org/docs/app/guides/mdx

**Contents:**
- How to use markdown and MDX in Next.js
- Install dependencies
- Configure next.config.mjs
  - Handling .md files
- Add an mdx-components.tsx file
- Rendering MDX
  - Using file based routing
  - Using imports
  - Using dynamic imports
- Using custom styles and components

Markdown is a lightweight markup language used to format text. It allows you to write using plain text syntax and convert it to structurally valid HTML. It's commonly used for writing content on websites and blogs.

MDX is a superset of markdown that lets you write JSX directly in your markdown files. It is a powerful way to add dynamic interactivity and embed React components within your content.

Next.js can support both local MDX content inside your application, as well as remote MDX files fetched dynamically on the server. The Next.js plugin handles transforming markdown and React components into HTML, including support for usage in Server Components (the default in App Router).

Good to know: View the Portfolio Starter Kit template for a complete working example.

The @next/mdx package, and related packages, are used to configure Next.js so it can process markdown and MDX. It sources data from local files, allowing you to create pages with a .md or .mdx extension, directly in your /pages or /app directory.

Install these packages to render MDX with Next.js:

Update the next.config.mjs file at your project's root to configure it to use MDX:

This allows .mdx files to act as pages, routes, or imports in your application.

By default, next/mdx only compiles files with the .mdx extension. To handle .md files with webpack, update the extension option:

Create an mdx-components.tsx (or .js) file in the root of your project to define global MDX Components. For example, at the same level as pages or app, or inside src if applicable.

You can render MDX using Next.js's file based routing or by importing MDX files into other pages.

When using file based routing, you can use MDX pages like any other page.

In App Router apps, that includes being able to use metadata.

Create a new MDX page within the /app directory:

You can use MDX in these files, and even import React components, directly inside your MDX page:

Navigating to the /mdx-page route should display your rendered MDX page.

Create a new page within the /app directory and an MDX file wherever you'd like:

You can use MDX in these files, and even import React components, directly inside your MDX page:

Import the MDX file inside the page to display the content:

Navigating to the /mdx-page route should display your rendered MDX page.

You can import dynamic MDX components instead of using filesystem routing for MDX files.

For example, you can have a dynamic route segment which loads MDX components from a separate directory:

generateStaticParams can be used to prerender the provided routes. By marking dynamicParams as false, accessing a route not defined in generateStaticParams will 404.

Good to know: Ensure you specify the .mdx file extension in your import. While it is not required to use module path aliases (e.g., @/content), it does simplify your import path.

Markdown, when rendered, maps to native HTML elements. For example, writing the following markdown:

Generates the following HTML:

To style your markdown, you can provide custom components that map to the generated HTML elements. Styles and components can be implemented globally, locally, and with shared layouts.

Adding styles and components in mdx-components.tsx will affect all MDX files in your application.

You can apply local styles and components to specific pages by passing them into imported MDX components. These will merge with and override global styles and components.

To share a layout across MDX pages, you can use the built-in layouts support with the App Router.

If you are using Tailwind to style your application, using the @tailwindcss/typography plugin will allow you to reuse your Tailwind configuration and styles in your markdown files.

The plugin adds a set of prose classes that can be used to add typographic styles to content blocks that come from sources, like markdown.

Install Tailwind typography and use with shared layouts to add the prose you want.

Frontmatter is a YAML like key/value pairing that can be used to store data about a page. @next/mdx does not support frontmatter by default, though there are many solutions for adding frontmatter to your MDX content, such as:

@next/mdx does allow you to use exports like any other JavaScript component:

Metadata can now be referenced outside of the MDX file:

A common use case for this is when you want to iterate over a collection of MDX and extract data. For example, creating a blog index page from all blog posts. You can use packages like Node's fs module or globby to read a directory of posts and extract the metadata.

You can optionally provide remark and rehype plugins to transform the MDX content.

For example, you can use remark-gfm to support GitHub Flavored Markdown.

Since the remark and rehype ecosystem is ESM only, you'll need to use next.config.mjs or next.config.ts as the configuration file.

To use plugins with Turbopack, upgrade to the latest @next/mdx and specify plugin names using a string:

remark and rehype plugins without serializable options cannot be used yet with Turbopack, because JavaScript functions can't be passed to Rust.

If your MDX files or content lives somewhere else, you can fetch it dynamically on the server. This is useful for content stored in a CMS, database, or anywhere else. A community package for this use is next-mdx-remote-client.

Good to know: Please proceed with caution. MDX compiles to JavaScript and is executed on the server. You should only fetch MDX content from a trusted source, otherwise this can lead to remote code execution (RCE).

The following example uses next-mdx-remote-client:

Navigating to the /mdx-page-remote route should display your rendered MDX.

React does not natively understand markdown. The markdown plaintext needs to first be transformed into HTML. This can be accomplished with remark and rehype.

remark is an ecosystem of tools around markdown. rehype is the same, but for HTML. For example, the following code snippet transforms markdown into HTML:

The remark and rehype ecosystem contains plugins for syntax highlighting, linking headings, generating a table of contents, and more.

When using @next/mdx as shown above, you do not need to use remark or rehype directly, as it is handled for you. We're describing it here for a deeper understanding of what the @next/mdx package is doing underneath.

Next.js supports a new MDX compiler written in Rust. This compiler is still experimental and is not recommended for production use. To use the new compiler, you need to configure next.config.js when you pass it to withMDX:

mdxRs also accepts an object to configure how to transform mdx files.

**Examples:**

Example 1 (unknown):
```unknown
I **love** using [Next.js](https://nextjs.org/)
```

Example 2 (unknown):
```unknown
<p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>
```

Example 3 (unknown):
```unknown
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx
```

Example 4 (python):
```python
import createMDX from '@next/mdx'
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Configure `pageExtensions` to include markdown and MDX files
  pageExtensions: ['js', 'jsx', 'md', 'mdx', 'ts', 'tsx'],
  // Optionally, add any other Next.js config below
}
 
const withMDX = createMDX({
  // Add markdown plugins here, as desired
})
 
// Merge MDX config with Next.js config
export default withMDX(nextConfig)
```

---

## ESLint

**URL:** https://nextjs.org/docs/pages/api-reference/config/eslint

**Contents:**
- ESLint
- Setup ESLint
- Reference
  - Rules
- Examples
  - Specifying a root directory within a monorepo
  - Disabling rules
  - With Core Web Vitals
  - With TypeScript
  - With Prettier

Next.js provides an ESLint plugin, @next/eslint-plugin-next, already bundled within the base configuration that makes it possible to catch common issues and problems in a Next.js application.

Get linting working quickly with the ESLint CLI (flat config):

Install ESLint and the Next.js config:

Create eslint.config.mjs with the Next.js config:

Recommended rule-sets from the following ESLint plugins are all used within eslint-config-next:

The full set of rules is as follows:

We recommend using an appropriate integration to view warnings and errors directly in your code editor during development.

Starting with Next.js 16, next lint is removed.

As part of the removal, the eslint option in your Next config file is no longer needed and can be safely removed.

If you're using @next/eslint-plugin-next in a project where Next.js isn't installed in your root directory (such as a monorepo), you can tell @next/eslint-plugin-next where to find your Next.js application using the settings property in your eslint.config.mjs:

rootDir can be a path (relative or absolute), a glob (i.e. "packages/*/"), or an array of paths and/or globs.

If you would like to modify or disable any rules provided by the supported plugins (react, react-hooks, next), you can directly change them using the rules property in your eslint.config.mjs:

Enable the next/core-web-vitals rule set by extending it in your ESLint config.

next/core-web-vitals updates @next/eslint-plugin-next to error on a number of rules that are warnings by default if they affect Core Web Vitals.

The next/core-web-vitals entry point is automatically included for new applications built with Create Next App.

In addition to the Next.js ESLint rules, create-next-app --typescript will also add TypeScript-specific lint rules with next/typescript to your config:

Those rules are based on plugin:@typescript-eslint/recommended. See typescript-eslint > Configs for more details.

ESLint also contains code formatting rules, which can conflict with your existing Prettier setup. We recommend including eslint-config-prettier in your ESLint config to make ESLint and Prettier work together.

First, install the dependency:

Then, add prettier to your existing ESLint config:

If you would like to use ESLint with lint-staged to run the linter on staged git files, add the following to the .lintstagedrc.js file in the root of your project:

If you already have ESLint configured in your application, we recommend extending from this plugin directly instead of including eslint-config-next unless a few conditions are met.

If the following conditions are true:

Then we recommend either removing these settings if you prefer how these properties have been configured within eslint-config-next or extending directly from the Next.js ESLint plugin instead:

The plugin can be installed normally in your project:

This eliminates the risk of collisions or errors that can occur due to importing the same plugin or parser across multiple configurations.

If you already use a separate ESLint configuration and want to include eslint-config-next, ensure that it is extended last after other configurations. For example:

The next configuration already handles setting default values for the parser, plugins and settings properties. There is no need to manually re-declare any of these properties unless you need a different configuration for your use case.

If you include any other shareable configurations, you will need to make sure that these properties are not overwritten or modified. Otherwise, we recommend removing any configurations that share behavior with the next configuration or extending directly from the Next.js ESLint plugin as mentioned above.

**Examples:**

Example 1 (unknown):
```unknown
pnpm add -D eslint eslint-config-next
```

Example 2 (python):
```python
import { defineConfig, globalIgnores } from 'eslint/config'
import nextVitals from 'eslint-config-next/core-web-vitals'
 
const eslintConfig = defineConfig([
  ...nextVitals,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    '.next/**',
    'out/**',
    'build/**',
    'next-env.d.ts',
  ]),
])
 
export default eslintConfig
```

Example 3 (unknown):
```unknown
pnpm exec eslint .
```

Example 4 (python):
```python
import { defineConfig } from 'eslint/config'
import eslintNextPlugin from '@next/eslint-plugin-next'
 
const eslintConfig = defineConfig([
  {
    plugins: {
      next: eslintNextPlugin,
    },
    settings: {
      next: {
        rootDir: 'packages/my-app/',
      },
    },
    files: [
      // ...files
    ],
    ignores: [
      // ...ignores
    ],
  },
])
 
export default eslintConfig
```

---

## File-system conventions

**URL:** https://nextjs.org/docs/15/app/api-reference/file-conventions

**Contents:**
- File-system conventions
  - default.js
  - Dynamic Segments
  - error.js
  - forbidden.js
  - instrumentation.js
  - instrumentation-client.js
  - Intercepting Routes
  - layout.js
  - loading.js

---

## How to implement authentication in Next.js

**URL:** https://nextjs.org/docs/app/guides/authentication

**Contents:**
- How to implement authentication in Next.js
- Authentication
  - Sign-up and login functionality
    - 1. Capture user credentials
    - 2. Validate form fields on the server
    - 3. Create a user or check user credentials
- Session Management
  - Stateless Sessions
    - 1. Generating a secret key
    - 2. Encrypting and decrypting sessions

Understanding authentication is crucial for protecting your application's data. This page will guide you through what React and Next.js features to use to implement auth.

Before starting, it helps to break down the process into three concepts:

This diagram shows the authentication flow using React and Next.js features:

The examples on this page walk through basic username and password auth for educational purposes. While you can implement a custom auth solution, for increased security and simplicity, we recommend using an authentication library. These offer built-in solutions for authentication, session management, and authorization, as well as additional features such as social logins, multi-factor authentication, and role-based access control. You can find a list in the Auth Libraries section.

You can use the <form> element with React's Server Actions and useActionState to capture user credentials, validate form fields, and call your Authentication Provider's API or database.

Since Server Actions always execute on the server, they provide a secure environment for handling authentication logic.

Here are the steps to implement signup/login functionality:

To capture user credentials, create a form that invokes a Server Action on submission. For example, a signup form that accepts the user's name, email, and password:

Use the Server Action to validate the form fields on the server. If your authentication provider doesn't provide form validation, you can use a schema validation library like Zod or Yup.

Using Zod as an example, you can define a form schema with appropriate error messages:

To prevent unnecessary calls to your authentication provider's API or database, you can return early in the Server Action if any form fields do not match the defined schema.

Back in your <SignupForm />, you can use React's useActionState hook to display validation errors while the form is submitting:

After validating form fields, you can create a new user account or check if the user exists by calling your authentication provider's API or database.

Continuing from the previous example:

After successfully creating the user account or verifying the user credentials, you can create a session to manage the user's auth state. Depending on your session management strategy, the session can be stored in a cookie or database, or both. Continue to the Session Management section to learn more.

Session management ensures that the user's authenticated state is preserved across requests. It involves creating, storing, refreshing, and deleting sessions or tokens.

There are two types of sessions:

Good to know: While you can use either method, or both, we recommend using a session management library such as iron-session or Jose.

To create and manage stateless sessions, there are a few steps you need to follow:

In addition to the above, consider adding functionality to update (or refresh) the session when the user returns to the application, and delete the session when the user logs out.

Good to know: Check if your auth library includes session management.

There are a few ways you can generate secret key to sign your session. For example, you may choose to use the openssl command in your terminal:

This command generates a 32-character random string that you can use as your secret key and store in your environment variables file:

You can then reference this key in your session management logic:

Next, you can use your preferred session management library to encrypt and decrypt sessions. Continuing from the previous example, we'll use Jose (compatible with the Edge Runtime) and React's server-only package to ensure that your session management logic is only executed on the server.

To store the session in a cookie, use the Next.js cookies API. The cookie should be set on the server, and include the recommended options:

Please refer to MDN for more information on each of these options.

Back in your Server Action, you can invoke the createSession() function, and use the redirect() API to redirect the user to the appropriate page:

You can also extend the session's expiration time. This is useful for keeping the user logged in after they access the application again. For example:

Tip: Check if your auth library supports refresh tokens, which can be used to extend the user's session.

To delete the session, you can delete the cookie:

Then you can reuse the deleteSession() function in your application, for example, on logout:

To create and manage database sessions, you'll need to follow these steps:

After implementing session management, you'll need to add authorization logic to control what users can access and do within your application. Continue to the Authorization section to learn more.

Once a user is authenticated and a session is created, you can implement authorization to control what the user can access and do within your application.

There are two main types of authorization checks:

For both cases, we recommend:

There are some cases where you may want to use Proxy and redirect users based on permissions:

However, since Proxy runs on every route, including prefetched routes, it's important to only read the session from the cookie (optimistic checks), and avoid database checks to prevent performance issues.

While Proxy can be useful for initial checks, it should not be your only line of defense in protecting your data. The majority of security checks should be performed as close as possible to your data source, see Data Access Layer for more information.

We recommend creating a DAL to centralize your data requests and authorization logic.

The DAL should include a function that verifies the user's session as they interact with your application. At the very least, the function should check if the session is valid, then redirect or return the user information needed to make further requests.

For example, create a separate file for your DAL that includes a verifySession() function. Then use React's cache API to memoize the return value of the function during a React render pass:

You can then invoke the verifySession() function in your data requests, Server Actions, Route Handlers:

When retrieving data, it's recommended you return only the necessary data that will be used in your application, and not entire objects. For example, if you're fetching user data, you might only return the user's ID and name, rather than the entire user object which could contain passwords, phone numbers, etc.

However, if you have no control over the returned data structure, or are working in a team where you want to avoid whole objects being passed to the client, you can use strategies such as specifying what fields are safe to be exposed to the client.

By centralizing your data requests and authorization logic in a DAL and using DTOs, you can ensure that all data requests are secure and consistent, making it easier to maintain, audit, and debug as your application scales.

Auth check in Server Components are useful for role-based access. For example, to conditionally render components based on the user's role:

In the example, we use the verifySession() function from our DAL to check for 'admin', 'user', and unauthorized roles. This pattern ensures that each user interacts only with components appropriate to their role.

Due to Partial Rendering, be cautious when doing checks in Layouts as these don't re-render on navigation, meaning the user session won't be checked on every route change.

Instead, you should do the checks close to your data source or the component that'll be conditionally rendered.

For example, consider a shared layout that fetches the user data and displays the user image in a nav. Instead of doing the auth check in the layout, you should fetch the user data (getUser()) in the layout and do the auth check in your DAL.

This guarantees that wherever getUser() is called within your application, the auth check is performed, and prevents developers forgetting to check the user is authorized to access the data.

Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation.

In the example below, we check the user's role before allowing the action to proceed:

Treat Route Handlers with the same security considerations as public-facing API endpoints, and verify if the user is allowed to access the Route Handler.

The example above demonstrates a Route Handler with a two-tier security check. It first checks for an active session, and then verifies if the logged-in user is an 'admin'.

Using context providers for auth works due to interleaving. However, React context is not supported in Server Components, making them only applicable to Client Components.

This works, but any child Server Components will be rendered on the server first, and will not have access to the context providerâ€™s session data:

If session data is needed in Client Components (e.g. for client-side data fetching), use Reactâ€™s taintUniqueValue API to prevent sensitive session data from being exposed to the client.

Now that you've learned about authentication in Next.js, here are Next.js-compatible libraries and resources to help you implement secure authentication and session management:

To continue learning about authentication and security, check out the following resources:

**Examples:**

Example 1 (python):
```python
import { signup } from '@/app/actions/auth'
 
export function SignupForm() {
  return (
    <form action={signup}>
      <div>
        <label htmlFor="name">Name</label>
        <input id="name" name="name" placeholder="Name" />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Sign Up</button>
    </form>
  )
}
```

Example 2 (unknown):
```unknown
export async function signup(formData: FormData) {}
```

Example 3 (python):
```python
import * as z from 'zod'
 
export const SignupFormSchema = z.object({
  name: z
    .string()
    .min(2, { error: 'Name must be at least 2 characters long.' })
    .trim(),
  email: z.email({ error: 'Please enter a valid email.' }).trim(),
  password: z
    .string()
    .min(8, { error: 'Be at least 8 characters long' })
    .regex(/[a-zA-Z]/, { error: 'Contain at least one letter.' })
    .regex(/[0-9]/, { error: 'Contain at least one number.' })
    .regex(/[^a-zA-Z0-9]/, {
      error: 'Contain at least one special character.',
    })
    .trim(),
})
 
export type FormState =
  | {
      errors?: {
        name?: string[]
        email?: string[]
        password?: string[]
      }
      message?: string
    }
  | undefined
```

Example 4 (python):
```python
import { SignupFormSchema, FormState } from '@/app/lib/definitions'
 
export async function signup(state: FormState, formData: FormData) {
  // Validate form fields
  const validatedFields = SignupFormSchema.safeParse({
    name: formData.get('name'),
    email: formData.get('email'),
    password: formData.get('password'),
  })
 
  // If any form fields are invalid, return early
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }
 
  // Call the provider or db to create a user...
}
```

---

## getInitialProps

**URL:** https://nextjs.org/docs/pages/api-reference/functions/get-initial-props

**Contents:**
- getInitialProps
- Context Object
- Caveats

Good to know: getInitialProps is a legacy API. We recommend using getStaticProps or getServerSideProps instead.

getInitialProps is an async function that can be added to the default exported React component for the page. It will run on both the server-side and again on the client-side during page transitions. The result of the function will be forwarded to the React component as props.

getInitialProps receives a single argument called context, which is an object with the following properties:

**Examples:**

Example 1 (python):
```python
import { NextPageContext } from 'next'
 
Page.getInitialProps = async (ctx: NextPageContext) => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const json = await res.json()
  return { stars: json.stargazers_count }
}
 
export default function Page({ stars }: { stars: number }) {
  return stars
}
```

---

## use cache

**URL:** https://nextjs.org/docs/app/api-reference/directives/use-cache

**Contents:**
- use cache
- Usage
- How use cache works
  - Cache keys
- Non-serializable arguments
- Return values
- use cache at build time
- use cache at runtime
- During revalidation
- Examples

The use cache directive allows you to mark a route, React component, or a function as cacheable. It can be used at the top of a file to indicate that all exports in the file should be cached, or inline at the top of function or component to cache the return value.

Good to know: For caching user-specific content that requires access to cookies or headers, see 'use cache: private'.

use cache is a Cache Components feature. To enable it, add the cacheComponents option to your next.config.ts file:

Then, add use cache at the file, component, or function level:

A cache entry's key is generated using a serialized version of its inputs, which includes:

The arguments passed to the cached function, as well as any values it reads from the parent scope automatically become a part of the key. This means, the same cache entry will be reused as long as its inputs are the same.

Any non-serializable arguments, props, or closed-over values will turn into references inside the cached function, and can be only passed through and not inspected nor modified. These non-serializable values will be filled in at the request time and won't become a part of the cache key.

For example, a cached function can take in JSX as a children prop and return <div>{children}</div>, but it won't be able to introspect the actual children object. This allows you to nest uncached content inside a cached component.

The return value of the cacheable function must be serializable props. This ensures that the cached data can be stored and retrieved correctly.

Good to know: The supported types for arguments and the supported types for returned values are not the same. For more details, refer to Serializable Parameters and Return Values for function arguments and Serializable Types for return values.

When used at the top of a layout or page, the route segment will be prerendered, allowing it to later be revalidated.

This means use cache cannot be used with runtime data like cookies or headers.

Note: If you need to cache content that depends on cookies, headers, or search params, use 'use cache: private' instead.

On the server, the cache entries of individual components or functions will be cached in-memory.

Then, on the client, any content returned from the server cache will be stored in the browser's memory for the duration of the session or until revalidated.

By default, use cache has server-side revalidation period of 15 minutes. While this period may be useful for content that doesn't require frequent updates, you can use the cacheLife and cacheTag APIs to configure when the individual cache entries should be revalidated.

Both of these APIs integrate across the client and server caching layers, meaning you can configure your caching semantics in one place and have them apply everywhere.

See the cacheLife and cacheTag API docs for more information.

To pre-render an entire route, add use cache to the top of both the layout and page files. Each of these segments are treated as separate entry points in your application, and will be cached independently.

Any components imported and nested in page file are part of the cache output associated with the page.

You can use use cache at the component level to cache any fetches or computations performed within that component. The cache entry will be reused as long as the serialized props produce the same value in each instance.

Since you can add use cache to any asynchronous function, you aren't limited to caching components or routes only. You might want to cache a network request, a database query, or a slow computation.

In React, composition with children or slots is a well-known pattern for building flexible components. When using use cache, you can continue to compose your UI in this way. Anything included as children, or other compositional slots, in the returned JSX will be passed through the cached component without affecting its cache entry.

As long as you don't directly reference any of the JSX slots inside the body of the cacheable function itself, their presence in the returned output won't affect the cache entry.

You can also pass Server Actions through cached components to Client Components without invoking them inside the cacheable function.

Learn how to configure caching when self-hosting Next.js.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  cacheComponents: true,
}
 
export default nextConfig
```

Example 2 (javascript):
```javascript
// File level
'use cache'
 
export default async function Page() {
  // ...
}
 
// Component level
export async function MyComponent() {
  'use cache'
  return <></>
}
 
// Function level
export async function getData() {
  'use cache'
  const data = await fetch('/api/data')
  return data
}
```

Example 3 (unknown):
```unknown
async function CachedComponent({ children }: { children: ReactNode }) {
  'use cache'
  return <div>{children}</div>
}
```

Example 4 (unknown):
```unknown
'use cache'
 
export default async function Layout({ children }: { children: ReactNode }) {
  return <div>{children}</div>
}
```

---

## How to migrate from Create React App to Next.js

**URL:** https://nextjs.org/docs/pages/guides/migrating/from-create-react-app

**Contents:**
- How to migrate from Create React App to Next.js
- Why Switch?
  - Slow initial page loading time
  - No automatic code splitting
  - Network waterfalls
  - Fast and intentional loading states
  - Choose the data fetching strategy
  - Proxy
  - Built-in Optimizations
- Migration Steps

This guide will help you migrate an existing Create React App (CRA) site to Next.js.

There are several reasons why you might want to switch from Create React App to Next.js:

Create React App uses purely client-side rendering. Client-side only applications, also known as single-page applications (SPAs), often experience slow initial page loading time. This happens due to a couple of reasons:

The previous issue of slow loading times can be somewhat mitigated with code splitting. However, if you try to do code splitting manually, you can inadvertently introduce network waterfalls. Next.js provides automatic code splitting and tree-shaking built into its router and build pipeline.

A common cause of poor performance occurs when applications make sequential client-server requests to fetch data. One pattern for data fetching in a SPA is to render a placeholder, and then fetch data after the component has mounted. Unfortunately, a child component can only begin fetching data after its parent has finished loading its own data, resulting in a â€œwaterfallâ€ of requests.

While client-side data fetching is supported in Next.js, Next.js also lets you move data fetching to the server. This often eliminates client-server waterfalls altogether.

With built-in support for streaming through React Suspense, you can define which parts of your UI load first and in what order, without creating network waterfalls.

This enables you to build pages that are faster to load and eliminate layout shifts.

Depending on your needs, Next.js allows you to choose your data fetching strategy on a page or component-level basis. For example, you could fetch data from your CMS and render blog posts at build time (SSG) for quick load speeds, or fetch data at request time (SSR) when necessary.

Next.js Proxy allows you to run code on the server before a request is completed. For instance, you can avoid a flash of unauthenticated content by redirecting a user to a login page in the proxy for authenticated-only pages. You can also use it for features like A/B testing, experimentation, and internationalization.

Images, fonts, and third-party scripts often have a large impact on an applicationâ€™s performance. Next.js includes specialized components and APIs that automatically optimize them for you.

Our goal is to get a working Next.js application as quickly as possible so that you can then adopt Next.js features incrementally. To begin with, weâ€™ll treat your application as a purely client-side application (SPA) without immediately replacing your existing router. This reduces complexity and merge conflicts.

Note: If you are using advanced CRA configurations such as a custom homepage field in your package.json, a custom service worker, or specific Babel/webpack tweaks, please see the Additional Considerations section at the end of this guide for tips on replicating or adapting these features in Next.js.

Install Next.js in your existing project:

Create a next.config.ts at the root of your project (same level as your package.json). This file holds your Next.js configuration options.

Note: Using output: 'export' means youâ€™re doing a static export. You will not have access to server-side features like SSR or APIs. You can remove this line to leverage Next.js server features.

A Next.js App Router application must include a root layout file, which is a React Server Component that will wrap all your pages.

The closest equivalent of the root layout file in a CRA application is public/index.html, which includes your <html>, <head>, and <body> tags.

Now copy the content of your old index.html into this <RootLayout> component. Replace body div#root (and body noscript) with <div id="root">{children}</div>.

Good to know: Next.js ignores CRAâ€™s public/manifest.json, additional iconography, and testing configuration by default. If you need these, Next.js has support with its Metadata API and Testing setup.

Next.js automatically includes the <meta charset="UTF-8" /> and <meta name="viewport" content="width=device-width, initial-scale=1" /> tags, so you can remove them from <head>:

Any metadata files such as favicon.ico, icon.png, robots.txt are automatically added to the application <head> tag as long as you have them placed into the top level of the app directory. After moving all supported files into the app directory you can safely delete their <link> tags:

Finally, Next.js can manage your last <head> tags with the Metadata API. Move your final metadata info into an exported metadata object:

With the above changes, you shifted from declaring everything in your index.html to using Next.js' convention-based approach built into the framework (Metadata API). This approach enables you to more easily improve your SEO and web shareability of your pages.

Like CRA, Next.js supports CSS Modules out of the box. It also supports global CSS imports.

If you have a global CSS file, import it into your app/layout.tsx:

If you're using Tailwind CSS, see our installation docs.

Create React App uses src/index.tsx (or index.js) as the entry point. In Next.js (App Router), each folder inside the app directory corresponds to a route, and each folder should have a page.tsx.

Since we want to keep the app as an SPA for now and intercept all routes, weâ€™ll use an optional catch-all route.

This tells Next.js to generate a single route for the empty slug (/), effectively mapping all routes to the same page. This page is a Server Component, prerendered into static HTML.

Next, weâ€™ll embed your CRAâ€™s root App component inside a Client Component so that all logic remains client-side. If this is your first time using Next.js, it's worth knowing that clients components (by default) are still prerendered on the server. You can think about them as having the additional capability of running client-side JavaScript.

Create a client.tsx (or client.js) in app/[[...slug]]/:

Now update your page.tsx (or page.js) to use your new component:

In CRA, importing an image file returns its public URL as a string:

With Next.js, static image imports return an object. The object can then be used directly with the Next.js <Image> component, or you can use the object's src property with your existing <img> tag.

The <Image> component has the added benefits of automatic image optimization. The <Image> component automatically sets the width and height attributes of the resulting <img> based on the image's dimensions. This prevents layout shifts when the image loads. However, this can cause issues if your app contains images with only one of their dimensions being styled without the other styled to auto. When not styled to auto, the dimension will default to the <img> dimension attribute's value, which can cause the image to appear distorted.

Keeping the <img> tag will reduce the amount of changes in your application and prevent the above issues. You can then optionally later migrate to the <Image> component to take advantage of optimizing images by configuring a loader, or moving to the default Next.js server which has automatic image optimization.

Convert absolute import paths for images imported from /public into relative imports:

Pass the image src property instead of the whole image object to your <img> tag:

Alternatively, you can reference the public URL for the image asset based on the filename. For example, public/logo.png will serve the image at /logo.png for your application, which would be the src value.

Warning: If you're using TypeScript, you might encounter type errors when accessing the src property. To fix them, you need to add next-env.d.ts to the include array of your tsconfig.json file. Next.js will automatically generate this file when you run your application on step 9.

Next.js supports environment variables similarly to CRA but requires a NEXT_PUBLIC_ prefix for any variable you want to expose in the browser.

The main difference is the prefix used to expose environment variables on the client-side. Change all environment variables with the REACT_APP_ prefix to NEXT_PUBLIC_.

Update your package.json scripts to use Next.js commands. Also, add .next and next-env.d.ts to your .gitignore:

Open http://localhost:3000. You should see your application now running on Next.js (in SPA mode).

You can now remove artifacts that are specific to Create React App:

If you used the homepage field in your CRA package.json to serve the app under a specific subpath, you can replicate that in Next.js using the basePath configuration in next.config.ts:

If you used CRAâ€™s service worker (e.g., serviceWorker.js from create-react-app), you can learn how to create Progressive Web Applications (PWAs) with Next.js.

If your CRA app used the proxy field in package.json to forward requests to a backend server, you can replicate this with Next.js rewrites in next.config.ts:

If you had a custom webpack or Babel configuration in CRA, you can extend Next.jsâ€™s config in next.config.ts:

Note: This will require using Webpack by adding --webpack to your dev script.

Next.js automatically sets up TypeScript if you have a tsconfig.json. Make sure next-env.d.ts is listed in your tsconfig.json include array:

Create React App uses webpack for bundling. Next.js now defaults to Turbopack for faster local development:

To use Webpack instead (similar to CRA):

You can still provide a custom webpack configuration if you need to migrate advanced webpack settings from CRA.

If everything worked, you now have a functioning Next.js application running as a single-page application. You arenâ€™t yet leveraging Next.js features like server-side rendering or file-based routing, but you can now do so incrementally:

Note: Using a static export (output: 'export') does not currently support the useParams hook or other server features. To use all Next.js features, remove output: 'export' from your next.config.ts.

**Examples:**

Example 1 (unknown):
```unknown
npm install next@latest
```

Example 2 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  output: 'export', // Outputs a Single-Page Application (SPA)
  distDir: 'build', // Changes the build output directory to `build`
}
 
export default nextConfig
```

Example 3 (unknown):
```unknown
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return '...'
}
```

Example 4 (unknown):
```unknown
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <meta charSet="UTF-8" />
        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>React App</title>
        <meta name="description" content="Web site created..." />
      </head>
      <body>
        <div id="root">{children}</div>
      </body>
    </html>
  )
}
```

---

## headers

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js/headers

**Contents:**
- headers
- Header Overriding Behavior
- Path Matching
  - Wildcard Path Matching
  - Regex Path Matching
- Header, Cookie, and Query Matching
- Headers with basePath support
- Headers with i18n support
- Cache-Control
- Options

Headers allow you to set custom HTTP headers on the response to an incoming request on a given path.

To set custom HTTP headers you can use the headers key in next.config.js:

headers is an async function that expects an array to be returned holding objects with source and headers properties:

Headers are checked before the filesystem which includes pages and /public files.

If two headers match the same path and set the same header key, the last header key will override the first. Using the below headers, the path /hello will result in the header x-hello being world due to the last header value set being world.

Path matches are allowed, for example /blog/:slug will match /blog/first-post (no nested paths):

The pattern /blog/:slug matches /blog/first-post and /blog/post-1 but not a nested path like /blog/a/b. Patterns are anchored to the start, /blog/:slug will not match /archive/blog/first-post.

You can use modifiers on parameters: * (zero or more), + (one or more), ? (zero or one). For example, /blog/:slug* matches /blog, /blog/a, and /blog/a/b/c.

Read more details on path-to-regexp documentation.

To match a wildcard path you can use * after a parameter, for example /blog/:slug* will match /blog/a/b/c/d/hello-world:

To match a regex path you can wrap the regex in parenthesis after a parameter, for example /blog/:slug(\\d{1,}) will match /blog/123 but not /blog/abc:

The following characters (, ), {, }, :, *, +, ? are used for regex path matching, so when used in the source as non-special values they must be escaped by adding \\ before them:

To only apply a header when header, cookie, or query values also match the has field or don't match the missing field can be used. Both the source and all has items must match and all missing items must not match for the header to be applied.

has and missing items can have the following fields:

When leveraging basePath support with headers each source is automatically prefixed with the basePath unless you add basePath: false to the header:

When leveraging i18n support with headers each source is automatically prefixed to handle the configured locales unless you add locale: false to the header. If locale: false is used you must prefix the source with a locale for it to be matched correctly.

Next.js sets the Cache-Control header of public, max-age=31536000, immutable for truly immutable assets. It cannot be overridden. These immutable files contain a SHA-hash in the file name, so they can be safely cached indefinitely. For example, Static Image Imports. You cannot set Cache-Control headers in next.config.js for these assets.

However, you can set Cache-Control headers for other responses or data.

If you need to revalidate the cache of a page that has been statically generated, you can do so by setting the revalidate prop in the page's getStaticProps function.

To cache the response from an API Route, you can use res.setHeader:

You can also use caching headers (Cache-Control) inside getServerSideProps to cache dynamic responses. For example, using stale-while-revalidate.

Cross-Origin Resource Sharing (CORS) is a security feature that allows you to control which sites can access your resources. You can set the Access-Control-Allow-Origin header to allow a specific origin to access your API Endpoints.

This header controls DNS prefetching, allowing browsers to proactively perform domain name resolution on external links, images, CSS, JavaScript, and more. This prefetching is performed in the background, so the DNS is more likely to be resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.

This header informs browsers it should only be accessed using HTTPS, instead of using HTTP. Using the configuration below, all present and future subdomains will use HTTPS for a max-age of 2 years. This blocks access to pages or subdomains that can only be served over HTTP.

This header indicates whether the site should be allowed to be displayed within an iframe. This can prevent against clickjacking attacks.

This header has been superseded by CSP's frame-ancestors option, which has better support in modern browsers (see Content Security Policy for configuration details).

This header allows you to control which features and APIs can be used in the browser. It was previously named Feature-Policy.

This header prevents the browser from attempting to guess the type of content if the Content-Type header is not explicitly set. This can prevent XSS exploits for websites that allow users to upload and share files.

For example, a user trying to download an image, but having it treated as a different Content-Type like an executable, which could be malicious. This header also applies to downloading browser extensions. The only valid value for this header is nosniff.

This header controls how much information the browser includes when navigating from the current website (origin) to another.

Learn more about adding a Content Security Policy to your application.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  async headers() {
    return [
      {
        source: '/about',
        headers: [
          {
            key: 'x-custom-header',
            value: 'my custom header value',
          },
          {
            key: 'x-another-custom-header',
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

Example 2 (unknown):
```unknown
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'x-hello',
            value: 'there',
          },
        ],
      },
      {
        source: '/hello',
        headers: [
          {
            key: 'x-hello',
            value: 'world',
          },
        ],
      },
    ]
  },
}
```

Example 3 (unknown):
```unknown
module.exports = {
  async headers() {
    return [
      {
        source: '/blog/:slug',
        headers: [
          {
            key: 'x-slug',
            value: ':slug', // Matched parameters can be used in the value
          },
          {
            key: 'x-slug-:slug', // Matched parameters can be used in the key
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

Example 4 (unknown):
```unknown
module.exports = {
  async headers() {
    return [
      {
        source: '/blog/:slug*',
        headers: [
          {
            key: 'x-slug',
            value: ':slug*', // Matched parameters can be used in the value
          },
          {
            key: 'x-slug-:slug*', // Matched parameters can be used in the key
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

---

## How to optimize package bundling

**URL:** https://nextjs.org/docs/app/guides/package-bundling

**Contents:**
- How to optimize package bundling
- Analyzing JavaScript bundles
  - Installation
  - Generating a report
- Optimizing package imports
- Opting specific packages out of bundling
- Next Steps
  - Production

Bundling external packages can significantly improve the performance of your application. By default, packages imported inside Server Components and Route Handlers are automatically bundled by Next.js. This page will guide you through how to analyze and further optimize package bundling.

@next/bundle-analyzer is a plugin for Next.js that helps you manage the size of your application bundles. It generates a visual report of the size of each package and their dependencies. You can use the information to remove large dependencies, split, or lazy-load your code.

Install the plugin by running the following command:

Then, add the bundle analyzer's settings to your next.config.js.

Run the following command to analyze your bundles:

The report will open three new tabs in your browser, which you can inspect. Periodically evaluating your application's bundles can help you maintain application performance over time.

Some packages, such as icon libraries, can export hundreds of modules, which can cause performance issues in development and production.

You can optimize how these packages are imported by adding the optimizePackageImports option to your next.config.js. This option will only load the modules you actually use, while still giving you the convenience of writing import statements with many named exports.

Next.js also optimizes some libraries automatically, thus they do not need to be included in the optimizePackageImports list. See the full list.

Since packages imported inside Server Components and Route Handlers are automatically bundled by Next.js, you can opt specific packages out of bundling using the serverExternalPackages option in your next.config.js.

Next.js includes a list of popular packages that currently are working on compatibility and automatically opt-ed out. See the full list.

**Examples:**

Example 1 (unknown):
```unknown
npm i @next/bundle-analyzer
# or
yarn add @next/bundle-analyzer
# or
pnpm add @next/bundle-analyzer
```

Example 2 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {}
 
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})
 
module.exports = withBundleAnalyzer(nextConfig)
```

Example 3 (unknown):
```unknown
ANALYZE=true npm run build
# or
ANALYZE=true yarn build
# or
ANALYZE=true pnpm build
```

Example 4 (javascript):
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    optimizePackageImports: ['icon-library'],
  },
}
 
module.exports = nextConfig
```

---

## getStaticProps

**URL:** https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props

**Contents:**
- getStaticProps
- When should I use getStaticProps?
- When does getStaticProps run
- Using getStaticProps to fetch data from a CMS
- Write server-side code directly
- Statically generates both HTML and JSON
- Where can I use getStaticProps
- Runs on every request in development
- Preview Mode

If you export a function called getStaticProps (Static Site Generation) from a page, Next.js will pre-render this page at build time using the props returned by getStaticProps.

Note that irrespective of rendering type, any props will be passed to the page component and can be viewed on the client-side in the initial HTML. This is to allow the page to be hydrated correctly. Make sure that you don't pass any sensitive information that shouldn't be available on the client in props.

The getStaticProps API reference covers all parameters and props that can be used with getStaticProps.

You should use getStaticProps if:

getStaticProps always runs on the server and never on the client. You can validate code written inside getStaticProps is removed from the client-side bundle with this tool.

When combined with Incremental Static Regeneration, getStaticProps will run in the background while the stale page is being revalidated, and the fresh page served to the browser.

getStaticProps does not have access to the incoming request (such as query parameters or HTTP headers) as it generates static HTML. If you need access to the request for your page, consider using Proxy in addition to getStaticProps.

The following example shows how you can fetch a list of blog posts from a CMS.

The getStaticProps API reference covers all parameters and props that can be used with getStaticProps.

As getStaticProps runs only on the server-side, it will never run on the client-side. It wonâ€™t even be included in the JS bundle for the browser, so you can write direct database queries without them being sent to browsers.

This means that instead of fetching an API route from getStaticProps (that itself fetches data from an external source), you can write the server-side code directly in getStaticProps.

Take the following example. An API route is used to fetch some data from a CMS. That API route is then called directly from getStaticProps. This produces an additional call, reducing performance. Instead, the logic for fetching the data from the CMS can be shared by using a lib/ directory. Then it can be shared with getStaticProps.

Alternatively, if you are not using API routes to fetch data, then the fetch() API can be used directly in getStaticProps to fetch data.

To verify what Next.js eliminates from the client-side bundle, you can use the next-code-elimination tool.

When a page with getStaticProps is pre-rendered at build time, in addition to the page HTML file, Next.js generates a JSON file holding the result of running getStaticProps.

This JSON file will be used in client-side routing through next/link or next/router. When you navigate to a page thatâ€™s pre-rendered using getStaticProps, Next.js fetches this JSON file (pre-computed at build time) and uses it as the props for the page component. This means that client-side page transitions will not call getStaticProps as only the exported JSON is used.

When using Incremental Static Generation, getStaticProps will be executed in the background to generate the JSON needed for client-side navigation. You may see this in the form of multiple requests being made for the same page, however, this is intended and has no impact on end-user performance.

getStaticProps can only be exported from a page. You cannot export it from non-page files, _app, _document, or _error.

One of the reasons for this restriction is that React needs to have all the required data before the page is rendered.

Also, you must use export getStaticProps as a standalone function â€” it will not work if you add getStaticProps as a property of the page component.

Good to know: if you have created a custom app, ensure you are passing the pageProps to the page component as shown in the linked document, otherwise the props will be empty.

In development (next dev), getStaticProps will be called on every request.

You can temporarily bypass static generation and render the page at request time instead of build time using Preview Mode. For example, you might be using a headless CMS and want to preview drafts before they're published.

**Examples:**

Example 1 (python):
```python
import type { InferGetStaticPropsType, GetStaticProps } from 'next'
 
type Repo = {
  name: string
  stargazers_count: number
}
 
export const getStaticProps = (async (context) => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo = await res.json()
  return { props: { repo } }
}) satisfies GetStaticProps<{
  repo: Repo
}>
 
export default function Page({
  repo,
}: InferGetStaticPropsType<typeof getStaticProps>) {
  return repo.stargazers_count
}
```

Example 2 (javascript):
```javascript
// posts will be populated at build time by getStaticProps()
export default function Blog({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li>{post.title}</li>
      ))}
    </ul>
  )
}
 
// This function gets called at build time on server-side.
// It won't be called on client-side, so you can even do
// direct database queries.
export async function getStaticProps() {
  // Call an external API endpoint to get posts.
  // You can use any data fetching library
  const res = await fetch('https://.../posts')
  const posts = await res.json()
 
  // By returning { props: { posts } }, the Blog component
  // will receive `posts` as a prop at build time
  return {
    props: {
      posts,
    },
  }
}
```

Example 3 (javascript):
```javascript
// The following function is shared
// with getStaticProps and API routes
// from a `lib/` directory
export async function loadPosts() {
  // Call an external API endpoint to get posts
  const res = await fetch('https://.../posts/')
  const data = await res.json()
 
  return data
}
```

Example 4 (python):
```python
// pages/blog.js
import { loadPosts } from '../lib/load-posts'
 
// This function runs only on the server side
export async function getStaticProps() {
  // Instead of fetching your `/api` route you can call the same
  // function directly in `getStaticProps`
  const posts = await loadPosts()
 
  // Props returned will be passed to the page component
  return { props: { posts } }
}
```

---

## How to set up instrumentation

**URL:** https://nextjs.org/docs/pages/guides/instrumentation

**Contents:**
- How to set up instrumentation
- Convention
- Examples
  - Importing files with side effects
  - Importing runtime-specific code

Instrumentation is the process of using code to integrate monitoring and logging tools into your application. This allows you to track the performance and behavior of your application, and to debug issues in production.

To set up instrumentation, create instrumentation.ts|js file in the root directory of your project (or inside the src folder if using one).

Then, export a register function in the file. This function will be called once when a new Next.js server instance is initiated.

For example, to use Next.js with OpenTelemetry and @vercel/otel:

See the Next.js with OpenTelemetry example for a complete implementation.

Sometimes, it may be useful to import a file in your code because of the side effects it will cause. For example, you might import a file that defines a set of global variables, but never explicitly use the imported file in your code. You would still have access to the global variables the package has declared.

We recommend importing files using JavaScript import syntax within your register function. The following example demonstrates a basic usage of import in a register function:

We recommend importing the file from within the register function, rather than at the top of the file. By doing this, you can colocate all of your side effects in one place in your code, and avoid any unintended consequences from importing globally at the top of the file.

Next.js calls register in all environments, so it's important to conditionally import any code that doesn't support specific runtimes (e.g. Edge or Node.js). You can use the NEXT_RUNTIME environment variable to get the current environment:

**Examples:**

Example 1 (python):
```python
import { registerOTel } from '@vercel/otel'
 
export function register() {
  registerOTel('next-app')
}
```

Example 2 (unknown):
```unknown
export async function register() {
  await import('package-with-side-effect')
}
```

Example 3 (unknown):
```unknown
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./instrumentation-node')
  }
 
  if (process.env.NEXT_RUNTIME === 'edge') {
    await import('./instrumentation-edge')
  }
}
```

---

## How to use Next.js as a backend for your frontend

**URL:** https://nextjs.org/docs/app/guides/backend-for-frontend

**Contents:**
- How to use Next.js as a backend for your frontend
- Public Endpoints
- Content types
  - Consuming request payloads
- Manipulating data
- Proxying to a backend
- NextRequest and NextResponse
- Webhooks and callback URLs
- Redirects
- Proxy

Next.js supports the "Backend for Frontend" pattern. This lets you create public endpoints to handle HTTP requests and return any content typeâ€”not just HTML. You can also access data sources and perform side effects like updating remote data.

If you are starting a new project, using create-next-app with the --api flag automatically includes an example route.ts in your new projectâ€™s app/ folder, demonstrating how to create an API endpoint.

Good to know: Next.js backend capabilities are not a full backend replacement. They serve as an API layer that:

To implement this pattern, use:

Route Handlers are public HTTP endpoints. Any client can access them.

Create a Route Handler using the route.ts or route.js file convention:

This handles GET requests sent to /api.

Use try/catch blocks for operations that may throw an exception:

Avoid exposing sensitive information in error messages sent to the client.

To restrict access, implement authentication and authorization. See Authentication.

Route Handlers let you serve non-UI responses, including JSON, XML, images, files, and plain text.

Next.js uses file conventions for common endpoints:

You can also define custom ones, such as:

For example, app/rss.xml/route.ts creates a Route Handler for rss.xml.

Sanitize any input used to generate markup.

Use Request instance methods like .json(), .formData(), or .text() to access the request body.

GET and HEAD requests donâ€™t carry a body.

Good to know: Validate data before passing it to other systems

You can only read the request body once. Clone the request if you need to read it again:

Route Handlers can transform, filter, and aggregate data from one or more sources. This keeps logic out of the frontend and avoids exposing internal systems.

You can also offload heavy computations to the server and reduce client battery and data usage.

Good to know: This example uses POST to avoid putting geo-location data in the URL. GET requests may be cached or logged, which could expose sensitive info.

You can use a Route Handler as a proxy to another backend. Add validation logic before forwarding the request.

Next.js extends the Request and Response Web APIs with methods that simplify common operations. These extensions are available in both Route Handlers and Proxy.

Both provide methods for reading and manipulating cookies.

NextRequest includes the nextUrl property, which exposes parsed values from the incoming request, for example, it makes it easier to access request pathname and search params.

NextResponse provides helpers like next(), json(), redirect(), and rewrite().

You can pass NextRequest to any function expecting Request. Likewise, you can return NextResponse where a Response is expected.

Learn more about NextRequest and NextResponse.

Use Route Handlers to receive event notifications from third-party applications.

For example, revalidate a route when content changes in a CMS. Configure the CMS to call a specific endpoint on changes.

Callback URLs are another use case. When a user completes a third-party flow, the third party sends them to a callback URL. Use a Route Handler to verify the response and decide where to redirect the user.

Learn more about redirects in redirect and permanentRedirect

Only one proxy file is allowed per project. Use config.matcher to target specific paths. Learn more about proxy.

Use proxy to generate a response before the request reaches a route path.

You can also proxy requests using proxy:

Another type of response proxy can produce are redirects:

Be deliberate about where headers go, and avoid directly passing incoming request headers to the outgoing response.

Learn more in NextResponse headers in Proxy.

You can implement rate limiting in your Next.js backend. In addition to code-based checks, enable any rate limiting features provided by your host.

Never trust incoming request data. Validate content type and size, and sanitize against XSS before use.

Use timeouts to prevent abuse and protect server resources.

Store user-generated static assets in dedicated services. When possible, upload them from the browser and store the returned URI in your database to reduce request size.

Always verify credentials before granting access. Do not rely on proxy alone for authentication and authorization.

Remove sensitive or unnecessary data from responses and backend logs.

Rotate credentials and API keys regularly.

Preflight requests use the OPTIONS method to ask the server if a request is allowed based on origin, method, and headers.

If OPTIONS is not defined, Next.js adds it automatically and sets the Allow header based on the other defined methods.

Community libraries often use the factory pattern for Route Handlers.

This creates a shared handler for GET and POST requests. The library customizes behavior based on the method and pathname in the request.

Libraries can also provide a proxy factory.

Good to know: Third-party libraries may still refer to proxy as middleware.

See more examples on using Router Handlers and the proxy API references.

These examples include, working with Cookies, Headers, Streaming, Proxy negative matching, and other useful code snippets.

Fetch data in Server Components directly from its source, not via Route Handlers.

For Server Components pre-rendered at build time, using Route Handlers will fail the build step. This is because, while building there is no server listening for these requests.

For Server Components rendered on demand, fetching from Route Handlers is slower due to the extra HTTP round trip between the handler and the render process.

A server side fetch request uses absolute URLs. This implies an HTTP round trip, to an external server. During development, your own development server acts as the external server. At build time there is no server, and at runtime, the server is available through your public facing domain.

Server Components cover most data-fetching needs. However, fetching data client side might be necessary for:

For these, use community libraries like swr or react-query.

Server Actions let you run server-side code from the client. Their primary purpose is to mutate data from your frontend client.

Server Actions are queued. Using them for data fetching introduces sequential execution.

export mode outputs a static site without a runtime server. Features that require the Next.js runtime are not supported, because this mode produces a static site, and no runtime server.

In export mode, only GET Route Handlers are supported, in combination with the dynamic route segment config, set to 'force-static'.

This can be used to generate static HTML, JSON, TXT, or other files.

Some hosts deploy Route Handlers as lambda functions. This means:

**Examples:**

Example 1 (unknown):
```unknown
npx create-next-app@latest --api
```

Example 2 (unknown):
```unknown
export function GET(request: Request) {}
```

Example 3 (python):
```python
import { submit } from '@/lib/submit'
 
export async function POST(request: Request) {
  try {
    await submit(request)
    return new Response(null, { status: 204 })
  } catch (reason) {
    const message =
      reason instanceof Error ? reason.message : 'Unexpected error'
 
    return new Response(message, { status: 500 })
  }
}
```

Example 4 (javascript):
```javascript
export async function GET(request: Request) {
  const rssResponse = await fetch(/* rss endpoint */)
  const rssData = await rssResponse.json()
 
  const rssFeed = `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
 <title>${rssData.title}</title>
 <description>${rssData.description}</description>
 <link>${rssData.link}</link>
 <copyright>${rssData.copyright}</copyright>
 ${rssData.items.map((item) => {
   return `<item>
    <title>${item.title}</title>
    <description>${item.description}</description>
    <link>${item.link}</link>
    <pubDate>${item.publishDate}</pubDate>
    <guid isPermaLink="false">${item.guid}</guid>
 </item>`
 })}
</channel>
</rss>`
 
  const headers = new Headers({ 'content-type': 'application/xml' })
 
  return new Response(rssFeed, { headers })
}
```

---

## No Document Import in Page

**URL:** https://nextjs.org/docs/messages/no-document-import-in-page

**Contents:**
- No Document Import in Page
- Why This Error Occurred
- Possible Ways to Fix It
- Useful Links

Prevent importing next/document outside of pages/_document.js.

next/document was imported in a page outside of pages/_document.js (or pages/_document.tsx if you are using TypeScript). This can cause unexpected issues in your application.

Only import and use next/document within pages/_document.js (or pages/_document.tsx) to override the default Document component:

**Examples:**

Example 1 (python):
```python
import Document, { Html, Head, Main, NextScript } from 'next/document'
 
class MyDocument extends Document {
  //...
}
 
export default MyDocument
```

---

## basePath

**URL:** https://nextjs.org/docs/app/api-reference/config/next-config-js/basePath

**Contents:**
- basePath
  - Links
  - Images

To deploy a Next.js application under a sub-path of a domain you can use the basePath config option.

basePath allows you to set a path prefix for the application. For example, to use /docs instead of '' (an empty string, the default), open next.config.js and add the basePath config:

Good to know: This value must be set at build time and cannot be changed without re-building as the value is inlined in the client-side bundles.

When linking to other pages using next/link and next/router the basePath will be automatically applied.

For example, using /about will automatically become /docs/about when basePath is set to /docs.

This makes sure that you don't have to change all links in your application when changing the basePath value.

When using the next/image component, you will need to add the basePath in front of src.

For example, using /docs/me.png will properly serve your image when basePath is set to /docs.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  basePath: '/docs',
}
```

Example 2 (unknown):
```unknown
export default function HomePage() {
  return (
    <>
      <Link href="/about">About Page</Link>
    </>
  )
}
```

Example 3 (unknown):
```unknown
<a href="/docs/about">About Page</a>
```

Example 4 (python):
```python
import Image from 'next/image'
 
function Home() {
  return (
    <>
      <h1>My Homepage</h1>
      <Image
        src="/docs/me.png"
        alt="Picture of the author"
        width={500}
        height={500}
      />
      <p>Welcome to my homepage!</p>
    </>
  )
}
 
export default Home
```

---

## How to migrate from Pages to the App Router

**URL:** https://nextjs.org/docs/app/guides/migrating/app-router-migration

**Contents:**
- How to migrate from Pages to the App Router
- Upgrading
  - Node.js Version
  - Next.js Version
  - ESLint Version
- Next Steps
- Upgrading New Features
  - <Image/> Component
  - <Link> Component
  - <Script> Component

This guide will help you:

The minimum Node.js version is now v18.17. See the Node.js documentation for more information.

To update to Next.js version 13, run the following command using your preferred package manager:

If you're using ESLint, you need to upgrade your ESLint version:

Good to know: You may need to restart the ESLint server in VS Code for the ESLint changes to take effect. Open the Command Palette (cmd+shift+p on Mac; ctrl+shift+p on Windows) and search for ESLint: Restart ESLint Server.

After you've updated, see the following sections for next steps:

Next.js 13 introduced the new App Router with new features and conventions. The new Router is available in the app directory and co-exists with the pages directory.

Upgrading to Next.js 13 does not require using the App Router. You can continue using pages with new features that work in both directories, such as the updated Image component, Link component, Script component, and Font optimization.

Next.js 12 introduced new improvements to the Image Component with a temporary import: next/future/image. These improvements included less client-side JavaScript, easier ways to extend and style images, better accessibility, and native browser lazy loading.

In version 13, this new behavior is now the default for next/image.

There are two codemods to help you migrate to the new Image Component:

The <Link> Component no longer requires manually adding an <a> tag as a child. This behavior was added as an experimental option in version 12.2 and is now the default. In Next.js 13, <Link> always renders <a> and allows you to forward props to the underlying tag.

To upgrade your links to Next.js 13, you can use the new-link codemod.

The behavior of next/script has been updated to support both pages and app, but some changes need to be made to ensure a smooth migration:

Previously, Next.js helped you optimize fonts by inlining font CSS. Version 13 introduces the new next/font module which gives you the ability to customize your font loading experience while still ensuring great performance and privacy. next/font is supported in both the pages and app directories.

While inlining CSS still works in pages, it does not work in app. You should use next/font instead.

See the Font Optimization page to learn how to use next/font.

ðŸŽ¥ Watch: Learn how to incrementally adopt the App Router â†’ YouTube (16 minutes).

Moving to the App Router may be the first time using React features that Next.js builds on top of such as Server Components, Suspense, and more. When combined with new Next.js features such as special files and layouts, migration means new concepts, mental models, and behavioral changes to learn.

We recommend reducing the combined complexity of these updates by breaking down your migration into smaller steps. The app directory is intentionally designed to work simultaneously with the pages directory to allow for incremental page-by-page migration.

Update to the latest Next.js version (requires 13.4 or greater):

Then, create a new app directory at the root of your project (or src/ directory).

Create a new app/layout.tsx file inside the app directory. This is a root layout that will apply to all routes inside app.

To manage <head> HTML elements, you can use the built-in SEO support:

If you have an existing _app or _document file, you can copy the contents (e.g. global styles) to the root layout (app/layout.tsx). Styles in app/layout.tsx will not apply to pages/*. You should keep _app/_document while migrating to prevent your pages/* routes from breaking. Once fully migrated, you can then safely delete them.

If you are using any React Context providers, they will need to be moved to a Client Component.

Next.js recommended adding a property to Page components to achieve per-page layouts in the pages directory. This pattern can be replaced with native support for nested layouts in the app directory.

Remove the Page.getLayout property from pages/dashboard/index.js and follow the steps for migrating pages to the app directory.

Move the contents of DashboardLayout into a new Client Component to retain pages directory behavior.

Import the DashboardLayout into a new layout.js file inside the app directory.

You can incrementally move non-interactive parts of DashboardLayout.js (Client Component) into layout.js (Server Component) to reduce the amount of component JavaScript you send to the client.

In the pages directory, the next/head React component is used to manage <head> HTML elements such as title and meta . In the app directory, next/head is replaced with the new built-in SEO support.

See all metadata options.

We recommend breaking down the migration of a page into two main steps:

Good to know: This is the easiest migration path because it has the most comparable behavior to the pages directory.

Step 1: Create a new Client Component

Step 2: Create a new page

Create a new app/page.tsx file inside the app directory. This is a Server Component by default.

Import the home-page.tsx Client Component into the page.

If you were fetching data in pages/index.js, move the data fetching logic directly into the Server Component using the new data fetching APIs. See the data fetching upgrade guide for more details.

If your previous page used useRouter, you'll need to update to the new routing hooks. Learn more.

Start your development server and visit http://localhost:3000. You should see your existing index route, now served through the app directory.

A new router has been added to support the new behavior in the app directory.

In app, you should use the three new hooks imported from next/navigation: useRouter(), usePathname(), and useSearchParams().

In addition, the new useRouter hook has the following changes:

View the useRouter() API reference.

To keep components compatible between the pages and app routers, refer to the useRouter hook from next/compat/router. This is the useRouter hook from the pages directory, but intended to be used while sharing components between routers. Once you are ready to use it only on the app router, update to the new useRouter from next/navigation.

The pages directory uses getServerSideProps and getStaticProps to fetch data for pages. Inside the app directory, these previous data fetching functions are replaced with a simpler API built on top of fetch() and async React Server Components.

In the pages directory, getServerSideProps is used to fetch data on the server and forward props to the default exported React component in the file. The initial HTML for the page is prerendered from the server, followed by "hydrating" the page in the browser (making it interactive).

In the App Router, we can colocate our data fetching inside our React components using Server Components. This allows us to send less JavaScript to the client, while maintaining the rendered HTML from the server.

By setting the cache option to no-store, we can indicate that the fetched data should never be cached. This is similar to getServerSideProps in the pages directory.

In the pages directory, you can retrieve request-based data based on the Node.js HTTP API.

For example, you can retrieve the req object from getServerSideProps and use it to retrieve the request's cookies and headers.

The app directory exposes new read-only functions to retrieve request data:

In the pages directory, the getStaticProps function is used to pre-render a page at build time. This function can be used to fetch data from an external API or directly from a database, and pass this data down to the entire page as it's being generated during the build.

In the app directory, data fetching with fetch() will default to cache: 'force-cache', which will cache the request data until manually invalidated. This is similar to getStaticProps in the pages directory.

In the pages directory, the getStaticPaths function is used to define the dynamic paths that should be pre-rendered at build time.

In the app directory, getStaticPaths is replaced with generateStaticParams.

generateStaticParams behaves similarly to getStaticPaths, but has a simplified API for returning route parameters and can be used inside layouts. The return shape of generateStaticParams is an array of segments instead of an array of nested param objects or a string of resolved paths.

Using the name generateStaticParams is more appropriate than getStaticPaths for the new model in the app directory. The get prefix is replaced with a more descriptive generate, which sits better alone now that getStaticProps and getServerSideProps are no longer necessary. The Paths suffix is replaced by Params, which is more appropriate for nested routing with multiple dynamic segments.

In the pages directory, the fallback property returned from getStaticPaths is used to define the behavior of a page that isn't pre-rendered at build time. This property can be set to true to show a fallback page while the page is being generated, false to show a 404 page, or blocking to generate the page at request time.

In the app directory the config.dynamicParams property controls how params outside of generateStaticParams are handled:

This replaces the fallback: true | false | 'blocking' option of getStaticPaths in the pages directory. The fallback: 'blocking' option is not included in dynamicParams because the difference between 'blocking' and true is negligible with streaming.

With dynamicParams set to true (the default), when a route segment is requested that hasn't been generated, it will be server-rendered and cached.

In the pages directory, the getStaticProps function allows you to add a revalidate field to automatically regenerate a page after a certain amount of time.

In the app directory, data fetching with fetch() can use revalidate, which will cache the request for the specified amount of seconds.

API Routes continue to work in the pages/api directory without any changes. However, they have been replaced by Route Handlers in the app directory.

Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.

Good to know: If you previously used API routes to call an external API from the client, you can now use Server Components instead to securely fetch data. Learn more about data fetching.

If you are also migrating to Next.js from a Single-Page Application (SPA) at the same time, see our documentation to learn more.

In the pages directory, global stylesheets are restricted to only pages/_app.js. With the app directory, this restriction has been lifted. Global styles can be added to any layout, page, or component.

If you're using Tailwind CSS, you'll need to add the app directory to your tailwind.config.js file:

You'll also need to import your global styles in your app/layout.js file:

Learn more about styling with Tailwind CSS

When navigating between routes served by the different Next.js routers, there will be a hard navigation. Automatic link prefetching with next/link will not prefetch across routers.

Instead, you can optimize navigations between App Router and Pages Router to retain the prefetched and fast page transitions. Learn more.

Next.js provides Codemod transformations to help upgrade your codebase when a feature is deprecated. See Codemods for more information.

**Examples:**

Example 1 (unknown):
```unknown
npm install next@latest react@latest react-dom@latest
```

Example 2 (unknown):
```unknown
npm install -D eslint-config-next@latest
```

Example 3 (python):
```python
import Link from 'next/link'
 
// Next.js 12: `<a>` has to be nested otherwise it's excluded
<Link href="/about">
  <a>About</a>
</Link>
 
// Next.js 13: `<Link>` always renders `<a>` under the hood
<Link href="/about">
  About
</Link>
```

Example 4 (unknown):
```unknown
npm install next@latest
```

---

## NextRequest

**URL:** https://nextjs.org/docs/app/api-reference/functions/next-request

**Contents:**
- NextRequest
- cookies
  - set(name, value)
  - get(name)
  - getAll()
  - delete(name)
  - has(name)
  - clear()
- nextUrl
- Version History

NextRequest extends the Web Request API with additional convenience methods.

Read or mutate the Set-Cookie header of the request.

Given a name, set a cookie with the given value on the request.

Given a cookie name, return the value of the cookie. If the cookie is not found, undefined is returned. If multiple cookies are found, the first one is returned.

Given a cookie name, return the values of the cookie. If no name is given, return all cookies on the request.

Given a cookie name, delete the cookie from the request.

Given a cookie name, return true if the cookie exists on the request.

Remove the Set-Cookie header from the request.

Extends the native URL API with additional convenience methods, including Next.js specific properties.

The following options are available:

Note: The internationalization properties from the Pages Router are not available for usage in the App Router. Learn more about internationalization with the App Router.

**Examples:**

Example 1 (unknown):
```unknown
// Given incoming request /home
// Set a cookie to hide the banner
// request will have a `Set-Cookie:show-banner=false;path=/home` header
request.cookies.set('show-banner', 'false')
```

Example 2 (unknown):
```unknown
// Given incoming request /home
// { name: 'show-banner', value: 'false', Path: '/home' }
request.cookies.get('show-banner')
```

Example 3 (unknown):
```unknown
// Given incoming request /home
// [
//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },
//   { name: 'experiments', value: 'winter-launch', Path: '/home' },
// ]
request.cookies.getAll('experiments')
// Alternatively, get all cookies for the request
request.cookies.getAll()
```

Example 4 (unknown):
```unknown
// Returns true for deleted, false is nothing is deleted
request.cookies.delete('experiments')
```

---

## instrumentation.js

**URL:** https://nextjs.org/docs/pages/api-reference/file-conventions/instrumentation

**Contents:**
- instrumentation.js
- Exports
  - register (optional)
  - onRequestError (optional)
    - Parameters
  - Specifying the runtime
- Version History

The instrumentation.js|ts file is used to integrate observability tools into your application, allowing you to track the performance and behavior, and to debug issues in production.

To use it, place the file in the root of your application or inside a src folder if using one.

The file exports a register function that is called once when a new Next.js server instance is initiated. register can be an async function.

You can optionally export an onRequestError function to track server errors to any custom observability provider.

The function accepts three parameters: error, request, and context.

The instrumentation.js file works in both the Node.js and Edge runtime, however, you can use process.env.NEXT_RUNTIME to target a specific runtime.

**Examples:**

Example 1 (python):
```python
import { registerOTel } from '@vercel/otel'
 
export function register() {
  registerOTel('next-app')
}
```

Example 2 (python):
```python
import { type Instrumentation } from 'next'
 
export const onRequestError: Instrumentation.onRequestError = async (
  err,
  request,
  context
) => {
  await fetch('https://.../report-error', {
    method: 'POST',
    body: JSON.stringify({
      message: err.message,
      request,
      context,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  })
}
```

Example 3 (unknown):
```unknown
export function onRequestError(
  error: { digest: string } & Error,
  request: {
    path: string // resource path, e.g. /blog?name=foo
    method: string // request method. e.g. GET, POST, etc
    headers: { [key: string]: string | string[] }
  },
  context: {
    routerKind: 'Pages Router' | 'App Router' // the router type
    routePath: string // the route file path, e.g. /app/blog/[dynamic]
    routeType: 'render' | 'route' | 'action' | 'proxy' // the context in which the error occurred
    renderSource:
      | 'react-server-components'
      | 'react-server-components-payload'
      | 'server-rendering'
    revalidateReason: 'on-demand' | 'stale' | undefined // undefined is a normal request without revalidation
    renderType: 'dynamic' | 'dynamic-resume' // 'dynamic-resume' for PPR
  }
): void | Promise<void>
```

Example 4 (unknown):
```unknown
export function register() {
  if (process.env.NEXT_RUNTIME === 'edge') {
    return require('./register.edge')
  } else {
    return require('./register.node')
  }
}
 
export function onRequestError() {
  if (process.env.NEXT_RUNTIME === 'edge') {
    return require('./on-request-error.edge')
  } else {
    return require('./on-request-error.node')
  }
}
```

---

## Upgrading

**URL:** https://nextjs.org/docs/pages/guides/upgrading

**Contents:**
- Upgrading
  - Codemods
  - Version 10
  - Version 11
  - Version 12
  - Version 13
  - Version 14
  - Version 9

Learn how to upgrade to the latest versions of Next.js following the versions-specific guides:

---

## userAgent

**URL:** https://nextjs.org/docs/app/api-reference/functions/userAgent

**Contents:**
- userAgent
- isBot
- browser
- device
- engine
- os
- cpu

The userAgent helper extends the Web Request API with additional properties and methods to interact with the user agent object from the request.

A boolean indicating whether the request comes from a known bot.

An object containing information about the browser used in the request.

An object containing information about the device used in the request.

An object containing information about the browser's engine.

An object containing information about the operating system.

An object containing information about the CPU architecture.

**Examples:**

Example 1 (python):
```python
import { NextRequest, NextResponse, userAgent } from 'next/server'
 
export function proxy(request: NextRequest) {
  const url = request.nextUrl
  const { device } = userAgent(request)
 
  // device.type can be: 'mobile', 'tablet', 'console', 'smarttv',
  // 'wearable', 'embedded', or undefined (for desktop browsers)
  const viewport = device.type || 'desktop'
 
  url.searchParams.set('viewport', viewport)
  return NextResponse.rewrite(url)
}
```

---

## How to upgrade to version 10

**URL:** https://nextjs.org/docs/pages/guides/upgrading/version-10

**Contents:**
- How to upgrade to version 10

There were no breaking changes between versions 9 and 10.

To upgrade to version 10, run the following command:

Good to know: If you are using TypeScript, ensure you also upgrade @types/react and @types/react-dom to their corresponding versions.

**Examples:**

Example 1 (unknown):
```unknown
npm i next@10
```

Example 2 (unknown):
```unknown
yarn add next@10
```

Example 3 (unknown):
```unknown
pnpm up next@10
```

Example 4 (unknown):
```unknown
bun add next@10
```

---

## public Folder

**URL:** https://nextjs.org/docs/pages/api-reference/file-conventions/public-folder

**Contents:**
- public Folder
- Caching
- Robots, Favicons, and others

Next.js can serve static files, like images, under a folder called public in the root directory. Files inside public can then be referenced by your code starting from the base URL (/).

For example, the file public/avatars/me.png can be viewed by visiting the /avatars/me.png path. The code to display that image might look like:

Next.js cannot safely cache assets in the public folder because they may change. The default caching headers applied are:

The folder is also useful for robots.txt, favicon.ico, Google Site Verification, and any other static files (including .html). But make sure to not have a static file with the same name as a file in the pages/ directory, as this will result in an error. Read more.

**Examples:**

Example 1 (python):
```python
import Image from 'next/image'
 
export function Avatar({ id, alt }) {
  return <Image src={`/avatars/${id}.png`} alt={alt} width="64" height="64" />
}
 
export function AvatarOfMe() {
  return <Avatar id="me" alt="A portrait of me" />
}
```

Example 2 (unknown):
```unknown
Cache-Control: public, max-age=0
```

---

## How to lazy load Client Components and libraries

**URL:** https://nextjs.org/docs/app/guides/lazy-loading

**Contents:**
- How to lazy load Client Components and libraries
- next/dynamic
- Examples
  - Importing Client Components
  - Skipping SSR
  - Importing Server Components
  - Loading External Libraries
  - Adding a custom loading component
  - Importing Named Exports

Lazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route.

It allows you to defer loading of Client Components and imported libraries, and only include them in the client bundle when they're needed. For example, you might want to defer loading a modal until a user clicks to open it.

There are two ways you can implement lazy loading in Next.js:

By default, Server Components are automatically code split, and you can use streaming to progressively send pieces of UI from the server to the client. Lazy loading applies to Client Components.

next/dynamic is a composite of React.lazy() and Suspense. It behaves the same way in the app and pages directories to allow for incremental migration.

Note: When a Server Component dynamically imports a Client Component, automatic code splitting is currently not supported.

When using React.lazy() and Suspense, Client Components will be prerendered (SSR) by default.

Note: ssr: false option will only work for Client Components, move it into Client Components ensure the client code-splitting working properly.

If you want to disable pre-rendering for a Client Component, you can use the ssr option set to false:

If you dynamically import a Server Component, only the Client Components that are children of the Server Component will be lazy-loaded - not the Server Component itself. It will also help preload the static assets such as CSS when you're using it in Server Components.

Note: ssr: false option is not supported in Server Components. You will see an error if you try to use it in Server Components. ssr: false is not allowed with next/dynamic in Server Components. Please move it into a Client Component.

External libraries can be loaded on demand using the import() function. This example uses the external library fuse.js for fuzzy search. The module is only loaded on the client after the user types in the search input.

To dynamically import a named export, you can return it from the Promise returned by import() function:

**Examples:**

Example 1 (python):
```python
'use client'
 
import { useState } from 'react'
import dynamic from 'next/dynamic'
 
// Client Components:
const ComponentA = dynamic(() => import('../components/A'))
const ComponentB = dynamic(() => import('../components/B'))
const ComponentC = dynamic(() => import('../components/C'), { ssr: false })
 
export default function ClientComponentExample() {
  const [showMore, setShowMore] = useState(false)
 
  return (
    <div>
      {/* Load immediately, but in a separate client bundle */}
      <ComponentA />
 
      {/* Load on demand, only when/if the condition is met */}
      {showMore && <ComponentB />}
      <button onClick={() => setShowMore(!showMore)}>Toggle</button>
 
      {/* Load only on the client side */}
      <ComponentC />
    </div>
  )
}
```

Example 2 (javascript):
```javascript
const ComponentC = dynamic(() => import('../components/C'), { ssr: false })
```

Example 3 (python):
```python
import dynamic from 'next/dynamic'
 
// Server Component:
const ServerComponent = dynamic(() => import('../components/ServerComponent'))
 
export default function ServerComponentExample() {
  return (
    <div>
      <ServerComponent />
    </div>
  )
}
```

Example 4 (python):
```python
'use client'
 
import { useState } from 'react'
 
const names = ['Tim', 'Joe', 'Bel', 'Lee']
 
export default function Page() {
  const [results, setResults] = useState()
 
  return (
    <div>
      <input
        type="text"
        placeholder="Search"
        onChange={async (e) => {
          const { value } = e.currentTarget
          // Dynamically load fuse.js
          const Fuse = (await import('fuse.js')).default
          const fuse = new Fuse(names)
 
          setResults(fuse.search(value))
        }}
      />
      <pre>Results: {JSON.stringify(results, null, 2)}</pre>
    </div>
  )
}
```

---

## reactStrictMode

**URL:** https://nextjs.org/docs/pages/api-reference/config/next-config-js/reactStrictMode

**Contents:**
- reactStrictMode

Good to know: Since Next.js 13.5.1, Strict Mode is true by default with app router, so the above configuration is only necessary for pages. You can still disable Strict Mode by setting reactStrictMode: false.

Suggested: We strongly suggest you enable Strict Mode in your Next.js application to better prepare your application for the future of React.

React's Strict Mode is a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe lifecycles, legacy API usage, and a number of other features.

The Next.js runtime is Strict Mode-compliant. To opt-in to Strict Mode, configure the following option in your next.config.js:

If you or your team are not ready to use Strict Mode in your entire application, that's OK! You can incrementally migrate on a page-by-page basis using <React.StrictMode>.

**Examples:**

Example 1 (unknown):
```unknown
module.exports = {
  reactStrictMode: true,
}
```

---

## unauthorized

**URL:** https://nextjs.org/docs/app/api-reference/functions/unauthorized

**Contents:**
- unauthorized
- Good to know
- Examples
  - Displaying login UI to unauthenticated users
  - Mutations with Server Actions
  - Fetching data with Route Handlers
- Version History
- Next Steps
  - unauthorized.js

The unauthorized function throws an error that renders a Next.js 401 error page. It's useful for handling authorization errors in your application. You can customize the UI using the unauthorized.js file.

To start using unauthorized, enable the experimental authInterrupts configuration option in your next.config.js file:

unauthorized can be invoked in Server Components, Server Actions, and Route Handlers.

You can use unauthorized function to display the unauthorized.js file with a login UI.

You can invoke unauthorized in Server Actions to ensure only authenticated users can perform specific mutations.

You can use unauthorized in Route Handlers to ensure only authenticated users can access the endpoint.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  experimental: {
    authInterrupts: true,
  },
}
 
export default nextConfig
```

Example 2 (python):
```python
import { verifySession } from '@/app/lib/dal'
import { unauthorized } from 'next/navigation'
 
export default async function DashboardPage() {
  const session = await verifySession()
 
  if (!session) {
    unauthorized()
  }
 
  // Render the dashboard for authenticated users
  return (
    <main>
      <h1>Welcome to the Dashboard</h1>
      <p>Hi, {session.user.name}.</p>
    </main>
  )
}
```

Example 3 (python):
```python
import { verifySession } from '@/app/lib/dal'
import { unauthorized } from 'next/navigation'
 
export default async function DashboardPage() {
  const session = await verifySession()
 
  if (!session) {
    unauthorized()
  }
 
  return <div>Dashboard</div>
}
```

Example 4 (python):
```python
import Login from '@/app/components/Login'
 
export default function UnauthorizedPage() {
  return (
    <main>
      <h1>401 - Unauthorized</h1>
      <p>Please log in to access this page.</p>
      <Login />
    </main>
  )
}
```

---

## How to build a Progressive Web Application (PWA) with Next.js

**URL:** https://nextjs.org/docs/15/app/guides/progressive-web-apps

**Contents:**
- How to build a Progressive Web Application (PWA) with Next.js
- Creating a PWA with Next.js
  - 1. Creating the Web App Manifest
  - 2. Implementing Web Push Notifications
  - 3. Implementing Server Actions
  - 4. Generating VAPID Keys
  - 5. Creating a Service Worker
  - 6. Adding to Home Screen
  - 7. Testing Locally
  - 8. Securing your application

Progressive Web Applications (PWAs) offer the reach and accessibility of web applications combined with the features and user experience of native mobile apps. With Next.js, you can create PWAs that provide a seamless, app-like experience across all platforms without the need for multiple codebases or app store approvals.

Next.js provides built-in support for creating a web app manifest using the App Router. You can create either a static or dynamic manifest file:

For example, create a app/manifest.ts or app/manifest.json file:

This file should contain information about the name, icons, and how it should be displayed as an icon on the user's device. This will allow users to install your PWA on their home screen, providing a native app-like experience.

You can use tools like favicon generators to create the different icon sets and place the generated files in your public/ folder.

Web Push Notifications are supported with all modern browsers, including:

This makes PWAs a viable alternative to native apps. Notably, you can trigger install prompts without needing offline support.

Web Push Notifications allow you to re-engage users even when they're not actively using your app. Here's how to implement them in a Next.js application:

First, let's create the main page component in app/page.tsx. We'll break it down into smaller parts for better understanding. First, weâ€™ll add some of the imports and utilities weâ€™ll need. Itâ€™s okay that the referenced Server Actions do not yet exist:

Letâ€™s now add a component to manage subscribing, unsubscribing, and sending push notifications.

Finally, letâ€™s create a component to show a message for iOS devices to instruct them to install to their home screen, and only show this if the app is not already installed.

Now, letâ€™s create the Server Actions which this file calls.

Create a new file to contain your actions at app/actions.ts. This file will handle creating subscriptions, deleting subscriptions, and sending notifications.

Sending a notification will be handled by our service worker, created in step 5.

In a production environment, you would want to store the subscription in a database for persistence across server restarts and to manage multiple users' subscriptions.

To use the Web Push API, you need to generate VAPID keys. The simplest way is to use the web-push CLI directly:

First, install web-push globally:

Generate the VAPID keys by running:

Copy the output and paste the keys into your .env file:

Create a public/sw.js file for your service worker:

This service worker supports custom images and notifications. It handles incoming push events and notification clicks.

Remember to test your service worker thoroughly to ensure it behaves as expected across different devices and browsers. Also, make sure to update the 'https://your-website.com' link in the notificationclick event listener to the appropriate URL for your application.

The InstallPrompt component defined in step 2 shows a message for iOS devices to instruct them to install to their home screen.

To ensure your application can be installed to a mobile home screen, you must have:

Modern browsers will automatically show an installation prompt to users when these criteria are met. You can provide a custom installation button with beforeinstallprompt, however, we do not recommend this as it is not cross browser and platform (does not work on Safari iOS).

To ensure you can view notifications locally, ensure that:

Security is a crucial aspect of any web application, especially for PWAs. Next.js allows you to configure security headers using the next.config.js file. For example:

Letâ€™s go over each of these options:

Learn more about defining Content Security Policies with Next.js.

**Examples:**

Example 1 (python):
```python
import type { MetadataRoute } from 'next'
 
export default function manifest(): MetadataRoute.Manifest {
  return {
    name: 'Next.js PWA',
    short_name: 'NextPWA',
    description: 'A Progressive Web App built with Next.js',
    start_url: '/',
    display: 'standalone',
    background_color: '#ffffff',
    theme_color: '#000000',
    icons: [
      {
        src: '/icon-192x192.png',
        sizes: '192x192',
        type: 'image/png',
      },
      {
        src: '/icon-512x512.png',
        sizes: '512x512',
        type: 'image/png',
      },
    ],
  }
}
```

Example 2 (python):
```python
'use client'
 
import { useState, useEffect } from 'react'
import { subscribeUser, unsubscribeUser, sendNotification } from './actions'
 
function urlBase64ToUint8Array(base64String: string) {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/')
 
  const rawData = window.atob(base64)
  const outputArray = new Uint8Array(rawData.length)
 
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i)
  }
  return outputArray
}
```

Example 3 (javascript):
```javascript
function PushNotificationManager() {
  const [isSupported, setIsSupported] = useState(false)
  const [subscription, setSubscription] = useState<PushSubscription | null>(
    null
  )
  const [message, setMessage] = useState('')
 
  useEffect(() => {
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      setIsSupported(true)
      registerServiceWorker()
    }
  }, [])
 
  async function registerServiceWorker() {
    const registration = await navigator.serviceWorker.register('/sw.js', {
      scope: '/',
      updateViaCache: 'none',
    })
    const sub = await registration.pushManager.getSubscription()
    setSubscription(sub)
  }
 
  async function subscribeToPush() {
    const registration = await navigator.serviceWorker.ready
    const sub = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(
        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!
      ),
    })
    setSubscription(sub)
    const serializedSub = JSON.parse(JSON.stringify(sub))
    await subscribeUser(serializedSub)
  }
 
  async function unsubscribeFromPush() {
    await subscription?.unsubscribe()
    setSubscription(null)
    await unsubscribeUser()
  }
 
  async function sendTestNotification() {
    if (subscription) {
      await sendNotification(message)
      setMessage('')
    }
  }
 
  if (!isSupported) {
    return <p>Push notifications are not supported in this browser.</p>
  }
 
  return (
    <div>
      <h3>Push Notifications</h3>
      {subscription ? (
        <>
          <p>You are subscribed to push notifications.</p>
          <button onClick={unsubscribeFromPush}>Unsubscribe</button>
          <input
            type="text"
            placeholder="Enter notification message"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
          />
          <button onClick={sendTestNotification}>Send Test</button>
        </>
      ) : (
        <>
          <p>You are not subscribed to push notifications.</p>
          <button onClick={subscribeToPush}>Subscribe</button>
        </>
      )}
    </div>
  )
}
```

Example 4 (javascript):
```javascript
function InstallPrompt() {
  const [isIOS, setIsIOS] = useState(false)
  const [isStandalone, setIsStandalone] = useState(false)
 
  useEffect(() => {
    setIsIOS(
      /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream
    )
 
    setIsStandalone(window.matchMedia('(display-mode: standalone)').matches)
  }, [])
 
  if (isStandalone) {
    return null // Don't show install button if already installed
  }
 
  return (
    <div>
      <h3>Install App</h3>
      <button>Add to Home Screen</button>
      {isIOS && (
        <p>
          To install this app on your iOS device, tap the share button
          <span role="img" aria-label="share icon">
            {' '}
            âŽ‹{' '}
          </span>
          and then "Add to Home Screen"
          <span role="img" aria-label="plus icon">
            {' '}
            âž•{' '}
          </span>.
        </p>
      )}
    </div>
  )
}
 
export default function Page() {
  return (
    <div>
      <PushNotificationManager />
      <InstallPrompt />
    </div>
  )
}
```

---

## API Reference

**URL:** https://nextjs.org/docs/pages/api-reference

**Contents:**
- API Reference
  - Components
  - File-system conventions
  - Functions
  - Configuration
  - CLI
  - Edge Runtime
  - Turbopack

---

## unstable_noStore

**URL:** https://nextjs.org/docs/app/api-reference/functions/unstable_noStore

**Contents:**
- unstable_noStore
- Usage
- Version History

In version 15, we recommend using connection instead of unstable_noStore.

unstable_noStore can be used to declaratively opt out of static rendering and indicate a particular component should not be cached.

If you prefer not to pass additional options to fetch, like cache: 'no-store', next: { revalidate: 0 } or in cases where fetch is not available, you can use noStore() as a replacement for all of these use cases.

**Examples:**

Example 1 (python):
```python
import { unstable_noStore as noStore } from 'next/cache';
 
export default async function ServerComponent() {
  noStore();
  const result = await db.query(...);
  ...
}
```

Example 2 (python):
```python
import { unstable_noStore as noStore } from 'next/cache';
 
export default async function ServerComponent() {
  noStore();
  const result = await db.query(...);
  ...
}
```

---

## instrumentation.js

**URL:** https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation

**Contents:**
- instrumentation.js
- Exports
  - register (optional)
  - onRequestError (optional)
    - Parameters
  - Specifying the runtime
- Version History
- Learn more about Instrumentation
  - Instrumentation

The instrumentation.js|ts file is used to integrate observability tools into your application, allowing you to track the performance and behavior, and to debug issues in production.

To use it, place the file in the root of your application or inside a src folder if using one.

The file exports a register function that is called once when a new Next.js server instance is initiated. register can be an async function.

You can optionally export an onRequestError function to track server errors to any custom observability provider.

The function accepts three parameters: error, request, and context.

The instrumentation.js file works in both the Node.js and Edge runtime, however, you can use process.env.NEXT_RUNTIME to target a specific runtime.

**Examples:**

Example 1 (python):
```python
import { registerOTel } from '@vercel/otel'
 
export function register() {
  registerOTel('next-app')
}
```

Example 2 (python):
```python
import { type Instrumentation } from 'next'
 
export const onRequestError: Instrumentation.onRequestError = async (
  err,
  request,
  context
) => {
  await fetch('https://.../report-error', {
    method: 'POST',
    body: JSON.stringify({
      message: err.message,
      request,
      context,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  })
}
```

Example 3 (unknown):
```unknown
export function onRequestError(
  error: { digest: string } & Error,
  request: {
    path: string // resource path, e.g. /blog?name=foo
    method: string // request method. e.g. GET, POST, etc
    headers: { [key: string]: string | string[] }
  },
  context: {
    routerKind: 'Pages Router' | 'App Router' // the router type
    routePath: string // the route file path, e.g. /app/blog/[dynamic]
    routeType: 'render' | 'route' | 'action' | 'proxy' // the context in which the error occurred
    renderSource:
      | 'react-server-components'
      | 'react-server-components-payload'
      | 'server-rendering'
    revalidateReason: 'on-demand' | 'stale' | undefined // undefined is a normal request without revalidation
    renderType: 'dynamic' | 'dynamic-resume' // 'dynamic-resume' for PPR
  }
): void | Promise<void>
```

Example 4 (unknown):
```unknown
export function register() {
  if (process.env.NEXT_RUNTIME === 'edge') {
    return require('./register.edge')
  } else {
    return require('./register.node')
  }
}
 
export function onRequestError() {
  if (process.env.NEXT_RUNTIME === 'edge') {
    return require('./on-request-error.edge')
  } else {
    return require('./on-request-error.node')
  }
}
```

---

## How to implement Incremental Static Regeneration (ISR)

**URL:** https://nextjs.org/docs/15/app/guides/incremental-static-regeneration

**Contents:**
- How to implement Incremental Static Regeneration (ISR)
- Reference
  - Route segment config
  - Functions
- Examples
  - Time-based revalidation
  - On-demand revalidation with revalidatePath
  - On-demand revalidation with revalidateTag
  - Handling uncaught exceptions
  - Customizing the cache location

Incremental Static Regeneration (ISR) enables you to:

Here's a minimal example:

Here's how this example works:

This fetches and displays a list of blog posts on /blog. After an hour has passed, the next visitor will still receive the cached (stale) version of the page immediately for a fast response. Simultaneously, Next.js triggers regeneration of a fresh version in the background. Once the new version is successfully generated, it replaces the cached version, and subsequent visitors will receive the updated content.

We recommend setting a high revalidation time. For instance, 1 hour instead of 1 second. If you need more precision, consider using on-demand revalidation. If you need real-time data, consider switching to dynamic rendering.

For a more precise method of revalidation, invalidate cached pages on-demand with the revalidatePath function.

For example, this Server Action would get called after adding a new post. Regardless of how you retrieve your data in your Server Component, either using fetch or connecting to a database, this will invalidate the cache for the entire route. The next request to that route will trigger regeneration and serve fresh data, which will then be cached for subsequent requests.

Note: revalidatePath invalidates the cache entries but regeneration happens on the next request. If you want to eagerly regenerate the cache entry immediately instead of waiting for the next request, you can use the Pages router res.revalidate method. We're working on adding new methods to provide eager regeneration capabilities for the App Router.

View a demo and explore the source code.

For most use cases, prefer revalidating entire paths. If you need more granular control, you can use the revalidateTag function. For example, you can tag individual fetch calls:

If you are using an ORM or connecting to a database, you can use unstable_cache:

You can then use revalidateTag in a Server Actions or Route Handler:

If an error is thrown while attempting to revalidate data, the last successfully generated data will continue to be served from the cache. On the next subsequent request, Next.js will retry revalidating the data. Learn more about error handling.

You can configure the Next.js cache location if you want to persist cached pages and data to durable storage, or share the cache across multiple containers or instances of your Next.js application. Learn more.

If you are using the fetch API, you can add additional logging to understand which requests are cached or uncached. Learn more about the logging option.

To verify your pages are cached and revalidated correctly in production, you can test locally by running next build and then next start to run the production Next.js server.

This will allow you to test ISR behavior as it would work in a production environment. For further debugging, add the following environment variable to your .env file:

This will make the Next.js server console log ISR cache hits and misses. You can inspect the output to see which pages are generated during next build, as well as how pages are updated as paths are accessed on-demand.

Learn how to configure ISR when self-hosting Next.js.

**Examples:**

Example 1 (javascript):
```javascript
interface Post {
  id: string
  title: string
  content: string
}
 
// Next.js will invalidate the cache when a
// request comes in, at most once every 60 seconds.
export const revalidate = 60
 
export async function generateStaticParams() {
  const posts: Post[] = await fetch('https://api.vercel.app/blog').then((res) =>
    res.json()
  )
  return posts.map((post) => ({
    id: String(post.id),
  }))
}
 
export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post: Post = await fetch(`https://api.vercel.app/blog/${id}`).then(
    (res) => res.json()
  )
  return (
    <main>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </main>
  )
}
```

Example 2 (javascript):
```javascript
interface Post {
  id: string
  title: string
  content: string
}
 
export const revalidate = 3600 // invalidate every hour
 
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog')
  const posts: Post[] = await data.json()
  return (
    <main>
      <h1>Blog Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  )
}
```

Example 3 (python):
```python
'use server'
 
import { revalidatePath } from 'next/cache'
 
export async function createPost() {
  // Invalidate the cache for the /posts route
  revalidatePath('/posts')
}
```

Example 4 (javascript):
```javascript
export default async function Page() {
  const data = await fetch('https://api.vercel.app/blog', {
    next: { tags: ['posts'] },
  })
  const posts = await data.json()
  // ...
}
```

---

## use cache: private

**URL:** https://nextjs.org/docs/app/api-reference/directives/use-cache-private

**Contents:**
- use cache: private
- Usage
  - Basic example
- Request APIs allowed in private caches
- Version History
- Related
  - use cache
  - cacheComponents
  - cacheLife
  - cacheTag

The 'use cache: private' directive works just like use cache, but allows you to use runtime APIs like cookies, headers, or search params.

Good to know: Unlike use cache, private caches are not prerendered statically as they contain personalized data that is not shared between users.

To use 'use cache: private', enable the cacheComponents flag in your next.config.ts file:

Then add 'use cache: private' to your function along with a cacheLife configuration.

The following request-specific APIs can be used inside 'use cache: private' functions:

Note: The connection() API is prohibited in both use cache and 'use cache: private' as it provides connection-specific information that cannot be safely cached.

**Examples:**

Example 1 (python):
```python
import type { NextConfig } from 'next'
 
const nextConfig: NextConfig = {
  cacheComponents: true,
}
 
export default nextConfig
```

Example 2 (python):
```python
import { Suspense } from 'react'
import { cookies } from 'next/headers'
import { cacheLife, cacheTag } from 'next/cache'
 
export default async function ProductPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
 
  return (
    <div>
      <ProductDetails id={id} />
      <Suspense fallback={<div>Loading recommendations...</div>}>
        <Recommendations productId={id} />
      </Suspense>
    </div>
  )
}
 
async function Recommendations({ productId }: { productId: string }) {
  const recommendations = await getRecommendations(productId)
 
  return (
    <div>
      {recommendations.map((rec) => (
        <ProductCard key={rec.id} product={rec} />
      ))}
    </div>
  )
}
 
async function getRecommendations(productId: string) {
  'use cache: private'
  cacheTag(`recommendations-${productId}`)
  cacheLife({ stale: 60 }) // Minimum 30 seconds required for runtime prefetch
 
  // Access cookies within private cache functions
  const sessionId = (await cookies()).get('session-id')?.value || 'guest'
 
  return getPersonalizedRecommendations(productId, sessionId)
}
```

---
